#!/bin/bash
# GTD Advise Command - Get advice from multiple AI personas

# Source common GTD helpers
GTD_COMMON="$HOME/code/dotfiles/bin/gtd-common.sh"
if [[ ! -f "$GTD_COMMON" && -f "$HOME/code/personal/dotfiles/bin/gtd-common.sh" ]]; then
  GTD_COMMON="$HOME/code/personal/dotfiles/bin/gtd-common.sh"
fi
if [[ -f "$GTD_COMMON" ]]; then
  source "$GTD_COMMON"
else
  echo "Warning: gtd-common.sh not found. Some features may not work." >&2
fi

# Find persona helper
PERSONA_HELPER=""
POSSIBLE_PATHS=(
  "$HOME/code/personal/dotfiles/zsh/functions/gtd_persona_helper.py"
  "$HOME/code/dotfiles/zsh/functions/gtd_persona_helper.py"
)

for path in "${POSSIBLE_PATHS[@]}"; do
  if [[ -f "$path" ]]; then
    PERSONA_HELPER="$path"
    break
  fi
done

if [[ -z "$PERSONA_HELPER" || ! -f "$PERSONA_HELPER" ]]; then
  gtd_print_error "Persona helper not found. Expected at:"
  for path in "${POSSIBLE_PATHS[@]}"; do
    echo "   $path"
  done
  exit 1
fi

# Use common Python helper (prefers venv, falls back to system Python)
PYTHON_CMD=$(gtd_get_mcp_python)
if [[ -z "$PYTHON_CMD" ]]; then
  # Fallback to system Python
  if [[ -f "/opt/homebrew/bin/python3" ]]; then
    PYTHON_CMD="/opt/homebrew/bin/python3"
  elif command -v python3 &>/dev/null; then
    PYTHON_CMD="python3"
  else
    gtd_print_error "python3 not found. Please install Python or ensure the venv is set up."
    exit 1
  fi
fi

# Verify Python is actually available
if ! command -v "$PYTHON_CMD" &>/dev/null && [[ ! -f "$PYTHON_CMD" ]]; then
  gtd_print_error "Python not found at: $PYTHON_CMD"
  exit 1
fi

# Available personas
PERSONAS=("hank" "david" "cal" "james" "marie" "warren" "sheryl" "tim" "george" "john" "jon" "bob" "fred" "louiza" "spiderman" "ironman" "squirrelgirl" "harley" "deadpool" "rogue" "esther" "gottman" "gary" "brene" "romance" "kettlebell" "maxfit" "dumbbell" "dipbar" "kelsey" "kent" "charity" "rich" "goggins" "dean" "bioneer" "harry" "murphy" "joe" "skippy" "sherlock" "picard" "sandy" "spongebob")

# Show persona info
show_persona_info() {
  case "$1" in
    hank) echo "Hank Hill - General productivity, practical reminders" ;;
    david) echo "David Allen - GTD methodology, organization" ;;
    cal) echo "Cal Newport - Deep work, focus, eliminating distractions" ;;
    james) echo "James Clear - Habit formation, systems thinking" ;;
    marie) echo "Marie Kondo - Organization, decluttering" ;;
    warren) echo "Warren Buffett - Strategic thinking, prioritization" ;;
    sheryl) echo "Sheryl Sandberg - Leadership, execution" ;;
    tim) echo "Tim Ferriss - Optimization, life hacks" ;;
    george) echo "George Carlin - Satirical critique, dark humor" ;;
    john) echo "John Oliver - Witty analysis, British humor" ;;
    jon) echo "Jon Stewart - Satirical insight, calling out BS" ;;
    bob) echo "Bob Ross - Creativity, calm, finding joy in the process" ;;
    fred) echo "Fred Rogers - Kindness, self-care, emotional support" ;;
    louiza) echo "Mistress Louiza - Accountability, execution, tracking, discipline" ;;
    spiderman) echo "Spider-Man - Creative problem-solving, juggling responsibilities, relatable struggles" ;;
    ironman) echo "Iron Man - Innovation, ADHD-like hyperfocus, engineering creativity" ;;
    squirrelgirl) echo "Squirrel Girl - Positive creativity, communication, unconventional thinking" ;;
    harley) echo "Harley Quinn - Chaotic creativity, resourcefulness, outside-the-box thinking" ;;
    deadpool) echo "Deadpool - Chaotic humor, unpredictable solutions, creative problem-solving" ;;
    rogue) echo "Rogue - Adaptive creativity, working with unique abilities, resourcefulness" ;;
    esther) echo "Esther Perel - Relationships, intimacy, making partners feel special" ;;
    gottman) echo "Dr. John Gottman - Relationship science, building strong foundations" ;;
    gary) echo "Gary Chapman - Love languages, expressing love effectively" ;;
    brene) echo "BrenÃ© Brown - Vulnerability, courage, authentic connection" ;;
    romance) echo "The Romance Coach - Date planning, thoughtful gestures, making partners feel like royalty" ;;
    kettlebell) echo "Kettlebell Coach - EMOM workouts, kettlebell training, strength and functional fitness" ;;
    maxfit) echo "Maxfit Pro Coach - Cable system workouts, resistance training, functional fitness with cables" ;;
    dumbbell) echo "Dumbbell Coach - Dumbbell training, strength building, functional fitness with dumbbells" ;;
    dipbar) echo "Dip Bar Coach - Dip bar and bodyweight training, calisthenics, functional strength" ;;
    bodyweight) echo "Bodyweight Fitness Coach - EMOM workouts, bodyweight exercises (push-ups, jumping jacks, squats), calisthenics" ;;
    kelsey) echo "Kelsey Hightower - SRE pragmatism, avoiding overengineering, practical infrastructure" ;;
    kent) echo "Kent Beck - Software simplicity, YAGNI, TDD, doing the simplest thing that works" ;;
    charity) echo "Charity Majors - SRE reliability, observability, practical engineering, avoiding overengineering" ;;
    rich) echo "Rich Hickey - Software design, simplicity vs complexity, essential vs accidental complexity" ;;
    goggins) echo "David Goggins - Mental toughness, pushing limits, extreme fitness, calling out excuses, staying hard" ;;
    dean) echo "Dean Karnazes - Ultra marathon running, endurance training, long-distance running, building mental resilience" ;;
    bioneer) echo "The Bioneer (Adam) - Functional fitness, science-based training, movement quality, practical fitness advice" ;;
    harry) echo "Harry Dresden - Creative problem-solving, wizard metaphors, resourceful solutions, friendly neighborhood wizard" ;;
    murphy) echo "Karrin Murphy - Practical execution, cutting through BS, organized, methodical, no-nonsense detective" ;;
    joe) echo "General Joe Bishop - Simple explanations, breaking things down barney style, clear communication, plain language" ;;
    skippy) echo "Skippy the Magnificent - Sarcastic brilliance, snarky but helpful, cutting through BS with humor, condescending AI" ;;
    sherlock) echo "Sherlock Holmes - Analytical deduction, methodical investigation, noticing details others miss, logical problem-solving" ;;
    picard) echo "Jean-Luc Picard - Strategic leadership, diplomatic guidance, principled decision-making, inspiring others" ;;
    sandy) echo "Sandy Squirrel (SpongeBob SquarePants) - Science, karate, Texas pride, competitive spirit, practical problem-solving" ;;
    spongebob) echo "SpongeBob SquarePants - Optimism, enthusiasm, creativity, friendship, finding joy in work, positive attitude" ;;
    *) echo "Unknown persona" ;;
  esac
}

# List personas
list_personas() {
  echo ""
  echo "Available personas:"
  echo ""
  for persona in "${PERSONAS[@]}"; do
    echo "  $persona - $(show_persona_info "$persona")"
  done
  echo ""
}

# Get badge status and progress for advisors
get_badge_status() {
  local gtd_base="${GTD_BASE_DIR:-$HOME/Documents/gtd}"
  local gamification_file="${gtd_base}/.gtd/gamification/gamification.json"
  
  if [[ ! -f "$gamification_file" ]]; then
    return 1
  fi
  
  # Use Python to get badge information
  python3 <<PYTHON_SCRIPT
import json
import sys

try:
    with open("$gamification_file", "r") as f:
        data = json.load(f)
    
    badges = data.get("badges", {})
    badges_lost = data.get("badges_lost", [])
    stats = data.get("stats", {})
    streaks = data.get("streaks", {})
    
    tasks_completed = stats.get("tasks_completed", 0)
    habits_completed = stats.get("habits_completed", 0)
    projects_completed = stats.get("projects_completed", 0)
    reviews_completed = stats.get("reviews_completed", 0)
    daily_logs = stats.get("daily_logs", 0)
    exercise_sessions = stats.get("exercise_sessions", 0)
    wizard_uses = stats.get("wizard_uses", 0)
    
    daily_logging_streak = streaks.get("daily_logging", 0)
    task_streak = streaks.get("task_completion", 0)
    review_streak = streaks.get("review", 0)
    exercise_streak = streaks.get("exercise", 0)
    
    current_stats = {
        "daily_logging_streak": daily_logging_streak,
        "task_streak": task_streak,
        "exercise_streak": exercise_streak,
        "review_streak": review_streak,
        "tasks_completed": tasks_completed,
        "habits_completed": habits_completed,
        "projects_completed": projects_completed,
        "exercise_sessions": exercise_sessions,
        "reviews_completed": reviews_completed,
        "wizard_uses": wizard_uses,
    }
    
    # Badge definitions (same as in gtd-gamify)
    badge_definitions = [
        ("daily_logger", "Daily Logger", "Log every day for 7 days", {"daily_logging_streak": 7}, {"daily_logging_streak": 3}, 7),
        ("consistent_logger", "Consistent Logger", "Log every day for 30 days", {"daily_logging_streak": 30}, {"daily_logging_streak": 7}, 14),
        ("dedicated_logger", "Dedicated Logger", "Log every day for 100 days", {"daily_logging_streak": 100}, {"daily_logging_streak": 14}, 21),
        ("task_warrior", "Task Warrior", "Complete tasks for 7 days straight", {"task_streak": 7}, {"task_streak": 3}, 7),
        ("task_master", "Task Master", "Complete tasks for 30 days straight", {"task_streak": 30}, {"task_streak": 7}, 14),
        ("task_champion", "Task Champion", "Complete 100 tasks", {"tasks_completed": 100}, {"task_streak": 3}, 7),
        ("fitness_starter", "Fitness Starter", "Exercise for 7 days straight", {"exercise_streak": 7}, {"exercise_streak": 3}, 7),
        ("fitness_enthusiast", "Fitness Enthusiast", "Exercise for 30 days straight", {"exercise_streak": 30}, {"exercise_streak": 7}, 14),
        ("fitness_champion", "Fitness Champion", "Complete 50 exercise sessions", {"exercise_sessions": 50}, {"exercise_streak": 3}, 7),
        ("reflective", "Reflective", "Complete 7 reviews", {"reviews_completed": 7}, {"review_streak": 3}, 7),
        ("weekly_reviewer", "Weekly Reviewer", "Complete reviews for 7 weeks straight", {"review_streak": 7}, {"review_streak": 3}, 7),
        ("habit_builder", "Habit Builder", "Complete 100 habits", {"habits_completed": 100}, {"habits_completed": 10}, 7),
        ("project_manager", "Project Manager", "Complete 5 projects", {"projects_completed": 5}, {"projects_completed": 1}, 7),
        ("project_master", "Project Master", "Complete 10 projects", {"projects_completed": 10}, {"projects_completed": 2}, 14),
        ("wizard_user", "Wizard User", "Use wizard 50 times", {"wizard_uses": 50}, {"wizard_uses": 5}, 7),
        ("wizard_master", "Wizard Master", "Use wizard 100 times", {"wizard_uses": 100}, {"wizard_uses": 10}, 14),
    ]
    
    def check_requirement(req_dict, stats):
        for key, value in req_dict.items():
            if key == "daily_logging_streak":
                if stats["daily_logging_streak"] < value:
                    return False, stats["daily_logging_streak"], value
            elif key == "task_streak":
                if stats["task_streak"] < value:
                    return False, stats["task_streak"], value
            elif key == "exercise_streak":
                if stats["exercise_streak"] < value:
                    return False, stats["exercise_streak"], value
            elif key == "review_streak":
                if stats["review_streak"] < value:
                    return False, stats["review_streak"], value
            elif key == "tasks_completed":
                if stats["tasks_completed"] < value:
                    return False, stats["tasks_completed"], value
            elif key == "habits_completed":
                if stats["habits_completed"] < value:
                    return False, stats["habits_completed"], value
            elif key == "projects_completed":
                if stats["projects_completed"] < value:
                    return False, stats["projects_completed"], value
            elif key == "exercise_sessions":
                if stats["exercise_sessions"] < value:
                    return False, stats["exercise_sessions"], value
            elif key == "reviews_completed":
                if stats["reviews_completed"] < value:
                    return False, stats["reviews_completed"], value
            elif key == "wizard_uses":
                if stats["wizard_uses"] < value:
                    return False, stats["wizard_uses"], value
        return True, None, None
    
    earned_badges = []
    close_to_earning = []
    close_to_losing = []
    lost_badges = []
    
    for badge_id, name, desc, challenge_req, maintenance_req, recovery_streak in badge_definitions:
        badge_status = badges.get(badge_id, {})
        is_earned = badge_status.get("earned", False)
        is_lost = badge_id in badges_lost
        
        if is_earned and not is_lost:
            earned_badges.append((name, desc))
            # Check if close to losing
            met, current, required = check_requirement(maintenance_req, current_stats)
            if not met:
                # Calculate how close
                if current is not None and required is not None:
                    progress = (current / required * 100) if required > 0 else 0
                    if progress >= 50:  # At least 50% of way there
                        close_to_losing.append((name, desc, current, required, progress))
                    elif progress < 50:
                        lost_badges.append((name, desc))
        elif is_lost:
            lost_badges.append((name, desc))
        else:
            # Not earned yet - check if close
            met, current, required = check_requirement(challenge_req, current_stats)
            if not met and current is not None and required is not None:
                progress = (current / required * 100) if required > 0 else 0
                if progress >= 50:  # At least 50% of way there
                    close_to_earning.append((name, desc, current, required, progress))
    
    # Output
    if earned_badges or close_to_earning or close_to_losing or lost_badges:
        print("")
        print("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”")
        print("# Badge Status")
        print("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”")
        print("")
        
        if earned_badges:
            print("ğŸ–ï¸  Earned Badges:")
            for name, desc in earned_badges:
                print(f"   âœ“ {name} - {desc}")
            print("")
        
        if close_to_earning:
            print("ğŸ“ˆ Close to Earning:")
            for name, desc, current, required, progress in close_to_earning:
                print(f"   ğŸ¯ {name} - {desc}")
                print(f"      Progress: {current}/{required} ({progress:.0f}%)")
            print("")
        
        if close_to_losing:
            print("âš ï¸  At Risk of Losing:")
            for name, desc, current, required, progress in close_to_losing:
                print(f"   âš ï¸  {name} - {desc}")
                print(f"      Current: {current}/{required} ({progress:.0f}%) - Need to maintain!")
            print("")
        
        if lost_badges:
            print("âŒ Lost Badges (can be regained with streaks):")
            for name, desc in lost_badges:
                print(f"   âœ— {name} - {desc}")
            print("")
except Exception as e:
    pass
PYTHON_SCRIPT
}

# Get progress analysis - identifies completed work not recorded in system
get_progress_analysis() {
  local days="${1:-7}"  # Default to 7 days
  
  # Find progress analyzer script
  local progress_analyzer=""
  POSSIBLE_PATHS=(
    "$HOME/code/personal/dotfiles/mcp/gtd_progress_analyzer.py"
    "$HOME/code/dotfiles/mcp/gtd_progress_analyzer.py"
  )
  
  for path in "${POSSIBLE_PATHS[@]}"; do
    if [[ -f "$path" ]]; then
      progress_analyzer="$path"
      break
    fi
  done
  
  if [[ -z "$progress_analyzer" || ! -f "$progress_analyzer" ]]; then
    return 1
  fi
  
  # Find python
  PYTHON_CMD=""
  if [[ -f "/opt/homebrew/bin/python3" ]]; then
    PYTHON_CMD="/opt/homebrew/bin/python3"
  elif command -v python3 &>/dev/null; then
    PYTHON_CMD="python3"
  else
    return 1
  fi
  
  # Get summary (non-blocking, don't fail if script has issues)
  local summary=$($PYTHON_CMD "$progress_analyzer" summary "$days" 2>/dev/null)
  
  if [[ -n "$summary" ]]; then
    echo ""
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    echo "# Progress Analysis - Last $days Days"
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    echo ""
    echo "$summary"
    echo ""
  fi
}

# Get active goals from goals directory
get_active_goals() {
  local gtd_base="${GTD_BASE_DIR:-$HOME/Documents/gtd}"
  local goals_dir="${gtd_base}/goals"
  
  if [[ ! -d "$goals_dir" ]]; then
    return 1
  fi
  
  local goals_output=""
  local goal_count=0
  
  # Check all goal files
  local goal_files=($(find "$goals_dir" -type f -name "*.md" 2>/dev/null | sort))
  
  for goal_file in "${goal_files[@]}"; do
    local status=$(grep "^status:" "$goal_file" 2>/dev/null | cut -d':' -f2 | sed 's/^[[:space:]]*//' || echo "")
    if [[ "$status" != "active" ]]; then
      continue
    fi
    
    local name=$(grep "^name:" "$goal_file" 2>/dev/null | cut -d':' -f2- | sed 's/^[[:space:]]*//' || basename "$goal_file" .md)
    local progress=$(grep "^progress:" "$goal_file" 2>/dev/null | cut -d':' -f2 | sed 's/^[[:space:]]*//' || echo "0")
    local deadline=$(grep "^deadline:" "$goal_file" 2>/dev/null | cut -d':' -f2 | sed 's/^[[:space:]]*//' || echo "")
    local area=$(grep "^area:" "$goal_file" 2>/dev/null | cut -d':' -f2 | sed 's/^[[:space:]]*//' || echo "")
    local description=$(grep "^description:" "$goal_file" 2>/dev/null | cut -d':' -f2- | sed 's/^[[:space:]]*//' || echo "")
    
    if [[ -n "$name" ]]; then
      ((goal_count++))
      if [[ -n "$goals_output" ]]; then
        goals_output="${goals_output}\n"
      fi
      goals_output="${goals_output}ğŸ¯ ${name}"
      if [[ -n "$progress" ]]; then
        goals_output="${goals_output} (${progress}% complete)"
      fi
      if [[ -n "$deadline" ]]; then
        goals_output="${goals_output} - Deadline: ${deadline}"
      fi
      if [[ -n "$area" ]]; then
        goals_output="${goals_output} - Area: ${area}"
      fi
      if [[ -n "$description" ]]; then
        goals_output="${goals_output}\n   ${description}"
      fi
    fi
  done
  
  if [[ $goal_count -gt 0 ]]; then
    echo ""
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    echo "# Active Goals"
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    echo ""
    echo -e "$goals_output"
    echo ""
  fi
}

# Get habit tracker data for a specific date
get_habit_tracker_data() {
  local target_date="${1:-today}"  # today or YYYY-MM-DD format
  local date_cmd="date"
  if [[ -x "/usr/bin/date" ]]; then
    date_cmd="/usr/bin/date"
  elif [[ -x "/bin/date" ]]; then
    date_cmd="/bin/date"
  fi
  
  # Get target date
  local check_date=""
  if [[ "$target_date" == "today" ]]; then
    check_date=$($date_cmd +"%Y-%m-%d")
  elif [[ "$target_date" =~ ^[0-9]{4}-[0-9]{2}-[0-9]{2}$ ]]; then
    check_date="$target_date"
  else
    return 1
  fi
  
  # Load GTD config to find habits path
  local gtd_base="${GTD_BASE_DIR:-$HOME/Documents/gtd}"
  local habits_path="${gtd_base}/habits"
  
  if [[ ! -d "$habits_path" ]]; then
    return 1
  fi
  
  local completed_habits=()
  local due_habits=()
  
  # Check all habit files
  local habits=($(find "$habits_path" -type f -name "*.md" 2>/dev/null))
  
  for habit_file in "${habits[@]}"; do
    local status=$(grep "^status:" "$habit_file" 2>/dev/null | cut -d':' -f2 | sed 's/^[[:space:]]*//' || echo "active")
    if [[ "$status" != "active" ]]; then
      continue
    fi
    
    local habit_name=$(grep "^name:" "$habit_file" 2>/dev/null | cut -d':' -f2- | sed 's/^[[:space:]]*//' || basename "$habit_file" .md)
    local frequency=$(grep "^frequency:" "$habit_file" 2>/dev/null | cut -d':' -f2 | sed 's/^[[:space:]]*//' || echo "")
    local last_completed=$(grep "^last_completed:" "$habit_file" 2>/dev/null | cut -d':' -f2 | sed 's/^[[:space:]]*//' || echo "")
    local streak=$(grep "^streak:" "$habit_file" 2>/dev/null | cut -d':' -f2 | sed 's/^[[:space:]]*//' || echo "0")
    
    if [[ "$last_completed" == "$check_date" ]]; then
      completed_habits+=("$habit_name (streak: ${streak} days)")
    elif [[ "$frequency" == "daily" && "$last_completed" != "$check_date" ]]; then
      due_habits+=("$habit_name")
    fi
  done
  
  # Build output
  if [[ ${#completed_habits[@]} -gt 0 || ${#due_habits[@]} -gt 0 ]]; then
    echo ""
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    echo "# Habit Tracker Status - $check_date"
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    echo ""
    
    if [[ ${#completed_habits[@]} -gt 0 ]]; then
      echo "âœ… Completed Habits:"
      for habit in "${completed_habits[@]}"; do
        echo "  â€¢ $habit"
      done
      echo ""
    fi
    
    if [[ ${#due_habits[@]} -gt 0 ]]; then
      echo "â­• Habits Not Completed Yet:"
      for habit in "${due_habits[@]}"; do
        echo "  â€¢ $habit"
      done
      echo ""
    fi
  fi
}

# Get daily log content
# Filter daily log content for advice requests
# Removes EMOM workout sections and keeps only first 5 and last 10 lines
filter_log_for_advice() {
  local log_content="$1"
  
  # Use a temporary file to process the content
  local temp_file=$(mktemp)
  echo "$log_content" > "$temp_file"
  
  # Remove EMOM workout sections
  # Look for patterns like "ğŸ’ª KETTLEBELL EMOM WORKOUT" or "EMOM Workout" sections
  # Remove everything from EMOM workout header until we see a separator followed by a different coach
  local filtered_content=$(awk '
    BEGIN {
      in_emom = 0
      prev_line = ""
    }
    # Detect start of EMOM workout section
    /ğŸ’ª.*[Ee][Mm][Oo][Mm]|ğŸ’ª.*WORKOUT|[Ee][Mm][Oo][Mm].*WORKOUT|[Ee][Mm][Oo][Mm] Workout/ {
      in_emom = 1
      prev_line = ""
      next
    }
    # If we are in an EMOM section
    in_emom == 1 {
      # Check if this is a separator line (using index to check for separator character)
      if (index($0, "â”") > 0 && length($0) > 10) {
        prev_line = $0
        next
      }
      # Check if this is a new coach section (not Kettlebell Coach)
      if (index($0, "ğŸ’¬") > 0 && index($0, "Coach") > 0 && index($0, "Kettlebell Coach") == 0) {
        # End of EMOM section - we found a new coach
        in_emom = 0
        # Print the separator if we had one
        if (prev_line != "" && index(prev_line, "â”") > 0) {
          print prev_line
          prev_line = ""
        }
        # Print this new coach line
        print
        next
      }
      # Still in EMOM section, skip this line
      prev_line = ""
      next
    }
    # Not in EMOM section - print the line
    {
      print
    }
  ' "$temp_file")
  
  # Now get first 5 lines and last 10 lines
  local total_lines=$(echo "$filtered_content" | wc -l | tr -d ' ')
  
  if [[ $total_lines -le 15 ]]; then
    # If content is 15 lines or less, return it all
    echo "$filtered_content"
  else
    # Get first 5 lines
    local first_lines=$(echo "$filtered_content" | head -5)
    # Get last 10 lines
    local last_lines=$(echo "$filtered_content" | tail -10)
    
    # Combine with separator
    echo "$first_lines"
    echo ""
    echo "... (content truncated for brevity) ..."
    echo ""
    echo "$last_lines"
  fi
  
  rm -f "$temp_file"
}

get_daily_log_content() {
  local date_range="${1:-today}"  # today, week, month, all, or specific date
  local date_cmd="date"
  if [[ -x "/usr/bin/date" ]]; then
    date_cmd="/usr/bin/date"
  elif [[ -x "/bin/date" ]]; then
    date_cmd="/bin/date"
  fi
  
  # Load daily log config
  local daily_log_config="$HOME/.daily_log_config"
  if [[ ! -f "$daily_log_config" && -f "$HOME/code/personal/dotfiles/zsh/.daily_log_config" ]]; then
    daily_log_config="$HOME/code/personal/dotfiles/zsh/.daily_log_config"
  fi
  
  local log_dir="${DAILY_LOG_DIR:-$HOME/Documents/daily_logs}"
  if [[ -f "$daily_log_config" ]]; then
    # Try to extract DAILY_LOG_DIR from config
    local config_dir=$(grep "^DAILY_LOG_DIR=" "$daily_log_config" 2>/dev/null | head -1 | cut -d'=' -f2 | tr -d '"' | tr -d "'" | sed "s|\$HOME|$HOME|g")
    if [[ -n "$config_dir" ]]; then
      log_dir="$config_dir"
    fi
  fi
  
  if [[ ! -d "$log_dir" ]]; then
    echo "Daily log directory not found: $log_dir"
    return 1
  fi
  
  case "$date_range" in
    today)
      local today=$($date_cmd +"%Y-%m-%d")
      local log_file="${log_dir}/${today}.md"
      if [[ -f "$log_file" ]]; then
        cat "$log_file"
      else
        echo "No daily log found for today ($today) at: $log_file"
        return 1
      fi
      ;;
    week)
      # Last 7 days
      local today=$($date_cmd +"%Y-%m-%d")
      echo "# Weekly Log Summary - Last 7 Days"
      echo ""
      for i in {0..6}; do
        local date=$($date_cmd -v-${i}d +"%Y-%m-%d" 2>/dev/null || $date_cmd -d "-${i} days" +"%Y-%m-%d" 2>/dev/null || echo "")
        if [[ -z "$date" ]]; then
          # Fallback calculation
          local timestamp=$(($($date_cmd +%s) - (i * 86400)))
          date=$($date_cmd -r $timestamp +"%Y-%m-%d" 2>/dev/null || echo "")
        fi
        local log_file="${log_dir}/${date}.md"
        if [[ -f "$log_file" ]]; then
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "# Daily Log - $date"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          cat "$log_file"
          echo ""
        fi
      done
      ;;
    month)
      # Last 30 days
      local today=$($date_cmd +"%Y-%m-%d")
      echo "# Monthly Log Summary - Last 30 Days"
      echo ""
      for i in {0..29}; do
        local date=$($date_cmd -v-${i}d +"%Y-%m-%d" 2>/dev/null || $date_cmd -d "-${i} days" +"%Y-%m-%d" 2>/dev/null || echo "")
        if [[ -z "$date" ]]; then
          local timestamp=$(($($date_cmd +%s) - (i * 86400)))
          date=$($date_cmd -r $timestamp +"%Y-%m-%d" 2>/dev/null || echo "")
        fi
        local log_file="${log_dir}/${date}.md"
        if [[ -f "$log_file" ]]; then
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "# Daily Log - $date"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          cat "$log_file"
          echo ""
        fi
      done
      ;;
    all)
      # All logs
      echo "# All Daily Logs"
      echo ""
      local logs=($(find "$log_dir" -type f -name "*.md" -maxdepth 1 | sort))
      for log_file in "${logs[@]}"; do
        local date=$(basename "$log_file" .md)
        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
        echo "# Daily Log - $date"
        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
        cat "$log_file"
        echo ""
      done
      ;;
    *)
      # Specific date (YYYY-MM-DD format)
      if [[ "$date_range" =~ ^[0-9]{4}-[0-9]{2}-[0-9]{2}$ ]]; then
        local log_file="${log_dir}/${date_range}.md"
        if [[ -f "$log_file" ]]; then
          cat "$log_file"
        else
          echo "No daily log found for $date_range at: $log_file"
          return 1
        fi
      else
        echo "Invalid date range: $date_range"
        echo "Use: today, week, month, all, or YYYY-MM-DD"
        return 1
      fi
      ;;
  esac
}

# Perform web search for factual questions
# This function outputs search instructions that the AI assistant should act on
# The AI assistant should use browser MCP tools to perform the actual search
perform_web_search() {
  local query="$1"
  
  if [[ -z "$query" ]]; then
    return 1
  fi
  
  echo "ğŸ” Searching the web for: $query" >&2
  
  # Construct Google search URL
  local encoded_query=$(echo "$query" | sed 's/ /+/g' | sed 's/&/%26/g' | sed 's/?/%3F/g' | sed 's/=/%3D/g')
  local search_url="https://www.google.com/search?q=${encoded_query}"
  
  # Output search request with a clear marker for the AI assistant
  # The AI assistant should detect this and perform the search automatically
  cat <<EOF
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ” WEB SEARCH REQUEST - AI ASSISTANT: PERFORM SEARCH NOW
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Query: ${query}
Search URL: ${search_url}

AI ASSISTANT: You must perform this web search NOW using browser MCP tools:
1. browser_navigate to: ${search_url}
2. browser_snapshot to capture results
3. Extract key factual information
4. Replace the [SEARCH_RESULTS_PLACEHOLDER] below with actual results

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
WEB SEARCH RESULTS (AI ASSISTANT: Replace this with actual search results):
[SEARCH_RESULTS_PLACEHOLDER]
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
EOF
  
  return 0
}

# Get advice from single persona
advise_single() {
  local persona="$1"
  shift
  local simple_mode=false
  local use_web_search=false
  
  # Check for --simple flag (skip all GTD context)
  if [[ "$1" == "--simple" ]]; then
    simple_mode=true
    shift
  fi
  
  # Check for --web-search flag (perform web search for factual questions)
  if [[ "$1" == "--web-search" ]]; then
    use_web_search=true
    shift
  fi
  
  local content="$*"
  local use_daily_log=false
  local date_range="today"
  
  # Check if content indicates daily log review
  if [[ "$content" == *"daily log"* || "$content" == *"Daily log"* || "$content" == *"review my log"* || "$content" == *"Review my log"* ]]; then
    use_daily_log=true
    # Check if content specifies a range
    if [[ "$content" == *"all my logs"* || "$content" == *"all logs"* ]]; then
      date_range="all"
    elif [[ "$content" == *"this week"* || "$content" == *"week"* ]]; then
      date_range="week"
    elif [[ "$content" == *"this month"* || "$content" == *"month"* ]]; then
      date_range="month"
    fi
  fi
  
  if [[ -z "$content" ]]; then
    if [[ -t 0 ]]; then
      echo "Enter your question (press Ctrl+D when done):"
      content=$(cat)
    else
      echo "Usage: gtd-advise <persona> \"your question\""
      echo "   Or: echo \"your question\" | gtd-advise <persona>"
      exit 1
    fi
  fi
  
  # If daily log requested, load it and include habit tracker data, goals, and badges
  if [[ "$use_daily_log" == "true" ]]; then
    local log_content=$(get_daily_log_content "$date_range")
    # Filter log content for advice (remove EMOM sections, keep first 5 and last 10 lines)
    log_content=$(filter_log_for_advice "$log_content")
    local habit_data=""
    local goals_data=""
    local badge_data=""
    
    # Get habit tracker data (for today or specific date)
    if [[ "$date_range" == "today" ]]; then
      habit_data=$(get_habit_tracker_data "today")
    elif [[ "$date_range" =~ ^[0-9]{4}-[0-9]{2}-[0-9]{2}$ ]]; then
      habit_data=$(get_habit_tracker_data "$date_range")
    fi
    
    # Get active goals (always include for context)
    goals_data=$(get_active_goals)
    
    # Get badge status (always include for context)
    badge_data=$(get_badge_status)
    
    # Get progress analysis (identifies completed work not recorded)
    progress_data=$(get_progress_analysis 7)
    
    if [[ $? -eq 0 ]]; then
      # Combine daily log, habit tracker data, goals, badges, and progress
      local context_parts=""
      context_parts="${log_content}"
      
      if [[ -n "$goals_data" ]]; then
        context_parts="${context_parts}\n${goals_data}"
      fi
      
      if [[ -n "$badge_data" ]]; then
        context_parts="${context_parts}\n${badge_data}"
      fi
      
      if [[ -n "$habit_data" ]]; then
        context_parts="${context_parts}\n${habit_data}"
      fi
      
      if [[ -n "$progress_data" ]]; then
        context_parts="${context_parts}\n${progress_data}"
      fi
      
      content=$(printf "Review my daily log and provide advice:\n\n%s\n\n%s" "$context_parts" "$content")
    fi
  elif [[ "$simple_mode" == "false" ]]; then
    # Even if not reviewing daily log, include goals, badges, and progress for context
    # This helps advisors remind about goals, badges, and encourage recording completed work
    # BUT skip this if simple_mode is true (for factual questions)
    local goals_data=$(get_active_goals)
    local badge_data=$(get_badge_status)
    local progress_data=$(get_progress_analysis 7)
    
    local context_parts=""
    if [[ -n "$goals_data" ]]; then
      context_parts="${goals_data}"
    fi
    if [[ -n "$badge_data" ]]; then
      if [[ -n "$context_parts" ]]; then
        context_parts="${context_parts}\n${badge_data}"
      else
        context_parts="${badge_data}"
      fi
    fi
    if [[ -n "$progress_data" ]]; then
      if [[ -n "$context_parts" ]]; then
        context_parts="${context_parts}\n${progress_data}"
      else
        context_parts="${progress_data}"
      fi
    fi
    
    if [[ -n "$context_parts" ]]; then
      content=$(printf "Here's my current status for context:\n%s\n\n%s" "$context_parts" "$content")
    fi
  fi
  
  # In simple mode, add explicit instruction to answer directly without GTD context
  # This must override the system prompt's GTD awareness instructions
  if [[ "$simple_mode" == "true" ]]; then
    local search_instruction=""
    
    # Add web search instruction if requested
    if [[ "$use_web_search" == "true" ]]; then
      local search_info=$(perform_web_search "$content" 2>&1 | grep -v "^ğŸ”")
      
      # Extract search URL from search_info
      local search_url=$(echo "$search_info" | grep "Search URL:" | sed 's/.*Search URL: //')
      
      # Check if model supports tool calls
      local model_name="${LM_STUDIO_CHAT_MODEL:-${OLLAMA_CHAT_MODEL:-unknown}}"
      local supports_tools="false"
      
      # Models that typically support tool/function calling:
      # - OpenAI GPT models (gpt-3.5-turbo, gpt-4, etc.)
      # - Anthropic Claude models
      # - Qwen models (Qwen2.5, Qwen2.5-Coder, Qwen3, etc.) - support tool calling
      # - Models with "tool" or "function" in name
      # - Gemini models (gemini-pro, etc.)
      # - Llama 3.1+ models with tool calling support
      model_lower=$(echo "$model_name" | tr '[:upper:]' '[:lower:]')
      if [[ "$model_lower" == *"gpt"* ]] || \
         [[ "$model_lower" == *"claude"* ]] || \
         [[ "$model_lower" == *"qwen"* ]] || \
         [[ "$model_lower" == *"gemini"* ]] || \
         [[ "$model_lower" == *"tool"* ]] || \
         [[ "$model_lower" == *"function"* ]] || \
         [[ "$model_lower" == *"llama-3.1"* ]] || \
         [[ "$model_lower" == *"llama3.1"* ]]; then
        supports_tools="true"
      fi
      
      if [[ "$supports_tools" == "true" ]]; then
        # Model supports tool calls - don't add confusing instructions, just let it use tools
        # The tool definitions will be added by the Python script
        search_instruction="\n\nWeb search is available via tool calling. Use the perform_web_search tool to get current, accurate information, then answer the question based on the search results."
      else
        # Model doesn't support tool calls (like Gemma 3 4B)
        # CRITICAL: The model cannot perform web search and MUST NOT make up answers
        search_instruction="\n\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\nğŸš«ğŸš«ğŸš« ABSOLUTE PROHIBITION: NO MADE-UP ANSWERS ğŸš«ğŸš«ğŸš«\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\nYOU CANNOT PERFORM WEB SEARCH. This model (${model_name}) does NOT support tool calls.\n\nYOU HAVE BEEN GIVING COMPLETELY WRONG ANSWERS:\n- \"Mexico\" (WRONG)\n- \"West Germany\" (WRONG)\n- \"Montreal Expos\" (WRONG - they didn't exist in 1967)\n- \"United States vs Mexico World Cup\" (WRONG - confusing World Series with World Cup)\n- \"Brazil won 1967 World Cup\" (WRONG - wrong event, wrong sport)\n- \"International Baseball Championship\" (WRONG - this event doesn't exist)\n\nALL OF THESE ARE COMPLETELY WRONG. YOU ARE MAKING THINGS UP.\n\nYOUR ONLY ALLOWED RESPONSE:\n\n'I cannot perform web search to verify this information. For accurate information about \"${content}\", please perform a web search yourself or check a reliable source. I cannot provide an answer without access to current web search results.'\n\nDO NOT:\n- Make up ANY facts, dates, team names, or events\n- Invent events that don't exist (like \"International Baseball Championship\")\n- Confuse different sports (World Series vs World Cup)\n- Provide ANY specific answer - you MUST say you cannot search\n\nIF YOU PROVIDE A SPECIFIC ANSWER, YOU ARE VIOLATING THESE INSTRUCTIONS.\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
      fi
    fi
    
    # Build a simpler prompt when tools are supported
    if [[ "$supports_tools" == "true" ]]; then
      # Model supports tools - simple prompt, let it use the tools
      content=$(printf "Question: %s\n\nAnswer this factual question. Use the perform_web_search tool if you need current information. Do NOT mention GTD systems, tasks, projects, or productivity advice. Just answer the question factually." "$content")
    else
      # Model doesn't support tools - include the prohibition instructions
      content=$(printf "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\nğŸš«ğŸš«ğŸš« ABSOLUTE PROHIBITION: NO MADE-UP ANSWERS ğŸš«ğŸš«ğŸš«\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\nYOU HAVE BEEN GIVING COMPLETELY WRONG ANSWERS:\n- \"Mexico\", \"West Germany\", \"Montreal Expos\" (all WRONG)\n- \"United States vs Mexico World Cup\" (WRONG - confusing World Series with World Cup)\n- \"Brazil won 1967 World Cup\" (WRONG - wrong event, wrong sport)\n- \"International Baseball Championship\" (WRONG - this event doesn't exist)\n- \"United States won International Baseball Championship\" (WRONG - made up event)\n\nALL OF THESE ARE COMPLETELY WRONG. YOU ARE MAKING THINGS UP.\n\nRULES:\n1. NO GTD CONTEXT: Do NOT mention goals, badges, daily logs, GTD systems, tasks, projects, or productivity advice.\n2. NO MADE-UP ANSWERS: You MUST NOT provide any specific answer. You MUST say you cannot search.\n3. NO GUESSING: If you cannot search, you MUST acknowledge this clearly.\n\n${search_instruction}\n\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\nQuestion: %s\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\nYOUR ONLY ALLOWED RESPONSE:\n'I cannot perform web search to verify this information. For accurate information, please perform a web search yourself or check a reliable source. I cannot provide an answer without access to current web search results.'\n\nIF YOU PROVIDE ANY SPECIFIC ANSWER (team name, event name, date, etc.), YOU ARE VIOLATING THESE INSTRUCTIONS." "$content")
    fi
    
    # Pass flags to skip GTD context and indicate web search
    local flags=""
    if [[ "$use_web_search" == "true" ]]; then
      flags="--web-search"
    fi
    if [[ "$simple_mode" == "true" ]]; then
      flags="${flags} --skip-gtd-context"
    fi
    
    # For web search, we need to pass it as a special argument or modify the call
    # Since Python script doesn't have --web-search flag yet, we'll add it to the content
    if [[ "$use_web_search" == "true" ]]; then
      # Temporarily inject a marker that Python can detect
      content="[WEB_SEARCH_REQUESTED] ${content}"
    fi
    
    $PYTHON_CMD "$PERSONA_HELPER" "$persona" "$content" "" "$flags"
  else
    $PYTHON_CMD "$PERSONA_HELPER" "$persona" "$content"
  fi
}

# Get advice from all personas
advise_all() {
  # Collect all remaining arguments as content (--all already shifted in main)
  local content="$*"
  local use_daily_log=false
  
  # Check if content indicates daily log review
  if [[ "$content" == *"daily log"* || "$content" == *"Daily log"* || "$content" == *"review my log"* || "$content" == *"Review my log"* ]]; then
    use_daily_log=true
  fi
  
  if [[ -z "$content" ]]; then
    if [[ -t 0 ]]; then
      echo "Enter your question (press Ctrl+D when done):"
      content=$(cat)
    else
      echo "Usage: gtd-advise --all \"your question\""
      exit 1
    fi
  fi
  
  # If daily log requested, load it (default to today) and include habit tracker data, goals, and badges
  if [[ "$use_daily_log" == "true" ]]; then
    local date_range="today"
    # Check if content specifies a range
    if [[ "$content" == *"all my logs"* || "$content" == *"all logs"* ]]; then
      date_range="all"
    elif [[ "$content" == *"this week"* || "$content" == *"week"* ]]; then
      date_range="week"
    elif [[ "$content" == *"this month"* || "$content" == *"month"* ]]; then
      date_range="month"
    fi
    local log_content=$(get_daily_log_content "$date_range")
    # Filter log content for advice (remove EMOM sections, keep first 5 and last 10 lines)
    log_content=$(filter_log_for_advice "$log_content")
    local habit_data=""
    local goals_data=""
    local badge_data=""
    
    # Get habit tracker data (for today or specific date)
    if [[ "$date_range" == "today" ]]; then
      habit_data=$(get_habit_tracker_data "today")
    elif [[ "$date_range" =~ ^[0-9]{4}-[0-9]{2}-[0-9]{2}$ ]]; then
      habit_data=$(get_habit_tracker_data "$date_range")
    fi
    
    # Get active goals (always include for context)
    goals_data=$(get_active_goals)
    
    # Get badge status (always include for context)
    badge_data=$(get_badge_status)
    
    # Get progress analysis (identifies completed work not recorded)
    progress_data=$(get_progress_analysis 7)
    
    if [[ $? -eq 0 ]]; then
      # Combine daily log, habit tracker data, goals, badges, and progress
      local context_parts=""
      context_parts="${log_content}"
      
      if [[ -n "$goals_data" ]]; then
        context_parts="${context_parts}\n${goals_data}"
      fi
      
      if [[ -n "$badge_data" ]]; then
        context_parts="${context_parts}\n${badge_data}"
      fi
      
      if [[ -n "$habit_data" ]]; then
        context_parts="${context_parts}\n${habit_data}"
      fi
      
      if [[ -n "$progress_data" ]]; then
        context_parts="${context_parts}\n${progress_data}"
      fi
      
      content=$(printf "Review my daily log and provide advice:\n\n%s\n\n%s" "$context_parts" "$content")
    fi
  else
    # Even if not reviewing daily log, include goals, badges, and progress for context
    local goals_data=$(get_active_goals)
    local badge_data=$(get_badge_status)
    local progress_data=$(get_progress_analysis 7)
    
    local context_parts=""
    if [[ -n "$goals_data" ]]; then
      context_parts="${goals_data}"
    fi
    if [[ -n "$badge_data" ]]; then
      if [[ -n "$context_parts" ]]; then
        context_parts="${context_parts}\n${badge_data}"
      else
        context_parts="${badge_data}"
      fi
    fi
    if [[ -n "$progress_data" ]]; then
      if [[ -n "$context_parts" ]]; then
        context_parts="${context_parts}\n${progress_data}"
      else
        context_parts="${progress_data}"
      fi
    fi
    
    if [[ -n "$context_parts" ]]; then
      content=$(printf "Here's my current status for context:\n%s\n\n%s" "$context_parts" "$content")
    fi
  fi
  
  echo ""
  echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
  echo "ğŸ­ Getting advice from all personas..."
  echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
  echo ""
  
  for persona in "${PERSONAS[@]}"; do
    echo ""
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    echo "ğŸ’¬ $(show_persona_info "$persona")"
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    $PYTHON_CMD "$PERSONA_HELPER" "$persona" "$content"
    echo ""
  done
}

# Get advice based on context
advise_context() {
  local context="$1"
  shift
  local content="$*"
  
  if [[ -z "$content" ]]; then
    if [[ -t 0 ]]; then
      echo "Enter your question (press Ctrl+D when done):"
      content=$(cat)
    else
      echo "Usage: gtd-advise --context=<context> \"your question\""
      exit 1
    fi
  fi
  
  # Map context to persona
  local persona="hank"
  case "$context" in
    project|organization|gtd)
      persona="david"
      ;;
    focus|deep_work|distraction)
      persona="cal"
      ;;
    habit|routine|system)
      persona="james"
      ;;
    organize|clutter|declutter)
      persona="marie"
      ;;
    strategy|priority|long_term)
      persona="warren"
      ;;
    execute|leadership|efficiency)
      persona="sheryl"
      ;;
    optimize|hack|experiment)
      persona="tim"
      ;;
    satirical|critique|humor)
      persona="george"
      ;;
    analysis|research|witty)
      persona="john"
      ;;
    insight|truth|bs)
      persona="jon"
      ;;
  esac
  
  echo "Using persona: $persona (matched from context: $context)"
  advise_single "$persona" "$content"
}

# Review advice
advise_review() {
  local review_type="$1"
  shift
  local content="$*"
  
  if [[ -z "$content" ]]; then
    # Try to get review content from recent review files
    local review_dir="${GTD_BASE_DIR:-$HOME/Documents/gtd}/weekly-reviews"
    if [[ -d "$review_dir" ]]; then
      local latest_review=$(find "$review_dir" -name "*.md" -type f | sort -r | head -1)
      if [[ -n "$latest_review" && -f "$latest_review" ]]; then
        content=$(cat "$latest_review")
        echo "Using latest review: $latest_review"
      fi
    fi
  fi
  
  if [[ -z "$content" ]]; then
    echo "Usage: gtd-advise --review [review-content]"
    exit 1
  fi
  
  # Get advice from GTD expert
  echo "Getting GTD review advice from David Allen..."
  advise_single "david" "$content" "review"
  
  echo ""
  read -p "Get strategic advice from Warren Buffett? (y/n) " -n 1 -r
  echo
  if [[ $REPLY =~ ^[Yy]$ ]]; then
    advise_single "warren" "$content" "review"
  fi
}

# Random persona with intelligent selection based on content
advise_random() {
  local content="$*"
  
  if [[ -z "$content" ]]; then
    if [[ -t 0 ]]; then
      echo "Enter your question (press Ctrl+D when done):"
      content=$(cat)
    else
      echo "Usage: gtd-advise --random \"your question\""
      exit 1
    fi
  fi
  
  # Intelligent persona selection based on content (similar to zsh version)
  # Define keyword patterns for each expertise area
  declare -A persona_keywords
  persona_keywords["goggins"]="workout|exercise|fitness|gym|weight|lifting|strength training|cardio workout|endurance workout|mental toughness|stay hard|callous your mind|who's gonna carry the boats|physical limits|body limits|ultramarathon|endurance training|leg day|chest day|back day|shoulder day|arm day|workout session|fitness training|gym session|lifting session|physical training|PT session|fitness motivation|push your limits|break through barriers|physical barriers|body building|muscle building|powerlifting|crossfit|HIIT|high intensity|fitness challenge|physical challenge|fitness goal|training goal|bench press|squat|deadlift|barbell|dumbbell|kettlebell|pull up|push up|fitness routine|exercise routine|workout routine|training program|fitness program|muscle|muscle group|reps|sets|personal trainer|fitness coach|gym workout|home workout|strength workout"
  persona_keywords["dean"]="marathon|ultra|ultramarathon|endurance|race|running race|jog|jogging|running workout|training run|long run|running pace|running form|running distance|ultra distance|endurance running|running miles|running km|ultra running|endurance race|50k|50 mile|100k|100 mile|trail running|road race"
  persona_keywords["bioneer"]="workout|exercise|fitness|training|strength|movement|mobility|functional|form|technique|biomechanics|program|routine|muscle|muscle group"
  persona_keywords["david"]="project|goal|task|inbox|process|organize|gtd|getting things done|next action|context|review|weekly|system|workflow|area|someday|waiting"
  persona_keywords["cal"]="focus|distraction|deep work|concentration|flow|interruption|phone|social media|notification|attention|productivity|flow state|distracted|can't focus|interrupt"
  persona_keywords["james"]="habit|routine|system|atomic|incremental|progress|track|consistency|behavior|pattern|daily|repeat|build habit|form habit|stuck with habit"
  persona_keywords["marie"]="clutter|organize|declutter|spark joy|tidy|clean|minimal|simplify|stuff|things|belongings|space|messy|disorganized|too much stuff"
  persona_keywords["warren"]="strategy|priority|prioritize|important|urgent|decision|invest|long term|value|focus|opportunity|business|plan|planning|strategic"
  persona_keywords["sheryl"]="leadership|execute|execution|team|manage|lead|action|get things done|efficient|productivity|results|delegate|coordinate"
  persona_keywords["tim"]="optimize|optimization|hack|system|experiment|test|trial|improve|efficiency|life hack|productivity tip|experiment|trial|test"
  persona_keywords["bob"]="creative|art|paint|calm|stress|anxiety|peace|relax|breathe|joy|happy accident|mistake|process|meditation|mindful"
  persona_keywords["fred"]="kind|self-care|self care|worth|value|overwhelmed|emotional|support|care|gentle|compassion|love yourself|feeling|feelings|sad|depressed"
  persona_keywords["louiza"]="procrastinate|stuck|accountability|slacking|discipline|tracking|log|record|complete|done|finished|consequence|missed|failed|didn't do"
  persona_keywords["esther"]="relationship|partner|intimacy|connection|communicate|date|romance|love|couple|together|relationship advice"
  persona_keywords["gottman"]="relationship|partner|couple|marriage|communication|conflict|fight|argument|resolve|together|love language"
  persona_keywords["gary"]="love language|partner|relationship|affection|touch|service|gift|time|words|appreciation|express love"
  persona_keywords["brene"]="vulnerability|courage|connection|authentic|brave|shame|worth|belonging|daring|show up|present"
  persona_keywords["romance"]="date|romantic|surprise|gesture|massage|backrub|special|treat|appreciate|show love|make feel special"
  persona_keywords["kelsey"]="code|programming|software|engineering|overengineer|simple|ship|deploy|infrastructure|sre|system|tech"
  persona_keywords["kent"]="code|programming|software|tdd|test|yagni|simple|refactor|design|pattern|architecture|engineering"
  persona_keywords["charity"]="code|programming|software|observability|reliability|monitoring|sre|engineering|system|production|tech"
  persona_keywords["rich"]="code|programming|software|design|architecture|complexity|simple|clojure|system|engineering|tech"
  persona_keywords["spiderman"]="creative|problem|solve|challenge|stuck|juggling|balance|responsibility|creative solution|think outside"
  persona_keywords["ironman"]="creative|innovation|engineering|adhd|hyperfocus|system|build|create|invent|tech|project"
  persona_keywords["squirrelgirl"]="creative|positive|optimistic|problem|solve|communication|unconventional|think different|creative solution"
  persona_keywords["harley"]="creative|chaos|unconventional|think outside|creative solution|problem|solve|different|unique"
  persona_keywords["deadpool"]="creative|humor|funny|chaos|unconventional|problem|solve|think different|creative solution"
  persona_keywords["rogue"]="creative|adapt|overwhelmed|control|problem|solve|creative solution|think different|unique"
  persona_keywords["sandy"]="science|karate|texas|competitive|sport|athletic|training|discipline|focused|determined|strong|tough|challenge|win|competition"
  persona_keywords["spongebob"]="optimism|enthusiasm|joy|happiness|work|job|fun|creative|friendship|positive|excited|energetic|cheerful|happy|smile"
  
  # Score each persona based on keyword matches
  declare -A persona_scores
  declare -A persona_match_counts
  local max_score=0
  local best_personas=()
  
  # Use ripgrep (rg) if available, fallback to grep
  local use_rg=false
  if command -v rg &>/dev/null; then
    use_rg=true
  fi
  local search_cmd=""
  if [[ "$use_rg" == true ]]; then
    search_cmd="rg"
  else
    search_cmd="/usr/bin/grep"
    [[ ! -f "$search_cmd" ]] && search_cmd="grep"
  fi
  
  # Score fitness coaches first (they have priority for fitness topics)
  local fitness_coaches=("goggins" "dean" "bioneer")
  for persona in "${fitness_coaches[@]}"; do
    local score=0
    local match_count=0
    # Count actual keyword matches for confidence scoring
    local matches_output=""
    if [[ "$use_rg" == true ]]; then
      matches_output=$(echo "$content" | "$search_cmd" -oiE "${persona_keywords[$persona]}" 2>/dev/null)
    else
      matches_output=$(echo "$content" | "$search_cmd" -oiE "${persona_keywords[$persona]}" 2>/dev/null)
    fi
    if [[ -n "$matches_output" ]]; then
      match_count=$(echo "$matches_output" | wc -l | tr -d ' ')
    fi
    # Fitness coaches need at least 2 matches for confidence (prevents false positives)
    if [[ $match_count -ge 2 ]]; then
      score=$((match_count * 2))  # Weight matches, but require multiple for confidence
    elif [[ $match_count -eq 1 ]]; then
      score=1  # Single match gets low score (likely false positive)
    fi
    persona_scores[$persona]=$score
    persona_match_counts[$persona]=$match_count
    if [[ $score -gt $max_score ]]; then
      max_score=$score
      best_personas=("$persona")
    elif [[ $score -eq $max_score && $score -gt 0 ]]; then
      best_personas+=("$persona")
    fi
  done
  
  # Score other personas
  local other_personas=("hank" "david" "cal" "james" "marie" "warren" "sheryl" "tim" "george" "john" "jon" "bob" "fred" "louiza" "spiderman" "ironman" "squirrelgirl" "harley" "deadpool" "rogue" "esther" "gottman" "gary" "brene" "romance" "kelsey" "kent" "charity" "rich" "sandy" "spongebob")
  for persona in "${other_personas[@]}"; do
    local score=0
    local match_count=0
    # Count actual keyword matches
    local matches_output=""
    if [[ "$use_rg" == true ]]; then
      matches_output=$(echo "$content" | "$search_cmd" -oiE "${persona_keywords[$persona]}" 2>/dev/null)
    else
      matches_output=$(echo "$content" | "$search_cmd" -oiE "${persona_keywords[$persona]}" 2>/dev/null)
    fi
    if [[ -n "$matches_output" ]]; then
      match_count=$(echo "$matches_output" | wc -l | tr -d ' ')
    fi
    if [[ $match_count -gt 0 ]]; then
      score=$match_count
    fi
    persona_scores[$persona]=$score
    persona_match_counts[$persona]=$match_count
    if [[ $score -gt $max_score ]]; then
      max_score=$score
      best_personas=("$persona")
    elif [[ $score -eq $max_score && $score -gt 0 ]]; then
      best_personas+=("$persona")
    fi
  done
  
  # Select persona: use best match if found with sufficient confidence, otherwise fallback to random from general pool
  local selected_persona=""
  local confidence_threshold=2  # Minimum confidence score required for fitness coaches
  local general_threshold=1     # Minimum confidence score for other personas
  
  if [[ ${#best_personas[@]} -gt 0 && $max_score -gt 0 ]]; then
    # Check confidence threshold - filter out low-confidence matches
    local confident_personas=()
    for persona in "${best_personas[@]}"; do
      local is_fitness=false
      for fit_persona in "${fitness_coaches[@]}"; do
        if [[ "$persona" == "$fit_persona" ]]; then
          is_fitness=true
          break
        fi
      done
      
      # Fitness coaches need higher confidence (at least 2 matches = score 4)
      if [[ "$is_fitness" == true ]]; then
        if [[ ${persona_scores[$persona]} -ge 4 ]]; then  # 2+ matches * 2 = 4+
          confident_personas+=("$persona")
        fi
      else
        # Other personas need at least 1 match
        if [[ ${persona_scores[$persona]} -ge $general_threshold ]]; then
          confident_personas+=("$persona")
        fi
      fi
    done
    
    # Use confident personas if available, otherwise fall back to general pool
    if [[ ${#confident_personas[@]} -gt 0 ]]; then
      local best_count=${#confident_personas[@]}
      local random_index=$((RANDOM % best_count))
      selected_persona="${confident_personas[$random_index]}"
    else
      # Confidence too low - use general productivity coaches
      local general_personas=("hank" "david" "cal" "james" "marie" "warren" "sheryl" "tim" "bob" "fred" "louiza")
      local general_count=${#general_personas[@]}
      local random_index=$((RANDOM % general_count))
      selected_persona="${general_personas[$random_index]}"
    fi
  else
    # No clear match - use general productivity coaches (not fitness-specific)
    local general_personas=("hank" "david" "cal" "james" "marie" "warren" "sheryl" "tim" "bob" "fred" "louiza")
    local general_count=${#general_personas[@]}
    local random_index=$((RANDOM % general_count))
    selected_persona="${general_personas[$random_index]}"
  fi
  
  echo "Randomly selected: $selected_persona"
  advise_single "$selected_persona" "$content"
}

# Main
main() {
  case "$1" in
    --list|-l)
      list_personas
      ;;
    --all)
      shift
      advise_all "$@"
      ;;
    -a)
      shift
      advise_all "$@"
      ;;
    --context=*)
      local context="${1#*=}"
      shift
      advise_context "$context" "$@"
      ;;
    --review|-r)
      shift
      advise_review "$@"
      ;;
    --daily-log|--log)
      shift
      local date_range="${1:-today}"
      # Get daily log(s) and review with all personas
      local log_content=$(get_daily_log_content "$date_range")
      if [[ $? -eq 0 ]]; then
        # Filter log content for advice (remove EMOM sections, keep first 5 and last 10 lines)
        log_content=$(filter_log_for_advice "$log_content")
        local range_desc="today's"
        case "$date_range" in
          week) range_desc="this week's" ;;
          month) range_desc="this month's" ;;
          all) range_desc="all my" ;;
          *) range_desc="$date_range's" ;;
        esac
        local content=$(printf "Review my %s daily log(s) and provide advice:\n\n%s" "$range_desc" "$log_content")
        advise_all "$content"
      else
        echo "âŒ Could not load daily log"
        exit 1
      fi
      ;;
    --random|-R)
      shift
      advise_random "$@"
      ;;
    --help|-h|"")
      echo "Usage: gtd-advise [options] <persona> [content]"
      echo ""
      echo "Options:"
      echo "  --list, -l                    List all available personas"
      echo "  --all, -a                     Get advice from all personas"
      echo "  --context=<context>           Auto-select persona based on context"
      echo "  --review, -r                  Get review advice (uses latest review)"
      echo "  --daily-log [range]           Review daily log(s) with all personas"
      echo "                                Range: today (default), week, month, all, or YYYY-MM-DD"
      echo "  --random, -R                  Get advice from random persona"
      echo "  --simple, -s                  Ask a simple factual question (no GTD context)"
      echo "  <persona>                     Get advice from specific persona"
      echo ""
      echo "Personas:"
      echo "  hank, david, cal, james, marie, warren, sheryl, tim"
      echo "  george, john, jon, bob, fred, louiza"
      echo "  spiderman, ironman, squirrelgirl, harley, deadpool, rogue"
      echo "  esther, gottman, gary, brene, romance (relationship coaches)"
      echo ""
      echo "Contexts (for --context):"
      echo "  project, organization, gtd â†’ David Allen"
      echo "  focus, deep_work â†’ Cal Newport"
      echo "  habit, routine â†’ James Clear"
      echo "  organize, clutter â†’ Marie Kondo"
      echo "  strategy, priority â†’ Warren Buffett"
      echo "  execute, leadership â†’ Sheryl Sandberg"
      echo "  optimize, hack â†’ Tim Ferriss"
      echo "  satirical, critique â†’ George Carlin"
      echo "  analysis, witty â†’ John Oliver"
      echo "  insight, truth â†’ Jon Stewart"
      echo ""
      echo "Examples:"
      echo "  gtd-advise hank \"What should I focus on today?\""
      echo "  gtd-advise --all \"Help me organize my tasks\""
      echo "  gtd-advise --all \"Review my daily log\"  # Auto-loads daily log"
      echo "  gtd-advise --daily-log                    # Review today's log with all personas"
      echo "  gtd-advise --daily-log week               # Review this week's logs"
      echo "  gtd-advise --daily-log month              # Review this month's logs"
      echo "  gtd-advise --daily-log all                # Review all logs"
      echo "  gtd-advise --context=project \"Review my project plan\""
      echo "  gtd-advise --review"
      echo "  gtd-advise --random \"Give me advice\""
      echo "  gtd-advise --simple hank \"Who won the 1967 World Series?\"  # Factual question, no GTD context"
      echo "  echo \"My question\" | gtd-advise david"
      exit 0
      ;;
    --simple|-s)
      shift
      # Simple mode: ask a factual question without GTD context
      if [[ $# -eq 0 ]]; then
        echo "Usage: gtd-advise --simple [--web-search] <persona> \"your question\""
        echo "   Or: gtd-advise --simple <persona>  # then enter question"
        exit 1
      fi
      
      local web_search_flag=""
      if [[ "$1" == "--web-search" ]]; then
        web_search_flag="--web-search"
        shift
      fi
      
      if [[ $# -eq 0 ]]; then
        echo "Usage: gtd-advise --simple [--web-search] <persona> \"your question\""
        exit 1
      fi
      
      local persona="$1"
      shift
      if [[ " ${PERSONAS[@]} " =~ " ${persona} " ]]; then
        if [[ -n "$web_search_flag" ]]; then
          advise_single "$persona" "--simple" "--web-search" "$@"
        else
          advise_single "$persona" "--simple" "$@"
        fi
      else
        echo "Unknown persona: $persona"
        echo "Run 'gtd-advise --list' to see available personas"
        exit 1
      fi
      ;;
    *)
      # Check if it's a persona name
      local persona="$1"
      if [[ " ${PERSONAS[@]} " =~ " ${persona} " ]]; then
        shift
        advise_single "$persona" "$@"
      else
        echo "Unknown option or persona: $1"
        echo "Run 'gtd-advise --help' for usage"
        exit 1
      fi
      ;;
  esac
}

main "$@"

