#!/bin/bash
# GTD Daily Log Command - Add entry to daily log
# Standalone script version of addInfoToDailyLog function

# Source common environment (PATH setup)
COMMON_ENV="$HOME/code/dotfiles/zsh/common_env.sh"
if [[ ! -f "$COMMON_ENV" && -f "$HOME/code/personal/dotfiles/zsh/common_env.sh" ]]; then
  COMMON_ENV="$HOME/code/personal/dotfiles/zsh/common_env.sh"
fi
if [[ -f "$COMMON_ENV" ]]; then
  source "$COMMON_ENV"
fi

# Load config if available
DAILY_LOG_CONFIG="$HOME/.daily_log_config"
if [[ -f "$HOME/code/dotfiles/zsh/.daily_log_config" ]]; then
  DAILY_LOG_CONFIG="$HOME/code/dotfiles/zsh/.daily_log_config"
elif [[ -f "$HOME/code/personal/dotfiles/zsh/.daily_log_config" ]]; then
  DAILY_LOG_CONFIG="$HOME/code/personal/dotfiles/zsh/.daily_log_config"
fi

if [[ -f "$DAILY_LOG_CONFIG" ]]; then
  source "$DAILY_LOG_CONFIG"
fi

# Default values
DAILY_LOG_DIR="${DAILY_LOG_DIR:-$HOME/Documents/daily_logs}"

# Get the log entry
if [[ -z "$1" ]]; then
  echo "Usage: gtd-daily-log \"Your log entry here\""
  exit 1
fi

log_entry="$1"

# Get date command
get_date_cmd() {
  if [[ -x "/usr/bin/date" ]]; then
    echo "/usr/bin/date"
  elif [[ -x "/bin/date" ]]; then
    echo "/bin/date"
  else
    echo "date"
  fi
}

DATE_CMD=$(get_date_cmd)
today=$($DATE_CMD +"%Y-%m-%d")
current_time=$($DATE_CMD +"%H:%M")
log_file="${DAILY_LOG_DIR}/${today}.md"

# Expand $HOME if present in path
log_file="${log_file//\$HOME/$HOME}"
DAILY_LOG_DIR="${DAILY_LOG_DIR//\$HOME/$HOME}"

# Create directory if it doesn't exist
if [[ ! -d "$DAILY_LOG_DIR" ]]; then
  mkdir -p "$DAILY_LOG_DIR" || {
    echo "Error: Could not create directory $DAILY_LOG_DIR" >&2
    exit 1
  }
fi

# Create file with header if it doesn't exist
if [[ ! -f "$log_file" ]]; then
  echo "# Daily Log - $today" > "$log_file" || {
    echo "Error: Could not create log file $log_file" >&2
    exit 1
  }
  echo "" >> "$log_file"
fi

# Append the entry with timestamp
echo "${current_time} - ${log_entry}" >> "$log_file" || {
  echo "Error: Could not write to log file $log_file" >&2
  exit 1
}

echo "âœ“ Added: ${current_time} - ${log_entry}"

# Check if this is a workout/exercise entry and award XP (gamification)
if echo "$log_entry" | grep -qiE "workout|exercise|kettlebell|walk|run|weight|lifting|gym|fitness|training|cardio|strength|squat|deadlift|press|swing|snatch|clean|row|bike|cycling|yoga|stretch|active|movement"; then
	# Determine if it's intense exercise (running, intense training) or normal
	local exercise_type="exercise"
	if echo "$log_entry" | grep -qiE "run|running|sprint|intense|hard|heavy|cardio"; then
		exercise_type="exercise_intense"
	fi
	
	if command -v gtd-gamify-award &>/dev/null; then
		gtd-gamify-award "$exercise_type" "" "Logged exercise: $log_entry" "exercise" 2>/dev/null || true
	elif [[ -f "$HOME/code/dotfiles/bin/gtd-gamify-award" ]]; then
		"$HOME/code/dotfiles/bin/gtd-gamify-award" "$exercise_type" "" "Logged exercise: $log_entry" "exercise" 2>/dev/null || true
	elif [[ -f "$HOME/code/personal/dotfiles/bin/gtd-gamify-award" ]]; then
		"$HOME/code/personal/dotfiles/bin/gtd-gamify-award" "$exercise_type" "" "Logged exercise: $log_entry" "exercise" 2>/dev/null || true
	fi
fi

# Check for milestones (run in background to not slow down logging)
MILESTONE_SCRIPT="$(dirname "$0")/gtd-milestone-celebration"
if [[ -f "$MILESTONE_SCRIPT" ]]; then
  "$MILESTONE_SCRIPT" >/dev/null 2>&1 &
fi

# Auto-suggestions from log entry (run in background to not slow down logging)
AUTO_SUGGEST_SCRIPT="$HOME/code/dotfiles/mcp/gtd_auto_suggest.py"
if [[ ! -f "$AUTO_SUGGEST_SCRIPT" ]]; then
  AUTO_SUGGEST_SCRIPT="$HOME/code/personal/dotfiles/mcp/gtd_auto_suggest.py"
fi

if [[ -f "$AUTO_SUGGEST_SCRIPT" ]]; then
  # Helper script to extract banter
  EXTRACT_BANTER="$HOME/code/dotfiles/mcp/extract_banter.py"
  if [[ ! -f "$EXTRACT_BANTER" ]]; then
    EXTRACT_BANTER="$HOME/code/personal/dotfiles/mcp/extract_banter.py"
  fi
  
  # Run auto-suggestions in background and save banter
  (
    result=$(python3 "$AUTO_SUGGEST_SCRIPT" entry "$log_entry" 2>&1)
    if [[ -f "$EXTRACT_BANTER" ]]; then
      banter=$(echo "$result" | python3 "$EXTRACT_BANTER" 2>/dev/null)
    else
      # Fallback: try simple extraction
      banter=$(echo "$result" | grep -o '"banter":\s*"[^"]*"' | cut -d'"' -f4)
    fi
    
    if [[ -n "$banter" && "$banter" != "None" && "$banter" != "null" ]]; then
      # Save banter to display after a brief delay
      echo "$banter" > "${log_file}.banter.$$"
    fi
  ) &
  
  # Display banter after processing (non-blocking, appears ~1-2 seconds later)
  (
    sleep 2
    banter_file="${log_file}.banter.$$"
    if [[ -f "$banter_file" ]]; then
      banter=$(cat "$banter_file" 2>/dev/null | head -1)
      if [[ -n "$banter" && "$banter" != "None" && "$banter" != "null" ]]; then
        echo ""
        echo "ðŸ’¬ $banter"
      fi
      rm -f "$banter_file" 2>/dev/null
    fi
  ) &
fi

exit 0


