#!/bin/bash
# GTD Task Command - Task management

# Source common environment (PATH setup)
COMMON_ENV="$HOME/code/dotfiles/zsh/common_env.sh"
if [[ ! -f "$COMMON_ENV" && -f "$HOME/code/personal/dotfiles/zsh/common_env.sh" ]]; then
  COMMON_ENV="$HOME/code/personal/dotfiles/zsh/common_env.sh"
fi
if [[ -f "$COMMON_ENV" ]]; then
  source "$COMMON_ENV"
fi

# Load GTD config
GTD_CONFIG_FILE="$HOME/.gtd_config"
if [[ -f "$HOME/code/personal/dotfiles/zsh/.gtd_config" ]]; then
  GTD_CONFIG_FILE="$HOME/code/personal/dotfiles/zsh/.gtd_config"
fi

# Source config if it exists
if [[ -f "$GTD_CONFIG_FILE" ]]; then
  source "$GTD_CONFIG_FILE"
fi

# Default values
GTD_BASE_DIR="${GTD_BASE_DIR:-$HOME/Documents/gtd}"
TASKS_PATH="${GTD_BASE_DIR}/tasks"
PROJECTS_PATH="${GTD_BASE_DIR}/${GTD_PROJECTS_DIR:-1-projects}"
ARCHIVE_PATH="${GTD_BASE_DIR}/${GTD_ARCHIVE_DIR:-6-archive}"

mkdir -p "$TASKS_PATH" "$PROJECTS_PATH" "$ARCHIVE_PATH"

TODAY=$(date +"%Y-%m-%d")
NOW=$(date +"%H:%M")

# Extract frontmatter value
get_frontmatter_value() {
  local file="$1"
  local key="$2"
  grep "^${key}:" "$file" 2>/dev/null | head -1 | cut -d':' -f2 | sed 's/^[[:space:]]*//' | sed 's/[[:space:]]*$//'
}

# Update frontmatter value
update_frontmatter_value() {
  local file="$1"
  local key="$2"
  local value="$3"
  
  if grep -q "^${key}:" "$file" 2>/dev/null; then
    if [[ "$OSTYPE" == "darwin"* ]]; then
      sed -i '' "s/^${key}:.*/${key}: ${value}/" "$file"
    else
      sed -i "s/^${key}:.*/${key}: ${value}/" "$file"
    fi
  else
    if [[ "$OSTYPE" == "darwin"* ]]; then
      sed -i '' "/^---$/a\\
${key}: ${value}
" "$file"
    else
      sed -i "/^---$/a\\${key}: ${value}" "$file"
    fi
  fi
}

# Validate and normalize repository URL
normalize_repo_url() {
  local url="$1"
  if [[ -z "$url" ]]; then
    echo ""
    return 0
  fi
  
  # Remove trailing slash
  url="${url%/}"
  
  # If it's already a full URL, return as-is
  if [[ "$url" =~ ^https?:// ]]; then
    echo "$url"
    return 0
  fi
  
  # If it's a shorthand like "user/repo", convert to GitHub
  if [[ "$url" =~ ^[a-zA-Z0-9_-]+/[a-zA-Z0-9_.-]+$ ]]; then
    echo "https://github.com/$url"
    return 0
  fi
  
  # Return as-is (might be invalid, but user can fix later)
  echo "$url"
}

# Add task
add_task() {
  local task_desc=""
  local context=""
  local energy=""
  local priority=""
  local project=""
  local repository=""
  local recurring="false"
  local frequency=""
  local non_interactive=false
  
  # Parse arguments
  local remaining_args=()
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --context=*)
        context="${1#*=}"
        non_interactive=true
        shift
        ;;
      --energy=*)
        energy="${1#*=}"
        non_interactive=true
        shift
        ;;
      --priority=*)
        priority="${1#*=}"
        non_interactive=true
        shift
        ;;
      --project=*)
        project="${1#*=}"
        non_interactive=true
        shift
        ;;
      --repository=*|--repo=*)
        repository="${1#*=}"
        repository=$(normalize_repo_url "$repository")
        non_interactive=true
        shift
        ;;
      --recurring=*)
        recurring="${1#*=}"
        non_interactive=true
        shift
        ;;
      --frequency=*)
        frequency="${1#*=}"
        non_interactive=true
        shift
        ;;
      --non-interactive)
        non_interactive=true
        shift
        ;;
      *)
        remaining_args+=("$1")
        shift
        ;;
    esac
  done
  
  # Get task description from remaining args
  task_desc="${remaining_args[*]}"
  
  if [[ -z "$task_desc" ]]; then
    read -p "Task description: " task_desc
  fi
  
  local timestamp=$(date +"%Y%m%d%H%M%S")
  local filename="${timestamp}-task.md"
  local filepath="${TASKS_PATH}/${filename}"
  
  # Get additional info (only if not provided via flags)
  if [[ "$non_interactive" != "true" ]]; then
    echo "Creating task: $task_desc"
    read -p "Is this a recurring task/habit? (y/n): " is_recurring
    
    if [[ "$is_recurring" == "y" || "$is_recurring" == "Y" ]]; then
      echo ""
      echo "Recurrence frequency:"
      echo "  1) Daily"
      echo "  2) Weekly"
      echo "  3) Monthly"
      echo "  4) Custom"
      read -p "Choose (1-4): " freq_choice
      case "$freq_choice" in
        1) frequency="daily" ;;
        2) frequency="weekly" ;;
        3) frequency="monthly" ;;
        4)
          read -p "Custom frequency (e.g., 'every 3 days', 'weekdays'): " frequency
          ;;
        *) frequency="daily" ;;
      esac
      recurring="true"
      echo ""
      echo "üí° Consider creating this as a habit instead: gtd-habit create \"$task_desc\""
      echo ""
    fi
  else
    # Non-interactive mode - use defaults
    if [[ -z "$recurring" ]]; then
      recurring="false"
    fi
    if [[ -z "$frequency" ]]; then
      frequency=""
    fi
  fi
  
  # Get context (prompt only if not provided)
  if [[ -z "$context" ]]; then
    if [[ "$non_interactive" != "true" ]]; then
      read -p "Context (home/office/computer/phone/errands): " context
    else
      context="computer"  # Default for non-interactive
    fi
  fi
  
  # Get energy level (prompt only if not provided)
  if [[ -z "$energy" ]]; then
    if [[ "$non_interactive" != "true" ]]; then
      read -p "Energy level (low/medium/high/creative/administrative): " energy
    else
      energy="medium"  # Default for non-interactive
    fi
  fi
  
  # Get priority (prompt only if not provided)
  if [[ -z "$priority" ]]; then
    if [[ "$non_interactive" != "true" ]]; then
      read -p "Priority (1=urgent&important, 2=not urgent&important, 3=urgent&not important, 4=neither): " priority_choice
    else
      priority="not_urgent_important"  # Default for non-interactive
    fi
  fi
  
  # Convert priority choice to priority value if needed (from interactive prompt)
  if [[ -z "$priority" && -n "$priority_choice" ]]; then
    case "$priority_choice" in
      1) priority="urgent_important" ;;
      2) priority="not_urgent_important" ;;
      3) priority="urgent_not_important" ;;
      4) priority="not_urgent_not_important" ;;
      *) priority="not_urgent_important" ;;
    esac
  fi
  
  # Set default priority if still empty
  if [[ -z "$priority" ]]; then
    priority="not_urgent_important"
  fi
  
  # Get repository link (prompt only if not provided and in interactive mode)
  if [[ -z "$repository" && "$non_interactive" != "true" ]]; then
    echo ""
    read -p "Repository URL (GitHub/GitLab, or press Enter to skip): " repo_input
    if [[ -n "$repo_input" ]]; then
      repository=$(normalize_repo_url "$repo_input")
    fi
  fi
  
  # Handle project assignment
  local project_dir=""
  if [[ -n "$project" ]]; then
    project=$(echo "$project" | tr ' ' '-' | tr '[:upper:]' '[:lower:]')
    project_dir="${PROJECTS_PATH}/${project}"
    mkdir -p "$project_dir"
    filepath="${project_dir}/${filename}"
  fi
  
  # Create task file with conditional repository field
  {
    echo "---"
    echo "type: task"
    echo "status: active"
    echo "created: ${TODAY}T${NOW}"
    echo "context: ${context:-computer}"
    echo "energy: ${energy:-medium}"
    echo "priority: ${priority}"
    echo "recurring: ${recurring:-false}"
    echo "frequency: ${frequency:-}"
    if [[ -n "$project" ]]; then
      echo "project: ${project}"
    fi
    if [[ -n "$repository" ]]; then
      echo "repository: ${repository}"
    fi
    echo "tags: []"
    echo "---"
    echo ""
    echo "# ${task_desc}"
    echo ""
    echo "## Next Action"
    echo "${task_desc}"
    echo ""
    echo "## Notes"
    echo ""
    echo ""
  } > "$filepath"
  
  echo "‚úì Created task: $filepath"
  echo "  Context: ${context:-computer}"
  echo "  Energy: ${energy:-medium}"
  echo "  Priority: $priority"
  if [[ -n "$project" ]]; then
    echo "  Project: $project"
  fi
  if [[ -n "$repository" ]]; then
    echo "  Repository: $repository"
  fi
}

# Find all task files (in tasks directory and project directories)
find_all_tasks() {
  local tasks=()
  
  # Search in tasks directory
  if [[ -d "$TASKS_PATH" ]]; then
    while IFS= read -r -d '' task; do
      tasks+=("$task")
    done < <(find "$TASKS_PATH" -type f -name "*.md" -print0 2>/dev/null)
  fi
  
  # Search in project directories (recursively, but exclude README.md)
  if [[ -d "$PROJECTS_PATH" ]]; then
    while IFS= read -r -d '' task; do
      tasks+=("$task")
    done < <(find "$PROJECTS_PATH" -type f -name "*.md" ! -name "README.md" -print0 2>/dev/null)
  fi
  
  printf '%s\0' "${tasks[@]}"
}

# List tasks
list_tasks() {
  local context_filter=""
  local energy_filter=""
  local priority_filter=""
  local project_filter=""
  local status_filter="active"
  local project_only=false
  local no_project=false
  
  # Parse filters
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --context=*)
        context_filter="${1#*=}"
        shift
        ;;
      --energy=*)
        energy_filter="${1#*=}"
        shift
        ;;
      --priority=*)
        priority_filter="${1#*=}"
        shift
        ;;
      --project=*)
        project_filter="${1#*=}"
        shift
        ;;
      --status=*)
        status_filter="${1#*=}"
        shift
        ;;
      --project-only)
        project_only=true
        shift
        ;;
      --no-project)
        no_project=true
        shift
        ;;
      *)
        shift
        ;;
    esac
  done
  
  local tasks=()
  while IFS= read -r -d '' task; do
    tasks+=("$task")
  done < <(find_all_tasks)
  
  local count=0
  
  echo ""
  echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
  echo "üìã Tasks (status: $status_filter)"
  if [[ -n "$context_filter" ]]; then
    echo "   Context: $context_filter"
  fi
  if [[ -n "$energy_filter" ]]; then
    echo "   Energy: $energy_filter"
  fi
  if [[ -n "$priority_filter" ]]; then
    echo "   Priority: $priority_filter"
  fi
  if [[ "$project_only" == "true" ]]; then
    echo "   Filter: Project-related tasks only"
  fi
  if [[ "$no_project" == "true" ]]; then
    echo "   Filter: Tasks without projects only"
  fi
  echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
  echo ""
  
  for task in "${tasks[@]}"; do
    local status=$(get_frontmatter_value "$task" "status")
    local context=$(get_frontmatter_value "$task" "context")
    local energy=$(get_frontmatter_value "$task" "energy")
    local priority=$(get_frontmatter_value "$task" "priority")
    local project=$(get_frontmatter_value "$task" "project")
    local repository=$(get_frontmatter_value "$task" "repository")
    
    # If project not in frontmatter but task is in a project directory, infer it
    if [[ -z "$project" ]]; then
      local task_dir=$(dirname "$task")
      if [[ "$task_dir" != "$TASKS_PATH" ]] && [[ "$task_dir" == "$PROJECTS_PATH"/* ]]; then
        project=$(basename "$task_dir")
      fi
    fi
    
    # Apply filters
    if [[ "$status" != "$status_filter" ]]; then
      continue
    fi
    if [[ -n "$context_filter" && "$context" != "$context_filter" ]]; then
      continue
    fi
    if [[ -n "$energy_filter" && "$energy" != "$energy_filter" ]]; then
      continue
    fi
    if [[ -n "$priority_filter" && "$priority" != "$priority_filter" ]]; then
      continue
    fi
    if [[ -n "$project_filter" && "$project" != "$project_filter" ]]; then
      continue
    fi
    if [[ "$project_only" == "true" && -z "$project" ]]; then
      continue
    fi
    if [[ "$no_project" == "true" && -n "$project" ]]; then
      continue
    fi
    
    ((count++))
    local task_name=$(head -20 "$task" | grep "^# " | head -1 | sed 's/^# //')
    local task_id=$(basename "$task" .md)
    
    echo "[$count] $task_name"
    echo "     ID: $task_id"
    echo "     Context: $context | Energy: $energy | Priority: $priority"
    if [[ -n "$project" ]]; then
      echo "     Project: $project"
    fi
    if [[ -n "$repository" ]]; then
      echo "     Repository: $repository"
    fi
    echo ""
  done
  
  if [[ $count -eq 0 ]]; then
    echo "No tasks found matching filters."
  else
    echo "Total: $count task(s)"
  fi
}

# Find task file by ID (searches both TASKS_PATH and project directories)
find_task_file() {
  local task_id="$1"
  local task_file=""
  
  # Search in tasks directory
  task_file=$(find "$TASKS_PATH" -name "${task_id}*.md" 2>/dev/null | head -1)
  
  # If not found, search in project directories
  if [[ -z "$task_file" || ! -f "$task_file" ]]; then
    if [[ -d "$PROJECTS_PATH" ]]; then
      task_file=$(find "$PROJECTS_PATH" -name "${task_id}*.md" ! -name "README.md" 2>/dev/null | head -1)
    fi
  fi
  
  echo "$task_file"
}

# Complete task
complete_task() {
  local task_id="$1"
  if [[ -z "$task_id" ]]; then
    echo "Usage: gtd-task complete <task-id>"
    echo "   Get task ID from 'gtd-task list'"
    exit 1
  fi
  
  local task_file=$(find_task_file "$task_id")
  
  if [[ -z "$task_file" || ! -f "$task_file" ]]; then
    echo "‚ùå Task not found: $task_id"
    exit 1
  fi
  
  update_frontmatter_value "$task_file" "status" "done"
  update_frontmatter_value "$task_file" "completed" "$(date +"%Y-%m-%dT%H:%M")"
  
  # Get task name for notification
  local task_name=$(get_frontmatter_value "$task_file" "title")
  if [[ -z "$task_name" ]]; then
    task_name=$(basename "$task_file" .md)
  fi
  
  mv "$task_file" "$ARCHIVE_PATH/"
  
  echo "‚úì Task completed and archived"
  
  # Send notification if enabled
  if [[ "${GTD_NOTIFICATIONS:-true}" == "true" ]]; then
    "$(dirname "$0")/gtd-notify" complete "$task_name" 2>/dev/null || true
  fi
}

# Update task
update_task() {
  local task_id="$1"
  if [[ -z "$task_id" ]]; then
    echo "Usage: gtd-task update <task-id>"
    exit 1
  fi
  
  local task_file=$(find_task_file "$task_id")
  
  if [[ -z "$task_file" || ! -f "$task_file" ]]; then
    echo "‚ùå Task not found: $task_id"
    exit 1
  fi
  
  echo "Updating task: $(basename "$task_file")"
  echo ""
  echo "What would you like to update?"
  echo "1) Context"
  echo "2) Energy level"
  echo "3) Priority"
  echo "4) Status"
  echo "5) Open in editor"
  read -p "Choice (1-5): " choice
  
  case "$choice" in
    1)
      read -p "New context: " new_context
      update_frontmatter_value "$task_file" "context" "$new_context"
      echo "‚úì Updated context"
      ;;
    2)
      read -p "New energy level: " new_energy
      update_frontmatter_value "$task_file" "energy" "$new_energy"
      echo "‚úì Updated energy level"
      ;;
    3)
      read -p "New priority (1-4): " priority_choice
      case "$priority_choice" in
        1) priority="urgent_important" ;;
        2) priority="not_urgent_important" ;;
        3) priority="urgent_not_important" ;;
        4) priority="not_urgent_not_important" ;;
        *) echo "Invalid choice"; exit 1 ;;
      esac
      update_frontmatter_value "$task_file" "priority" "$priority"
      echo "‚úì Updated priority"
      ;;
    4)
      read -p "New status (active/on-hold/done): " new_status
      update_frontmatter_value "$task_file" "status" "$new_status"
      if [[ "$new_status" == "done" ]]; then
        mv "$task_file" "$ARCHIVE_PATH/"
        echo "‚úì Updated status and archived"
      else
        echo "‚úì Updated status"
      fi
      ;;
    5)
      if [[ -n "$EDITOR" ]]; then
        $EDITOR "$task_file"
      else
        echo "EDITOR not set"
      fi
      ;;
    *)
      echo "Invalid choice"
      exit 1
      ;;
  esac
}

# Move task to project
move_task() {
  local task_id="$1"
  local project_name="$2"
  
  if [[ -z "$task_id" || -z "$project_name" ]]; then
    echo "Usage: gtd-task move <task-id> <project-name>"
    exit 1
  fi
  
  local task_file=$(find_task_file "$task_id")
  
  if [[ -z "$task_file" || ! -f "$task_file" ]]; then
    echo "‚ùå Task not found: $task_id"
    exit 1
  fi
  
  project_name=$(echo "$project_name" | tr ' ' '-' | tr '[:upper:]' '[:lower:]')
  local project_dir="${PROJECTS_PATH}/${project_name}"
  mkdir -p "$project_dir"
  
  update_frontmatter_value "$task_file" "project" "$project_name"
  
  # Move to project directory
  mv "$task_file" "${project_dir}/"
  
  echo "‚úì Moved task to project: $project_name"
  echo "  Location: $project_dir"
}

# Main
main() {
  case "$1" in
    add)
      shift
      add_task "$@"
      ;;
    list|ls)
      shift
      list_tasks "$@"
      ;;
    complete|done)
      shift
      complete_task "$1"
      ;;
    update)
      shift
      update_task "$1"
      ;;
    move)
      shift
      move_task "$1" "$2"
      ;;
    --help|-h|"")
      echo "Usage: gtd-task <command> [options]"
      echo ""
      echo "Commands:"
      echo "  add <description>              Add a new task"
      echo "  list [filters]                  List tasks"
      echo "  complete <task-id>             Mark task as complete"
      echo "  update <task-id>                Update task properties"
      echo "  move <task-id> <project>        Move task to project"
      echo ""
      echo "List filters:"
      echo "  --context=<context>             Filter by context"
      echo "  --energy=<level>                Filter by energy level"
      echo "  --priority=<priority>           Filter by priority"
      echo "  --project=<project>             Filter by project"
      echo "  --status=<status>               Filter by status (default: active)"
      echo "  --project-only                  Show only tasks with projects"
      echo "  --no-project                    Show only tasks without projects"
      echo ""
      echo "Examples:"
      echo "  gtd-task add \"Fix bug\""
      echo "  gtd-task list --context=computer"
      echo "  gtd-task list --energy=low"
      echo "  gtd-task complete 20240101120000-task"
      exit 0
      ;;
    *)
      echo "Unknown command: $1"
      echo "Run 'gtd-task --help' for usage"
      exit 1
      ;;
  esac
}

main "$@"



