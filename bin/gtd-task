#!/bin/bash
# GTD Task Command - Task management

# Source common GTD helpers
GTD_COMMON="$HOME/code/dotfiles/bin/gtd-common.sh"
if [[ ! -f "$GTD_COMMON" && -f "$HOME/code/personal/dotfiles/bin/gtd-common.sh" ]]; then
  GTD_COMMON="$HOME/code/personal/dotfiles/bin/gtd-common.sh"
fi
if [[ -f "$GTD_COMMON" ]]; then
  source "$GTD_COMMON"
else
  echo "Warning: gtd-common.sh not found. Some features may not work." >&2
fi

# Additional paths (TASKS_PATH, ARCHIVE_PATH already set by init_gtd_paths in gtd-common.sh)
# Only create directories if needed
ARCHIVE_PATH="${ARCHIVE_PATH:-${GTD_BASE_DIR}/${GTD_ARCHIVE_DIR:-6-archive}}"
mkdir -p "$TASKS_PATH" "$PROJECTS_PATH" "$ARCHIVE_PATH"

TODAY=$(gtd_get_today)
NOW=$(gtd_get_current_time)

# Use common frontmatter helper (aliased for backward compatibility)
alias get_frontmatter_value='gtd_get_frontmatter_value'

# Define wrapper function (aliases don't always work in subshells)
get_frontmatter_value() {
  gtd_get_frontmatter_value "$@"
}

# Update frontmatter value
update_frontmatter_value() {
  local file="$1"
  local key="$2"
  local value="$3"
  
  if grep -q "^${key}:" "$file" 2>/dev/null; then
    if [[ "$OSTYPE" == "darwin"* ]]; then
      sed -i '' "s/^${key}:.*/${key}: ${value}/" "$file"
    else
      sed -i "s/^${key}:.*/${key}: ${value}/" "$file"
    fi
  else
    if [[ "$OSTYPE" == "darwin"* ]]; then
      sed -i '' "/^---$/a\\
${key}: ${value}
" "$file"
    else
      sed -i "/^---$/a\\${key}: ${value}" "$file"
    fi
  fi
}

# Validate and normalize repository URL
normalize_repo_url() {
  local url="$1"
  if [[ -z "$url" ]]; then
    echo ""
    return 0
  fi
  
  # Remove trailing slash
  url="${url%/}"
  
  # If it's already a full URL, return as-is
  if [[ "$url" =~ ^https?:// ]]; then
    echo "$url"
    return 0
  fi
  
  # If it's a shorthand like "user/repo", convert to GitHub
  if [[ "$url" =~ ^[a-zA-Z0-9_-]+/[a-zA-Z0-9_.-]+$ ]]; then
    echo "https://github.com/$url"
    return 0
  fi
  
  # Return as-is (might be invalid, but user can fix later)
  echo "$url"
}

# Add task
add_task() {
  local task_desc=""
  local context=""
  local energy=""
  local priority=""
  local project=""
  local repository=""
  local recurring="false"
  local frequency=""
  local non_interactive=false
  
  # Parse arguments
  local remaining_args=()
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --context=*)
        context="${1#*=}"
        non_interactive=true
        shift
        ;;
      --energy=*)
        energy="${1#*=}"
        non_interactive=true
        shift
        ;;
      --priority=*)
        priority="${1#*=}"
        non_interactive=true
        shift
        ;;
      --project=*)
        project="${1#*=}"
        non_interactive=true
        shift
        ;;
      --repository=*|--repo=*)
        repository="${1#*=}"
        repository=$(normalize_repo_url "$repository")
        non_interactive=true
        shift
        ;;
      --recurring=*)
        recurring="${1#*=}"
        non_interactive=true
        shift
        ;;
      --frequency=*)
        frequency="${1#*=}"
        non_interactive=true
        shift
        ;;
      --non-interactive)
        non_interactive=true
        shift
        ;;
      *)
        remaining_args+=("$1")
        shift
        ;;
    esac
  done
  
  # Get task description from remaining args
  task_desc="${remaining_args[*]}"
  
  if [[ -z "$task_desc" ]]; then
    read -p "Task description: " task_desc
  fi
  
  # Show upcoming events in context during planning (if interactive)
  if [[ "$non_interactive" != "true" ]]; then
    echo ""
    echo "üìÖ Upcoming Events (Next 3 days):"
    if command -v gtd-calendar &>/dev/null; then
      gtd-calendar upcoming-context 3 2>/dev/null | head -15 || true
    elif [[ -f "$HOME/code/dotfiles/bin/gtd-calendar" ]]; then
      "$HOME/code/dotfiles/bin/gtd-calendar" upcoming-context 3 2>/dev/null | head -15 || true
    fi
    echo ""
    
    # Ask if they want to schedule this task
    echo -n "Would you like to schedule this task? (y/n): "
    read schedule_task
    if [[ "$schedule_task" == "y" || "$schedule_task" == "Y" ]]; then
      echo -n "When? (e.g., 'tomorrow 2pm' or '2024-12-05 10:00'): "
      read task_when
      if [[ -n "$task_when" ]]; then
        # Store when for later use (we'll add a due date field)
        echo -n "Would you like to time-block this in calendar? (y/n): "
        read time_block
        if [[ "$time_block" == "y" || "$time_block" == "Y" ]]; then
          # Suggest time-blocking
          if command -v gtd-calendar &>/dev/null; then
            gtd-calendar suggest-time-blocking "$task_desc" "$task_when" 60 2>/dev/null || true
          fi
        fi
        
        # Check for over-scheduling warning
        echo ""
        if command -v gtd-calendar &>/dev/null; then
          gtd-calendar check-over-scheduled "$task_when" 2>/dev/null || true
        fi
      fi
    fi
    echo ""
  fi
  
  local timestamp=$(date +"%Y%m%d%H%M%S")
  local filename="${timestamp}-task.md"
  local filepath="${TASKS_PATH}/${filename}"
  
  # Get additional info (only if not provided via flags)
  if [[ "$non_interactive" != "true" ]]; then
    echo "Creating task: $task_desc"
    read -p "Is this a recurring task/habit? (y/n): " is_recurring
    
    if [[ "$is_recurring" == "y" || "$is_recurring" == "Y" ]]; then
      echo ""
      echo "Recurrence frequency:"
      echo "  1) Daily"
      echo "  2) Weekly"
      echo "  3) Monthly"
      echo "  4) Custom"
      read -p "Choose (1-4): " freq_choice
      case "$freq_choice" in
        1) frequency="daily" ;;
        2) frequency="weekly" ;;
        3) frequency="monthly" ;;
        4)
          read -p "Custom frequency (e.g., 'every 3 days', 'weekdays'): " frequency
          ;;
        *) frequency="daily" ;;
      esac
      recurring="true"
      echo ""
      echo "üí° Consider creating this as a habit instead: gtd-habit create \"$task_desc\""
      echo ""
    fi
  else
    # Non-interactive mode - use defaults
    if [[ -z "$recurring" ]]; then
      recurring="false"
    fi
    if [[ -z "$frequency" ]]; then
      frequency=""
    fi
  fi
  
  # Get context (prompt only if not provided)
  if [[ -z "$context" ]]; then
    if [[ "$non_interactive" != "true" ]]; then
      read -p "Context (home/office/computer/phone/errands): " context
    else
      context="computer"  # Default for non-interactive
    fi
  fi
  
  # Get energy level (prompt only if not provided)
  if [[ -z "$energy" ]]; then
    if [[ "$non_interactive" != "true" ]]; then
      read -p "Energy level (low/medium/high/creative/administrative): " energy
    else
      energy="medium"  # Default for non-interactive
    fi
  fi
  
  # Get priority (prompt only if not provided)
  if [[ -z "$priority" ]]; then
    if [[ "$non_interactive" != "true" ]]; then
      read -p "Priority (1=urgent&important, 2=not urgent&important, 3=urgent&not important, 4=neither): " priority_choice
    else
      priority="not_urgent_important"  # Default for non-interactive
    fi
  fi
  
  # Convert priority choice to priority value if needed (from interactive prompt)
  if [[ -z "$priority" && -n "$priority_choice" ]]; then
    case "$priority_choice" in
      1) priority="urgent_important" ;;
      2) priority="not_urgent_important" ;;
      3) priority="urgent_not_important" ;;
      4) priority="not_urgent_not_important" ;;
      *) priority="not_urgent_important" ;;
    esac
  fi
  
  # Set default priority if still empty
  if [[ -z "$priority" ]]; then
    priority="not_urgent_important"
  fi
  
  # Get repository link (prompt only if not provided and in interactive mode)
  if [[ -z "$repository" && "$non_interactive" != "true" ]]; then
    echo ""
    read -p "Repository URL (GitHub/GitLab, or press Enter to skip): " repo_input
    if [[ -n "$repo_input" ]]; then
      repository=$(normalize_repo_url "$repo_input")
    fi
  fi
  
  # Handle project assignment
  local project_dir=""
  if [[ -n "$project" ]]; then
    project=$(echo "$project" | tr ' ' '-' | tr '[:upper:]' '[:lower:]')
    project_dir="${PROJECTS_PATH}/${project}"
    mkdir -p "$project_dir"
    filepath="${project_dir}/${filename}"
  fi
  
  # Create task file with conditional repository field
  {
    echo "---"
    echo "type: task"
    echo "status: active"
    echo "created: ${TODAY}T${NOW}"
    echo "context: ${context:-computer}"
    echo "energy: ${energy:-medium}"
    echo "priority: ${priority}"
    echo "recurring: ${recurring:-false}"
    echo "frequency: ${frequency:-}"
    if [[ -n "$project" ]]; then
      echo "project: ${project}"
    fi
    if [[ -n "$repository" ]]; then
      echo "repository: ${repository}"
    fi
    echo "tags: []"
    echo "---"
    echo ""
    echo "# ${task_desc}"
    echo ""
    echo "## Next Action"
    echo "${task_desc}"
    echo ""
    echo "## Notes"
    echo ""
    echo ""
  } > "$filepath"
  
  echo "‚úì Created task: $filepath"
  echo "  Context: ${context:-computer}"
  echo "  Energy: ${energy:-medium}"
  echo "  Priority: $priority"
  if [[ -n "$project" ]]; then
    echo "  Project: $project"
  fi
  
  # Track preferences
  if command -v gtd-preferences-learn &>/dev/null; then
    gtd-preferences-learn track-context "${context:-computer}" 2>/dev/null || true
    gtd-preferences-learn track-priority "$priority" "$task_desc" 2>/dev/null || true
    gtd-preferences-learn track-feature "command" "gtd-task" 2>/dev/null || true
  fi
  if [[ -n "$repository" ]]; then
    echo "  Repository: $repository"
  fi
  
  # Vectorize the task if enabled
  local task_id=$(basename "$filepath" .md)
  local task_content="$task_desc"
  if [[ -n "$project" ]]; then
    task_content="Project: $project. $task_content"
  fi
  if [[ -n "$context" ]]; then
    task_content="$task_content (Context: $context)"
  fi
  
  # Vectorize in background (don't block user)
  if command -v gtd-vectorize-content &>/dev/null; then
    gtd-vectorize-content "task" "$task_id" "$task_content" &
  elif [[ -f "$HOME/code/dotfiles/bin/gtd-vectorize-content" ]]; then
    "$HOME/code/dotfiles/bin/gtd-vectorize-content" "task" "$task_id" "$task_content" &
  elif [[ -f "$HOME/code/personal/dotfiles/bin/gtd-vectorize-content" ]]; then
    "$HOME/code/personal/dotfiles/bin/gtd-vectorize-content" "task" "$task_id" "$task_content" &
  fi
}

# Find all task files (in tasks directory and project directories)
find_all_tasks() {
  local tasks=()
  
  # Search in tasks directory
  if [[ -d "$TASKS_PATH" ]]; then
    while IFS= read -r -d '' task; do
      tasks+=("$task")
    done < <(find "$TASKS_PATH" -type f -name "*.md" -print0 2>/dev/null)
  fi
  
  # Search in project directories (recursively, but exclude README.md)
  if [[ -d "$PROJECTS_PATH" ]]; then
    while IFS= read -r -d '' task; do
      tasks+=("$task")
    done < <(find "$PROJECTS_PATH" -type f -name "*.md" ! -name "README.md" -print0 2>/dev/null)
  fi
  
  printf '%s\0' "${tasks[@]}"
}

# List tasks
list_tasks() {
  local context_filter=""
  local energy_filter=""
  local priority_filter=""
  local project_filter=""
  local status_filter="active"
  local project_only=false
  local no_project=false
  
  # Parse filters
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --context=*)
        context_filter="${1#*=}"
        shift
        ;;
      --energy=*)
        energy_filter="${1#*=}"
        shift
        ;;
      --priority=*)
        priority_filter="${1#*=}"
        shift
        ;;
      --project=*)
        project_filter="${1#*=}"
        shift
        ;;
      --status=*)
        status_filter="${1#*=}"
        shift
        ;;
      --project-only)
        project_only=true
        shift
        ;;
      --no-project)
        no_project=true
        shift
        ;;
      *)
        shift
        ;;
    esac
  done
  
  local tasks=()
  while IFS= read -r -d '' task; do
    tasks+=("$task")
  done < <(find_all_tasks)
  
  local count=0
  
  echo ""
  echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
  echo "üìã Tasks (status: $status_filter)"
  if [[ -n "$context_filter" ]]; then
    echo "   Context: $context_filter"
  fi
  if [[ -n "$energy_filter" ]]; then
    echo "   Energy: $energy_filter"
  fi
  if [[ -n "$priority_filter" ]]; then
    echo "   Priority: $priority_filter"
  fi
  if [[ "$project_only" == "true" ]]; then
    echo "   Filter: Project-related tasks only"
  fi
  if [[ "$no_project" == "true" ]]; then
    echo "   Filter: Tasks without projects only"
  fi
  echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
  echo ""
  
  for task in "${tasks[@]}"; do
    local status=$(get_frontmatter_value "$task" "status")
    local context=$(get_frontmatter_value "$task" "context")
    local energy=$(get_frontmatter_value "$task" "energy")
    local priority=$(get_frontmatter_value "$task" "priority")
    local project=$(get_frontmatter_value "$task" "project")
    local repository=$(get_frontmatter_value "$task" "repository")
    
    # If project not in frontmatter but task is in a project directory, infer it
    if [[ -z "$project" ]]; then
      local task_dir=$(dirname "$task")
      if [[ "$task_dir" != "$TASKS_PATH" ]] && [[ "$task_dir" == "$PROJECTS_PATH"/* ]]; then
        project=$(basename "$task_dir")
      fi
    fi
    
    # Apply filters
    if [[ "$status" != "$status_filter" ]]; then
      continue
    fi
    if [[ -n "$context_filter" && "$context" != "$context_filter" ]]; then
      continue
    fi
    if [[ -n "$energy_filter" && "$energy" != "$energy_filter" ]]; then
      continue
    fi
    if [[ -n "$priority_filter" && "$priority" != "$priority_filter" ]]; then
      continue
    fi
    if [[ -n "$project_filter" && "$project" != "$project_filter" ]]; then
      continue
    fi
    if [[ "$project_only" == "true" && -z "$project" ]]; then
      continue
    fi
    if [[ "$no_project" == "true" && -n "$project" ]]; then
      continue
    fi
    
    ((count++))
    local task_name=$(head -20 "$task" | grep "^# " | head -1 | sed 's/^# //')
    local task_id=$(basename "$task" .md)
    
    local area=$(get_frontmatter_value "$task" "area")
    
    echo "[$count] $task_name"
    echo "     ID: $task_id"
    echo "     Context: $context | Energy: $energy | Priority: $priority"
    if [[ -n "$area" ]]; then
      echo "     Area: $area"
    fi
    if [[ -n "$project" ]]; then
      echo "     Project: $project"
    fi
    if [[ -n "$repository" ]]; then
      echo "     Repository: $repository"
    fi
    echo ""
  done
  
  if [[ $count -eq 0 ]]; then
    echo "No tasks found matching filters."
  else
    echo "Total: $count task(s)"
  fi
}

# Find task file by ID (searches both TASKS_PATH and project directories)
# NOTE: This function is now available in gtd-common.sh (which is sourced above)
# The function from gtd-common.sh will be used automatically since it's sourced first
# This comment is kept for documentation - the actual function is in gtd-common.sh

# Complete task
complete_task() {
  local task_id="$1"
  if [[ -z "$task_id" ]]; then
    echo "Usage: gtd-task complete <task-id>"
    echo "   Get task ID from 'gtd-task list'"
    exit 1
  fi
  
  local task_file=$(find_task_file "$task_id")
  
  if [[ -z "$task_file" || ! -f "$task_file" ]]; then
    echo "‚ùå Task not found: $task_id"
    exit 1
  fi
  
  update_frontmatter_value "$task_file" "status" "done"
  update_frontmatter_value "$task_file" "completed" "$(date +"%Y-%m-%dT%H:%M")"
  
  # Get task name for notification
  local task_name=$(get_frontmatter_value "$task_file" "title")
  if [[ -z "$task_name" ]]; then
    task_name=$(basename "$task_file" .md)
  fi
  
  mv "$task_file" "$ARCHIVE_PATH/"
  
  echo "‚úì Task completed and archived"
  
  # Send notification if enabled
  if [[ "${GTD_NOTIFICATIONS:-true}" == "true" ]]; then
    "$(dirname "$0")/gtd-notify" complete "$task_name" 2>/dev/null || true
  fi
}

# Update task
update_task() {
  local task_id="$1"
  if [[ -z "$task_id" ]]; then
    echo "Usage: gtd-task update <task-id>"
    exit 1
  fi
  
  local task_file=$(find_task_file "$task_id")
  
  if [[ -z "$task_file" || ! -f "$task_file" ]]; then
    echo "‚ùå Task not found: $task_id"
    exit 1
  fi
  
  echo "Updating task: $(basename "$task_file")"
  echo ""
  echo "What would you like to update?"
  echo "1) Context"
  echo "2) Energy level"
  echo "3) Priority"
  echo "4) Status"
  echo "5) Area"
  echo "6) Open in editor"
  read -p "Choice (1-6): " choice
  
  case "$choice" in
    1)
      read -p "New context: " new_context
      update_frontmatter_value "$task_file" "context" "$new_context"
      echo "‚úì Updated context"
      ;;
    2)
      read -p "New energy level: " new_energy
      update_frontmatter_value "$task_file" "energy" "$new_energy"
      echo "‚úì Updated energy level"
      ;;
    3)
      read -p "New priority (1-4): " priority_choice
      case "$priority_choice" in
        1) priority="urgent_important" ;;
        2) priority="not_urgent_important" ;;
        3) priority="urgent_not_important" ;;
        4) priority="not_urgent_not_important" ;;
        *) echo "Invalid choice"; exit 1 ;;
      esac
      update_frontmatter_value "$task_file" "priority" "$priority"
      echo "‚úì Updated priority"
      ;;
    4)
      read -p "New status (active/on-hold/done): " new_status
      update_frontmatter_value "$task_file" "status" "$new_status"
      if [[ "$new_status" == "done" ]]; then
        mv "$task_file" "$ARCHIVE_PATH/"
        echo "‚úì Updated status and archived"
      else
        echo "‚úì Updated status"
      fi
      ;;
    5)
      # Load areas path
      AREAS_PATH="${GTD_BASE_DIR}/${GTD_AREAS_DIR:-2-areas}"
      
      if [[ -d "$AREAS_PATH" ]] && [[ -n "$(find "$AREAS_PATH" -type f -name "*.md" 2>/dev/null)" ]]; then
        echo "Select area:"
        # Use select_from_list if available
        if command -v select_from_list &>/dev/null || declare -f select_from_list &>/dev/null; then
          area_name=$(select_from_list "area" "$AREAS_PATH" "name")
        else
          # Fallback: list areas manually
          echo "Available areas:"
          local areas=($(find "$AREAS_PATH" -type f -name "*.md" 2>/dev/null | sort))
          local idx=1
          for area_file in "${areas[@]}"; do
            local area_display=$(basename "$area_file" .md | tr '-' ' ' | sed 's/\b\(.\)/\u\1/g')
            echo "  $idx) $area_display"
            ((idx++))
          done
          echo -n "Enter area number or name: "
          read area_input
          
          # Try to find by number or name
          if [[ "$area_input" =~ ^[0-9]+$ ]]; then
            local area_idx=$((area_input - 1))
            if [[ $area_idx -ge 0 && $area_idx -lt ${#areas[@]} ]]; then
              area_name=$(basename "${areas[$area_idx]}" .md | tr '-' ' ' | sed 's/\b\(.\)/\u\1/g')
            fi
          else
            area_name="$area_input"
          fi
        fi
        
        if [[ -n "$area_name" ]]; then
          area_slug=$(echo "$area_name" | tr ' ' '-' | tr '[:upper:]' '[:lower:]')
          update_frontmatter_value "$task_file" "area" "$area_slug"
          echo "‚úì Updated area to: $area_name"
        else
          echo "‚ùå No area selected"
        fi
      else
        echo -n "Area name: "
        read area_input
        if [[ -n "$area_input" ]]; then
          area_slug=$(echo "$area_input" | tr ' ' '-' | tr '[:upper:]' '[:lower:]')
          update_frontmatter_value "$task_file" "area" "$area_slug"
          echo "‚úì Updated area to: $area_input"
        fi
      fi
      ;;
    6)
      if [[ -n "$EDITOR" ]]; then
        $EDITOR "$task_file"
      else
        echo "EDITOR not set"
      fi
      ;;
    *)
      echo "Invalid choice"
      exit 1
      ;;
  esac
}

# Move task to project
move_task() {
  local task_id="$1"
  local project_name="$2"
  
  if [[ -z "$task_id" || -z "$project_name" ]]; then
    echo "Usage: gtd-task move <task-id> <project-name>"
    exit 1
  fi
  
  local task_file=$(find_task_file "$task_id")
  
  if [[ -z "$task_file" || ! -f "$task_file" ]]; then
    echo "‚ùå Task not found: $task_id"
    exit 1
  fi
  
  project_name=$(echo "$project_name" | tr ' ' '-' | tr '[:upper:]' '[:lower:]')
  local project_dir="${PROJECTS_PATH}/${project_name}"
  mkdir -p "$project_dir"
  
  update_frontmatter_value "$task_file" "project" "$project_name"
  
  # Move to project directory
  mv "$task_file" "${project_dir}/"
  
  echo "‚úì Moved task to project: $project_name"
  echo "  Location: $project_dir"
}

# View a task in detail
view_task() {
  local task_id="$1"
  
  if [[ -z "$task_id" ]]; then
    echo "Usage: gtd-task view <task-id>"
    exit 1
  fi
  
  local task_file=$(find_task_file "$task_id")
  
  if [[ -z "$task_file" || ! -f "$task_file" ]]; then
    echo "‚ùå Task not found: $task_id"
    exit 1
  fi
  
  echo ""
  echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
  echo "‚úÖ Task: $task_id"
  echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
  echo ""
  
  # Show task file
  cat "$task_file"
  echo ""
  
  # Show notes if they exist
  local task_base=$(basename "$task_file" .md)
  local task_dir=$(dirname "$task_file")
  local notes_dir="${task_dir}/${task_base}/notes"
  
  if [[ -d "$notes_dir" ]]; then
    local notes=($(find "$notes_dir" -type f -name "*.md" 2>/dev/null | sort))
    if [[ ${#notes[@]} -gt 0 ]]; then
      echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
      echo "üìù Notes (${#notes[@]})"
      echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
      echo ""
      for note_file in "${notes[@]}"; do
        local note_name=$(basename "$note_file" .md)
        echo "  ‚Ä¢ $note_name"
      done
      echo ""
    fi
  fi
}

# List notes for a task
list_task_notes() {
  local task_id="$1"
  
  if [[ -z "$task_id" ]]; then
    echo "‚ùå Task ID required"
    return 1
  fi
  
  local task_file=$(find_task_file "$task_id")
  
  if [[ -z "$task_file" || ! -f "$task_file" ]]; then
    return 1
  fi
  
  # Get task base name and notes directory
  local task_base=$(basename "$task_file" .md)
  local task_dir=$(dirname "$task_file")
  local notes_dir="${task_dir}/${task_base}/notes"
  
  if [[ ! -d "$notes_dir" ]]; then
    return 1
  fi
  
  # Find and list notes
  find "$notes_dir" -type f -name "*.md" 2>/dev/null | sort
}

# Add note to task (creates note file in notes/ subdirectory)
add_note_to_task() {
  local task_id="$1"
  shift
  local note_title="$*"
  
  if [[ -z "$task_id" ]]; then
    echo "‚ùå Task ID required"
    echo "Usage: gtd-task add-note <task-id> [note-title]"
    echo ""
    echo "Examples:"
    echo "  gtd-task add-note 20240101120000-task \"Research notes\""
    echo "  gtd-task add-note 20240101120000-task  # Interactive mode - prompts for title"
    exit 1
  fi
  
  local task_file=$(find_task_file "$task_id")
  
  if [[ -z "$task_file" || ! -f "$task_file" ]]; then
    echo "‚ùå Task not found: $task_id"
    exit 1
  fi
  
  # Get task base name (filename without extension)
  local task_base=$(basename "$task_file" .md)
  local task_dir=$(dirname "$task_file")
  
  # Create notes directory for this task
  # Notes go in task-id/notes/ subdirectory
  local task_notes_dir="${task_dir}/${task_base}"
  local notes_dir="${task_notes_dir}/notes"
  mkdir -p "$notes_dir"
  
  # Get note title
  if [[ -z "$note_title" ]]; then
    echo -n "Note title: "
    read note_title
    if [[ -z "$note_title" ]]; then
      echo "‚ùå Note title required"
      exit 1
    fi
  fi
  
  # Create sanitized filename
  local timestamp=$(date +"%Y%m%d%H%M%S")
  local sanitized_title=$(echo "$note_title" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9]/-/g' | sed 's/--*/-/g' | sed 's/^-\|-$//g')
  local note_filename="${timestamp}-${sanitized_title}.md"
  local note_file="${notes_dir}/${note_filename}"
  
  # Check if note already exists
  if [[ -f "$note_file" ]]; then
    echo "‚ö†Ô∏è  Note already exists: $note_file"
    read -p "Create anyway with new timestamp? (y/N): " create_anyway
    if [[ ! "$create_anyway" =~ ^[Yy]$ ]]; then
      echo "Cancelled."
      exit 0
    fi
    timestamp=$(date +"%Y%m%d%H%M%S")
    note_filename="${timestamp}-${sanitized_title}.md"
    note_file="${notes_dir}/${note_filename}"
  fi
  
  # Get task description for the note
  local task_desc=$(grep "^# " "$task_file" 2>/dev/null | head -1 | sed 's/^# //' || echo "")
  if [[ -z "$task_desc" ]]; then
    task_desc="$task_base"
  fi
  
  # Create the note file
  local created_time=$(date +"%Y-%m-%d %H:%M")
  cat > "$note_file" <<EOF
---
type: note
task: ${task_base}
created: ${TODAY}T${NOW}
tags: []
---

# ${note_title}

Created: ${created_time}
Task: ${task_desc}

## Content



## Links
- Related to: 

## Tags
#task-note #${task_base}

EOF
  
  # Add link to note in the task's Notes section
  local temp_file=$(mktemp)
  local notes_section_found=false
  local relative_note_path="${task_base}/notes/${note_filename}"
  local note_link="[[${note_title}]] (${relative_note_path})"
  
  while IFS= read -r line || [[ -n "$line" ]]; do
    # Check if we're at the Notes section header
    if [[ "$line" == "## Notes" ]]; then
      notes_section_found=true
      echo "$line" >> "$temp_file"
      echo "" >> "$temp_file"
      echo "- ${note_link}" >> "$temp_file"
      continue
    fi
    
    echo "$line" >> "$temp_file"
  done < "$task_file"
  
  # If Notes section wasn't found, add it at the end
  if [[ "$notes_section_found" == "false" ]]; then
    echo "" >> "$temp_file"
    echo "## Notes" >> "$temp_file"
    echo "" >> "$temp_file"
    echo "- ${note_link}" >> "$temp_file"
    echo "" >> "$temp_file"
  fi
  
  mv "$temp_file" "$task_file"
  
  echo "‚úì Created note for task: $task_desc"
  echo "  Title: $note_title"
  echo "  File: $note_file"
  echo "  Linked in task file"
  
  # Optionally open the note in editor
  if command -v ${EDITOR:-vim} &>/dev/null; then
    read -p "Open note in editor? (y/N): " open_editor
    if [[ "$open_editor" =~ ^[Yy]$ ]]; then
      ${EDITOR:-vim} "$note_file"
    fi
  fi
}

# Main
main() {
  case "$1" in
    add)
      shift
      add_task "$@"
      ;;
    list|ls)
      shift
      list_tasks "$@"
      ;;
    complete|done)
      shift
      complete_task "$1"
      ;;
    update)
      shift
      update_task "$1"
      ;;
    move)
      shift
      move_task "$1" "$2"
      ;;
    add-note)
      shift
      add_note_to_task "$@"
      ;;
    view)
      shift
      view_task "$@"
      ;;
    --help|-h|"")
      echo "Usage: gtd-task <command> [options]"
      echo ""
      echo "Commands:"
      echo "  add <description>              Add a new task"
      echo "  list [filters]                  List tasks"
      echo "  view <task-id>                 View task details"
      echo "  complete <task-id>             Mark task as complete"
      echo "  update <task-id>                Update task properties"
      echo "  move <task-id> <project>        Move task to project"
      echo "  add-note <task-id> [note]       Add note to task"
      echo ""
      echo "List filters:"
      echo "  --context=<context>             Filter by context"
      echo "  --energy=<level>                Filter by energy level"
      echo "  --priority=<priority>           Filter by priority"
      echo "  --project=<project>             Filter by project"
      echo "  --status=<status>               Filter by status (default: active)"
      echo "  --project-only                  Show only tasks with projects"
      echo "  --no-project                    Show only tasks without projects"
      echo ""
      echo "Examples:"
      echo "  gtd-task add \"Fix bug\""
      echo "  gtd-task list --context=computer"
      echo "  gtd-task list --energy=low"
      echo "  gtd-task complete 20240101120000-task"
      exit 0
      ;;
    *)
      echo "Unknown command: $1"
      echo "Run 'gtd-task --help' for usage"
      exit 1
      ;;
  esac
}

main "$@"



