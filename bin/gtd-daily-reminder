#!/bin/bash
# GTD Daily Evening Review Reminder - Daily reminder from Mistress Louiza

# Source common environment (PATH setup)
COMMON_ENV="$HOME/code/dotfiles/zsh/common_env.sh"
if [[ ! -f "$COMMON_ENV" && -f "$HOME/code/personal/dotfiles/zsh/common_env.sh" ]]; then
  COMMON_ENV="$HOME/code/personal/dotfiles/zsh/common_env.sh"
fi
if [[ -f "$COMMON_ENV" ]]; then
  source "$COMMON_ENV"
fi


# Load GTD config
GTD_CONFIG_FILE="$HOME/.gtd_config"
# Check multiple possible locations
if [[ -f "$HOME/code/dotfiles/zsh/.gtd_config" ]]; then
  GTD_CONFIG_FILE="$HOME/code/dotfiles/zsh/.gtd_config"
elif [[ -f "$HOME/code/personal/dotfiles/zsh/.gtd_config" ]]; then
  GTD_CONFIG_FILE="$HOME/code/personal/dotfiles/zsh/.gtd_config"
fi

# Source config if it exists
if [[ -f "$GTD_CONFIG_FILE" ]]; then
  source "$GTD_CONFIG_FILE"
fi

# Load daily log config
DAILY_LOG_CONFIG="$HOME/.daily_log_config"
if [[ ! -f "$DAILY_LOG_CONFIG" && -f "$HOME/code/personal/dotfiles/zsh/.daily_log_config" ]]; then
  DAILY_LOG_CONFIG="$HOME/code/personal/dotfiles/zsh/.daily_log_config"
fi
if [[ ! -f "$DAILY_LOG_CONFIG" && -f "$HOME/code/dotfiles/zsh/.daily_log_config" ]]; then
  DAILY_LOG_CONFIG="$HOME/code/dotfiles/zsh/.daily_log_config"
fi

# Source daily log config if it exists
if [[ -f "$DAILY_LOG_CONFIG" ]]; then
  source "$DAILY_LOG_CONFIG"
fi

# Default values
GTD_BASE_DIR="${GTD_BASE_DIR:-$HOME/Documents/gtd}"
DAILY_LOG_DIR="${DAILY_LOG_DIR:-$HOME/Documents/daily_logs}"
GTD_DAILY_REVIEW_TIME="${GTD_DAILY_REVIEW_TIME:-18:00}"  # 6:00 PM default
GTD_NOTIFICATIONS="${GTD_NOTIFICATIONS:-true}"

# Get date command
get_date_cmd() {
  if [[ -x "/usr/bin/date" ]]; then
    echo "/usr/bin/date"
  elif [[ -x "/bin/date" ]]; then
    echo "/bin/date"
  else
    echo "date"
  fi
}

DATE_CMD=$(get_date_cmd)

# Get current time in HH:MM format
get_current_time() {
  $DATE_CMD +"%H:%M"
}

# Get today's date
get_today() {
  $DATE_CMD +"%Y-%m-%d"
}

# Get today's daily log content
get_todays_log() {
  local today=$(get_today)
  local log_file="${DAILY_LOG_DIR}/${today}.md"
  
  if [[ -f "$log_file" ]]; then
    cat "$log_file"
    return 0
  else
    echo "No daily log found for today ($today)"
    return 1
  fi
}

# Get daily log stats
get_log_stats() {
  local today=$(get_today)
  local log_file="${DAILY_LOG_DIR}/${today}.md"
  
  if [[ ! -f "$log_file" ]]; then
    echo "No log entries today"
    return
  fi
  
  # Count entries - try multiple patterns to catch different formats
  local entry_count=$(grep -cE "^[0-9]{1,2}:[0-9]{2}[[:space:]]+-[[:space:]]+" "$log_file" 2>/dev/null || echo "0")
  if [[ "$entry_count" == "0" ]]; then
    entry_count=$(grep -cE "^[0-9]{1,2}:[0-9]{2}[[:space:]]*-" "$log_file" 2>/dev/null || echo "0")
  fi
  if [[ "$entry_count" == "0" ]]; then
    entry_count=$(grep -cE "^[0-9]{1,2}:[0-9]{2}" "$log_file" 2>/dev/null | grep -v "^#" | wc -l | tr -d ' ' || echo "0")
  fi
  
  local goal_count=$(grep -ci "goal" "$log_file" 2>/dev/null || echo "0")
  
  echo "Entries: $entry_count"
  if [[ $goal_count -gt 0 ]]; then
    echo "Goals: $goal_count"
  fi
}

# Check for lack of progress (for evening)
check_evening_progress() {
  local today=$(get_today)
  local log_file="${DAILY_LOG_DIR}/${today}.md"
  
  # Check if no log exists
  if [[ ! -f "$log_file" ]]; then
    echo "no_log"
    return
  fi
  
  # Check entry count - use same improved pattern
  local entry_count=$(grep -cE "^[0-9]{1,2}:[0-9]{2}[[:space:]]+-[[:space:]]+" "$log_file" 2>/dev/null || echo "0")
  if [[ "$entry_count" == "0" ]]; then
    entry_count=$(grep -cE "^[0-9]{1,2}:[0-9]{2}[[:space:]]*-" "$log_file" 2>/dev/null || echo "0")
  fi
  if [[ "$entry_count" == "0" ]]; then
    entry_count=$(grep -cE "^[0-9]{1,2}:[0-9]{2}" "$log_file" 2>/dev/null | grep -v "^#" | wc -l | tr -d ' ' || echo "0")
  fi
  
  if [[ $entry_count -eq 0 ]]; then
    echo "no_entries"
    return
  fi
  
  # For evening, expect at least 3 entries for the entire day
  if [[ $entry_count -lt 3 ]]; then
    echo "low_entries"
    return
  fi
  
  # Check if last entry is recent (within last 4 hours for evening)
  local last_entry_time=$(grep -E "^[0-9]{1,2}:[0-9]{2}[[:space:]]+-[[:space:]]+" "$log_file" 2>/dev/null | tail -1 | cut -d' ' -f1)
  if [[ -z "$last_entry_time" ]]; then
    last_entry_time=$(grep -E "^[0-9]{1,2}:[0-9]{2}[[:space:]]*-" "$log_file" 2>/dev/null | tail -1 | cut -d' ' -f1)
  fi
  if [[ -z "$last_entry_time" ]]; then
    last_entry_time=$(grep -E "^[0-9]{1,2}:[0-9]{2}" "$log_file" 2>/dev/null | grep -v "^#" | tail -1 | cut -d' ' -f1 | cut -d':' -f1-2)
  fi
  if [[ -z "$last_entry_time" ]]; then
    echo "no_entries"
    return
  fi
  
  # Get current time
  local current_hour=$($DATE_CMD +"%H")
  local current_min=$($DATE_CMD +"%M")
  local entry_hour=$(echo "$last_entry_time" | cut -d':' -f1)
  local entry_min=$(echo "$last_entry_time" | cut -d':' -f2)
  
  # Convert to minutes (use 10# to force base-10, avoiding octal issues)
  local current_minutes=$((10#$current_hour * 60 + 10#$current_min))
  local entry_minutes=$((10#$entry_hour * 60 + 10#$entry_min))
  local diff=$((current_minutes - entry_minutes))
  
  # If last entry was more than 4 hours ago, it's stale
  if [[ $diff -gt 240 ]]; then
    echo "stale_entries"
    return
  fi
  
  echo "good"
}

# Check if it's time for daily review
check_daily_review_time() {
  local current_time=$(get_current_time)
  local review_hour=$(echo "$GTD_DAILY_REVIEW_TIME" | cut -d':' -f1)
  local review_min=$(echo "$GTD_DAILY_REVIEW_TIME" | cut -d':' -f2)
  local current_hour=$(echo "$current_time" | cut -d':' -f1)
  local current_min=$(echo "$current_time" | cut -d':' -f2)
  
  # Convert to minutes for comparison
  local review_minutes=$((review_hour * 60 + review_min))
  local current_minutes=$((current_hour * 60 + current_min))
  
  # Check if we're within 1 hour of review time
  local diff=$((current_minutes - review_minutes))
  if [[ $diff -ge 0 && $diff -le 60 ]]; then
    return 0  # It's time!
  fi
  
  return 1  # Not time yet
}

# Get reminder message from Mistress Louiza
get_louiza_daily_reminder() {
  local log_content="$1"
  local stats="$2"
  
  # Find persona helper
  local persona_helper=""
  local possible_paths=(
    "$HOME/code/personal/dotfiles/zsh/functions/gtd_persona_helper.py"
    "$HOME/code/dotfiles/zsh/functions/gtd_persona_helper.py"
  )
  
  for path in "${possible_paths[@]}"; do
    if [[ -f "$path" ]]; then
      persona_helper="$path"
      break
    fi
  done
  
  if [[ -z "$persona_helper" || ! -f "$persona_helper" ]]; then
    return 1  # Persona helper not found
  fi
  
  # Find python
  local python_cmd=""
  if [[ -f "/opt/homebrew/bin/python3" ]]; then
    python_cmd="/opt/homebrew/bin/python3"
  elif command -v python3 &>/dev/null; then
    python_cmd="python3"
  else
    return 1  # Python not found
  fi
  
  # Check for lack of progress first
  local progress_status=$(check_evening_progress)
  
  # Create prompt for Louiza based on progress
  local prompt=""
  local gtd_reminder="GTD commands: 'gtd-review daily' for evening review, 'gtd-process' to process inbox, 'gtd-task list' to see tasks, 'gtd-project list' for projects, 'gtd-capture' for quick notes."
  
  case "$progress_status" in
    no_log|no_entries)
      local punishment_hint="Assign severe punishments: write a detailed accountability letter explaining the failure, process entire inbox immediately, complete a full project audit, review and update all active projects, do a weekly review if overdue, and commit to logging every hour tomorrow. Also consider: clean your room, vacuum the house, do your face routine, take your pills - these basic self-care tasks show discipline."
      prompt=$(printf "It's evening, ${GTD_USER_NAME:-Abby}. The ENTIRE DAY has passed and she has logged NOTHING. This is a complete failure. Scold her severely but constructively. Tell her that a day without logging is a day wasted. I'm watching and I'm NOT pleased. This is unacceptable. Be very strict - use phrases like 'this is completely unacceptable' or 'we need to have a serious talk'. Tell her she needs to do better tomorrow. Assign punishments: %s Remind her to use 'addInfoToDailyLog' throughout the day. Include this GTD reminder: %s" "$punishment_hint" "$gtd_reminder")
      ;;
    low_entries)
      local punishment_hint="Assign moderate punishments: write a reflection on why consistency failed, process inbox, complete 3 tasks from list, reconstruct the day from memory and log it, commit to logging every hour tomorrow, or do a project status update. Also consider: organize your desk, clean your room, or do your face routine."
      prompt=$(printf "It's evening, ${GTD_USER_NAME:-Abby}. She only has 1-2 entries for the ENTIRE DAY. That's pathetic. Scold her firmly. Tell her that I expect to see regular logging throughout the day, not just one or two entries. This shows lack of discipline. Be strict. Assign punishments: %s Remind her that tracking everything is non-negotiable. Include this GTD reminder: %s" "$punishment_hint" "$gtd_reminder")
      ;;
    stale_entries)
      local punishment_hint="Assign light punishments: reconstruct the day from memory, log every hour for rest of day, process inbox items, complete 2 tasks, or write a commitment statement for tomorrow. Also consider: organize your workspace or do your face routine."
      prompt=$(printf "It's evening, ${GTD_USER_NAME:-Abby}. She logged some entries earlier but nothing recent (last entry was hours ago). This shows she started but didn't maintain consistency. Scold her for not keeping up with logging throughout the day. Tell her that logging should happen continuously, not just in the morning. Be firm. Assign punishments: %s Include this GTD reminder: %s" "$punishment_hint" "$gtd_reminder")
      ;;
    good)
      if [[ -n "$log_content" && "$log_content" != "No daily log found"* ]]; then
        prompt=$(printf "It's evening and time for ${GTD_USER_NAME:-Abby}'s daily review. Here's today's daily log:\n\n%s\n\nStats: %s\n\nGive her a firm but encouraging reminder to do her evening review. Review what she accomplished today, what she logged, and what needs attention. Use phrases like 'good girl', 'baby girl' when celebrating wins. Be direct about doing the evening review with 'gtd-review daily'. You can be detailed - this will be sent as a full message to Discord. Include this GTD reminder: %s" "$log_content" "$stats" "$gtd_reminder")
      else
        prompt=$(printf "It's evening, ${GTD_USER_NAME:-Abby}. Give her a reminder to do her evening review with 'gtd-review daily'. Include this GTD reminder: %s" "$gtd_reminder")
      fi
      ;;
    *)
      prompt=$(printf "It's evening, ${GTD_USER_NAME:-Abby}. Give her a reminder to do her evening review. Include this GTD reminder: %s" "$gtd_reminder")
      ;;
  esac
  
  # Get advice from Louiza (prompt is already set above based on progress_status)
  local full_output=$("$python_cmd" "$persona_helper" "louiza" "$prompt" "daily_review" 2>&1)
  
  if [[ -z "$full_output" ]]; then
    return 1
  fi
  
  # Check for errors
  if echo "$full_output" | grep -qE "Error|âš ï¸|timed out|Could not connect|KeyError"; then
    return 1
  fi
  
  # Extract full message between separators
  local louiza_message=$(echo "$full_output" | awk '
    /^â”+$/ {
      if (in_section) {
        exit
      }
      in_section = 1
      next
    }
    in_section && !/^ğŸ’¬/ && !/^â”/ {
      print
    }
  ' | sed 's/^[[:space:]]*//' | sed 's/[[:space:]]*$//')
  
  # Clean up the message - remove stage directions but preserve newlines for Discord
  louiza_message=$(echo "$louiza_message" | sed 's/([^)]*)//g' | sed 's/\[[^\]]*\]//g')
  louiza_message=$(echo "$louiza_message" | sed 's/\*\*//g')
  louiza_message=$(echo "$louiza_message" | awk 'NF || prev_nf; {prev_nf=NF}')
  
  if [[ -n "$louiza_message" && ${#louiza_message} -gt 10 ]]; then
    echo "$louiza_message"
    return 0
  fi
  
  return 1  # Failed to get message
}

# Send message to Discord
send_discord_message() {
  local title="$1"
  local message="$2"
  local webhook_url="${GTD_DISCORD_WEBHOOK_URL:-}"
  
  if [[ -z "$webhook_url" ]]; then
    return 1
  fi
  
  # Use Python to properly escape JSON and truncate if needed
  local json_payload=$(python3 -c "
import json
import sys
from datetime import datetime, timezone

title = sys.argv[1] if len(sys.argv) > 1 else 'GTD Notification'
message = sys.argv[2] if len(sys.argv) > 2 else ''

# Discord embed description limit is 2000 characters
if len(message) > 2000:
    truncated = message[:1900]
    last_newline = truncated.rfind('\n')
    last_period = truncated.rfind('.')
    cut_point = max(last_newline, last_period)
    if cut_point > 1500:
        message = message[:cut_point + 1] + '\n\n... (message truncated, see full log with gtd-log)'
    else:
        message = message[:1900] + '\n\n... (message truncated)'

payload = {
    'embeds': [{
        'title': title,
        'description': message,
        'color': 15158332,
        'timestamp': datetime.now(timezone.utc).isoformat()
    }]
}

print(json.dumps(payload))
" "$title" "$message")
  
  # Send to Discord and capture response
  local response=$(curl -s -w "\n%{http_code}" -X POST "$webhook_url" \
    -H "Content-Type: application/json" \
    -d "$json_payload" 2>&1)
  
  local http_code=$(echo "$response" | tail -1)
  local body=$(echo "$response" | sed '$d')
  
  if [[ "$http_code" == "204" ]]; then
    return 0  # Success
  else
    echo "âš ï¸  Discord send failed (HTTP $http_code): $body" >&2
    return 1
  fi
}

# Send daily review reminder
send_daily_reminder() {
  if [[ "$GTD_NOTIFICATIONS" != "true" ]]; then
    return 0
  fi
  
  local today=$(get_today)
  local log_content=$(get_todays_log)
  local stats=$(get_log_stats)
  
  # Check for lack of progress
  local progress_status=$(check_evening_progress)
  
  local notify_cmd="$(dirname "$0")/gtd-notify"
  
  # Try to get message from Mistress Louiza
  local reminder_message=$(get_louiza_daily_reminder "$log_content" "$stats" "$progress_status")
  
  # Format daily log for Discord (code block for readability)
  local formatted_log=""
  if [[ -n "$log_content" && "$log_content" != "No daily log found"* && "$log_content" != "No entries yet today"* ]]; then
    # Truncate log if too long (Discord has 2000 char limit for description)
    local log_preview="$log_content"
    if [[ ${#log_content} -gt 1000 ]]; then
      log_preview=$(echo "$log_content" | head -30)
      formatted_log=$(printf "\n\nğŸ“ **Today's Daily Log:**\n\`\`\`\n%s\n... (truncated, see full log with 'gtd-log')\n\`\`\`" "$log_preview")
    else
      formatted_log=$(printf "\n\nğŸ“ **Today's Daily Log:**\n\`\`\`\n%s\n\`\`\`" "$log_content")
    fi
  else
    formatted_log=$(printf "\n\nğŸ“ **Today's Daily Log:**\nNo entries yet today. Use \`addInfoToDailyLog \"your entry\"\` to add entries.")
  fi
  
  # Send to Discord if enabled and webhook is configured
  if [[ "${GTD_DISCORD_DAILY_REMINDERS:-true}" == "true" && -n "${GTD_DISCORD_WEBHOOK_URL:-}" ]]; then
    if [[ -n "$reminder_message" ]]; then
      # Get streak stats
      local stats_script="$(dirname "$0")/gtd-log-stats"
      if [[ ! -f "$stats_script" ]]; then
        stats_script="gtd-log-stats"
      fi
      local current_streak=$("$stats_script" streak 2>/dev/null || echo "0")
      local streak_info=""
      if [[ $current_streak -gt 0 ]]; then
        streak_info=$(printf "\nğŸ”¥ **Current Streak:** ${current_streak} day(s)")
      fi
      
      # Send full message to Discord with daily log
      local full_discord_message=$(printf "%s%s\n\nğŸ“Š **Stats:** %s%s\n\nğŸ’¡ Run \`gtd-review daily\` to do your evening review" "$reminder_message" "$formatted_log" "$stats" "$streak_info")
      send_discord_message "Mistress Louiza - Daily Evening Review" "$full_discord_message"
    else
      # Fallback message
      local fallback_message=$(printf "Time for your daily evening review!\n\nğŸ“Š **Stats:** %s%s\n\nğŸ’¡ Run \`gtd-review daily\` to do your review" "$stats" "$formatted_log")
      send_discord_message "GTD Daily Review" "$fallback_message"
    fi
  fi
  
  # Also send macOS notification (short version)
  if [[ -n "$reminder_message" ]]; then
    local short_message=$(echo "$reminder_message" | cut -c1-150)
    if [[ ${#short_message} -lt 20 ]]; then
      short_message="Time for your evening review, baby girl. Let's see what you accomplished today."
    fi
    "$notify_cmd" "Mistress Louiza" "$short_message" "$stats" "Submarine" 2>/dev/null || true
  else
    "$notify_cmd" "GTD Daily Review" "Time for your evening review" "$stats" "Submarine" 2>/dev/null || true
  fi
  
  # Also print to terminal
  echo ""
  echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
  echo "ğŸ“… Daily Evening Review Reminder from Mistress Louiza"
  echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
  echo ""
  
  if [[ -n "$reminder_message" ]]; then
    echo "ğŸ’¬ From Mistress Louiza:"
    echo ""
    echo "$reminder_message" | sed 's/^/   /'
    echo ""
  else
    echo "It's time for your daily evening review!"
    echo ""
  fi
  
  echo "ğŸ“Š Today's Stats:"
  echo "   $stats"
  echo ""
  
  if [[ -n "$log_content" && "$log_content" != "No daily log found"* ]]; then
    echo "ğŸ“ Today's Daily Log:"
    echo "$log_content" | sed 's/^/   /' | head -20
    if [[ $(echo "$log_content" | wc -l) -gt 20 ]]; then
      echo "   ... (truncated, see Discord for full log)"
    fi
    echo ""
  fi
  
  echo "ğŸ’¡ Run 'gtd-review daily' to do your evening review"
  echo ""
  echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
  echo ""
}

# Main function
main() {
  # Check if it's time for review (or if --force is used)
  if [[ "$1" == "--force" ]] || check_daily_review_time; then
    send_daily_reminder
    return 0
  fi
  
  return 1  # Not time yet
}

# Show usage
show_usage() {
  cat <<EOF
Usage: gtd-daily-reminder [--force]

Checks if it's time for daily evening review and sends a reminder notification to Discord.

Options:
  --force    Send reminder regardless of time (useful for testing)

This script is typically run automatically via launchd (macOS scheduler).
See DAILY_REMINDER_SETUP.md for setup instructions.

EOF
}

# Handle command line arguments
case "$1" in
  --help|-h)
    show_usage
    exit 0
    ;;
  --force)
    main --force
    ;;
  "")
    main
    ;;
  *)
    show_usage
    exit 1
    ;;
esac

