#!/bin/bash
# CKA Typing Simulator - Practice kubectl commands for muscle memory

# Load GTD config
GTD_CONFIG_FILE="$HOME/.gtd_config"
if [[ -f "$HOME/code/dotfiles/zsh/.gtd_config" ]]; then
  GTD_CONFIG_FILE="$HOME/code/dotfiles/zsh/.gtd_config"
elif [[ -f "$HOME/code/personal/dotfiles/zsh/.gtd_config" ]]; then
  GTD_CONFIG_FILE="$HOME/code/personal/dotfiles/zsh/.gtd_config"
fi

if [[ -f "$GTD_CONFIG_FILE" ]]; then
  source "$GTD_CONFIG_FILE"
fi

# Source common GTD helpers (DRY - reuse existing helpers)
GTD_COMMON="$HOME/code/dotfiles/bin/gtd-common.sh"
if [[ ! -f "$GTD_COMMON" && -f "$HOME/code/personal/dotfiles/bin/gtd-common.sh" ]]; then
  GTD_COMMON="$HOME/code/personal/dotfiles/bin/gtd-common.sh"
fi
if [[ -f "$GTD_COMMON" ]]; then
  source "$GTD_COMMON"
else
  echo "Warning: gtd-common.sh not found. Some features may not work." >&2
fi

# GTD_BASE_DIR is already set by init_gtd_paths in gtd-common.sh (DRY - reuse existing helper)
STUDY_DIR="${GTD_BASE_DIR}/study"
K8S_STUDY_DIR="${STUDY_DIR}/kubernetes-cka"
TYPING_STATS_FILE="${K8S_STUDY_DIR}/typing-stats.json"

# Colors
CYAN='\033[0;36m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
BLUE='\033[0;34m'
MAGENTA='\033[0;35m'
BOLD='\033[1m'
NC='\033[0m'

# Get date command
get_date_cmd() {
  if [[ -x "/usr/bin/date" ]]; then
    echo "/usr/bin/date"
  elif [[ -x "/bin/date" ]]; then
    echo "/bin/date"
  else
    echo "date"
  fi
}

DATE_CMD=$(get_date_cmd)

# Initialize typing stats
init_typing_stats() {
  if [[ ! -f "$TYPING_STATS_FILE" ]]; then
    mkdir -p "$K8S_STUDY_DIR"
    cat > "$TYPING_STATS_FILE" <<EOF
{
  "sessions": 0,
  "total_commands": 0,
  "total_accuracy": 0,
  "total_time": 0,
  "best_wpm": 0,
  "best_accuracy": 0,
  "commands_practiced": {},
  "last_session": null
}
EOF
  fi
}

# Command sets for different topics (bash 3.2 compatible)
# Helper functions for associative array simulation
_set_array_value() {
  local prefix="$1"
  local key="$2"
  local value="$3"
  eval "${prefix}_${key}=\"\$value\""
}

_get_array_value() {
  local prefix="$1"
  local key="$2"
  eval "echo \"\$${prefix}_${key}\""
}

# Basic commands (beginner)
_set_array_value "COMMAND_SETS" "basic" "
kubectl get pods
kubectl get nodes
kubectl get namespaces
kubectl get pods -A
kubectl get pods --all-namespaces
kubectl get pods -o wide
kubectl get pods -o yaml
kubectl get pods -o json
kubectl describe pod my-pod
kubectl logs my-pod
kubectl logs -f my-pod
kubectl exec -it my-pod -- /bin/sh
kubectl exec my-pod -- ls
kubectl delete pod my-pod
"

# Pod management (intermediate)
_set_array_value "COMMAND_SETS" "pods" "
kubectl create pod my-pod --image=nginx
kubectl run my-pod --image=nginx
kubectl get pod my-pod -o yaml
kubectl edit pod my-pod
kubectl patch pod my-pod -p '{\"spec\":{\"containers\":[{\"name\":\"nginx\",\"image\":\"nginx:1.21\"}]}}'
kubectl label pod my-pod env=prod
kubectl get pods -l env=prod
kubectl annotate pod my-pod description='My pod'
kubectl port-forward pod/my-pod 8080:80
kubectl cp /local/file pod/my-pod:/remote/path
"

# Deployments (intermediate)
_set_array_value "COMMAND_SETS" "deployments" "
kubectl create deployment my-app --image=nginx
kubectl get deployments
kubectl scale deployment my-app --replicas=3
kubectl rollout status deployment/my-app
kubectl rollout history deployment/my-app
kubectl rollout undo deployment/my-app
kubectl rollout undo deployment/my-app --to-revision=2
kubectl set image deployment/my-app nginx=nginx:1.21
kubectl set env deployment/my-app ENV=prod
kubectl autoscale deployment my-app --min=2 --max=10 --cpu-percent=80
"

# Services (intermediate)
_set_array_value "COMMAND_SETS" "services" "
kubectl expose deployment my-app --port=80
kubectl expose pod my-pod --port=80 --type=NodePort
kubectl get services
kubectl get svc
kubectl describe service my-service
kubectl get endpoints my-service
kubectl port-forward service/my-service 8080:80
kubectl delete service my-service
"

# ConfigMaps and Secrets (intermediate)
_set_array_value "COMMAND_SETS" "config" "
kubectl create configmap my-config --from-literal=key1=value1
kubectl create configmap my-config --from-file=config.properties
kubectl get configmaps
kubectl describe configmap my-config
kubectl create secret generic my-secret --from-literal=password=secret
kubectl create secret tls my-tls --cert=cert.pem --key=key.pem
kubectl get secrets
kubectl describe secret my-secret
kubectl get secret my-secret -o yaml
kubectl get secret my-secret -o jsonpath='{.data.password}' | base64 -d
"

# Storage (advanced)
_set_array_value "COMMAND_SETS" "storage" "
kubectl get pv
kubectl get pvc
kubectl get storageclass
kubectl describe pv my-pv
kubectl describe pvc my-pvc
kubectl get pvc -n default
kubectl delete pvc my-pvc
"

# Troubleshooting (advanced)
_set_array_value "COMMAND_SETS" "troubleshooting" "
kubectl get events --sort-by='.lastTimestamp'
kubectl get events -n default
kubectl top nodes
kubectl top pods
kubectl get pods --field-selector=status.phase=Running
kubectl get pods --field-selector=status.phase!=Running
kubectl get pods -o custom-columns=NAME:.metadata.name,STATUS:.status.phase
kubectl get nodes -o wide
kubectl describe node my-node
kubectl get componentstatuses
kubectl get cs
"

# Exam-focused commands (all topics)
_set_array_value "COMMAND_SETS" "exam" "
kubectl get pods -n kube-system
kubectl get pods --all-namespaces
kubectl get nodes -o wide
kubectl get deployments -A
kubectl get services -A
kubectl get configmaps -A
kubectl get secrets -A
kubectl get pv
kubectl get pvc -A
kubectl get events --sort-by='.lastTimestamp' -A
kubectl logs -l app=my-app
kubectl exec -it deployment/my-app -- /bin/sh
kubectl scale deployment my-app --replicas=5
kubectl rollout restart deployment/my-app
kubectl set image deployment/my-app nginx=nginx:1.21
kubectl expose deployment my-app --port=80 --type=NodePort
kubectl create configmap my-config --from-literal=key=value
kubectl create secret generic my-secret --from-literal=password=secret
kubectl label pod my-pod tier=frontend
kubectl annotate pod my-pod description='My pod'
kubectl port-forward pod/my-pod 8080:80
kubectl cp /local/file pod/my-pod:/remote/path
"

# Get random command from set
get_random_command() {
  local topic="$1"
  local commands="$(_get_array_value "COMMAND_SETS" "$topic")"
  
  if [[ -z "$commands" ]]; then
    echo ""
    return 1
  fi
  
  # Convert to array, filter empty lines
  local cmd_array=()
  while IFS= read -r line; do
    [[ -n "$line" ]] && cmd_array+=("$line")
  done <<< "$commands"
  
  if [[ ${#cmd_array[@]} -eq 0 ]]; then
    echo ""
    return 1
  fi
  
  # Return random command
  local idx=$((RANDOM % ${#cmd_array[@]}))
  echo "${cmd_array[$idx]}"
}

# Calculate WPM (words per minute)
calculate_wpm() {
  local chars="$1"
  local seconds="$2"
  
  if [[ $seconds -eq 0 ]]; then
    echo "0"
    return
  fi
  
  # Average word is 5 characters, WPM = (chars / 5) / (seconds / 60)
  local words=$((chars / 5))
  local minutes=$(echo "scale=2; $seconds / 60" | bc 2>/dev/null || echo "0")
  
  if [[ -z "$minutes" || "$minutes" == "0" ]]; then
    echo "0"
    return
  fi
  
  local wpm=$(echo "scale=0; $words / $minutes" | bc 2>/dev/null || echo "0")
  echo "${wpm%.*}"
}

# Calculate accuracy
calculate_accuracy() {
  local correct="$1"
  local total="$2"
  
  if [[ $total -eq 0 ]]; then
    echo "0"
    return
  fi
  
  local accuracy=$(echo "scale=1; ($correct * 100) / $total" | bc 2>/dev/null || echo "0")
  echo "$accuracy"
}

# Practice a single command
practice_command() {
  local command="$1"
  local show_hint="${2:-false}"
  
  clear
  echo -e "${BOLD}${CYAN}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${NC}"
  echo -e "${BOLD}${CYAN}‚å®Ô∏è  CKA Typing Practice${NC}"
  echo -e "${CYAN}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${NC}"
  echo ""
  
  if [[ "$show_hint" == "true" ]]; then
    echo -e "${YELLOW}üí° Hint: This command ${command%% *}...${NC}"
    echo ""
  fi
  
  echo -e "${BOLD}Type this command:${NC}"
  echo ""
  echo -e "${GREEN}${command}${NC}"
  echo ""
  echo -e "${CYAN}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${NC}"
  echo ""
  echo -e "${YELLOW}Type the command below (press Enter when done):${NC}"
  echo ""
  
  # Start timer
  local start_time=$(date +%s)
  
  # Get user input
  read -r user_input
  
  # End timer
  local end_time=$(date +%s)
  local duration=$((end_time - start_time))
  
  # Compare input
  if [[ "$user_input" == "$command" ]]; then
    # Correct!
    local cmd_length=${#command}
    local wpm=$(calculate_wpm $cmd_length $duration)
    local accuracy=100.0
    
    echo ""
    echo -e "${GREEN}‚úì Correct!${NC}"
    echo -e "   Time: ${duration}s | WPM: ${wpm} | Accuracy: ${accuracy}%"
    echo ""
    
    # Update stats
    update_typing_stats "$command" "$duration" "$wpm" "$accuracy" "correct"
    
    echo -e "${BOLD}Press Enter for next command (or 'q' to quit)...${NC}"
    read -r next_action
    
    if [[ "$next_action" == "q" || "$next_action" == "Q" ]]; then
      return 2  # Quit signal
    fi
    
    return 0  # Success
  else
    # Incorrect - show comparison
    echo ""
    echo -e "${RED}‚úó Incorrect${NC}"
    echo ""
    echo -e "${BOLD}Expected:${NC} ${GREEN}${command}${NC}"
    echo -e "${BOLD}You typed:${NC} ${RED}${user_input}${NC}"
    echo ""
    
    # Show character-by-character comparison
    local expected_len=${#command}
    local input_len=${#user_input}
    local max_len=$((expected_len > input_len ? expected_len : input_len))
    
    echo -e "${BOLD}Character comparison:${NC}"
    local correct_chars=0
    for ((i=0; i<max_len; i++)); do
      local exp_char="${command:$i:1}"
      local inp_char="${user_input:$i:1}"
      
      if [[ "$exp_char" == "$inp_char" ]]; then
        echo -ne "${GREEN}${exp_char}${NC}"
        ((correct_chars++))
      else
        if [[ -n "$exp_char" ]]; then
          echo -ne "${RED}${exp_char}${NC}"
        fi
        if [[ -n "$inp_char" && "$inp_char" != "$exp_char" ]]; then
          echo -ne "${YELLOW}[${inp_char}]${NC}"
        fi
      fi
    done
    echo ""
    echo ""
    
    local cmd_length=${#command}
    local wpm=$(calculate_wpm $cmd_length $duration)
    local total_chars=${#command}
    local accuracy=$(calculate_accuracy $correct_chars $total_chars)
    
    echo -e "   Time: ${duration}s | WPM: ${wpm} | Accuracy: ${accuracy}%"
    echo ""
    
    # Update stats
    update_typing_stats "$command" "$duration" "$wpm" "$accuracy" "incorrect"
    
    echo -e "${BOLD}Press Enter to try again (or 's' to skip, 'q' to quit)...${NC}"
    read -r next_action
    
    if [[ "$next_action" == "q" || "$next_action" == "Q" ]]; then
      return 2  # Quit signal
    elif [[ "$next_action" == "s" || "$next_action" == "S" ]]; then
      return 1  # Skip
    else
      return 3  # Try again
    fi
  fi
}

# Update typing statistics
update_typing_stats() {
  local command="$1"
  local duration="$2"
  local wpm="$3"
  local accuracy="$4"
  local result="$5"
  
  init_typing_stats
  
  local data=$(cat "$TYPING_STATS_FILE")
  local sessions=$(echo "$data" | grep -o '"sessions": [0-9]*' | grep -o '[0-9]*')
  local total_commands=$(echo "$data" | grep -o '"total_commands": [0-9]*' | grep -o '[0-9]*')
  local total_accuracy=$(echo "$data" | grep -o '"total_accuracy": [0-9.]*' | grep -o '[0-9.]*')
  local total_time=$(echo "$data" | grep -o '"total_time": [0-9]*' | grep -o '[0-9]*')
  local best_wpm=$(echo "$data" | grep -o '"best_wpm": [0-9]*' | grep -o '[0-9]*')
  local best_accuracy=$(echo "$data" | grep -o '"best_accuracy": [0-9.]*' | grep -o '[0-9.]*')
  
  # Update totals
  local new_total_commands=$((total_commands + 1))
  local new_total_time=$((total_time + duration))
  
  # Calculate new average accuracy
  local new_total_accuracy=$(echo "scale=2; (($total_accuracy * $total_commands) + $accuracy) / $new_total_commands" | bc 2>/dev/null || echo "$accuracy")
  
  # Update bests
  if [[ $wpm -gt $best_wpm ]]; then
    best_wpm=$wpm
  fi
  
  local accuracy_float=$(echo "scale=1; $accuracy" | bc 2>/dev/null || echo "$accuracy")
  local best_accuracy_float=$(echo "scale=1; $best_accuracy" | bc 2>/dev/null || echo "0")
  
  if (( $(echo "$accuracy_float > $best_accuracy_float" | bc -l 2>/dev/null || echo "0") )); then
    best_accuracy=$accuracy_float
  fi
  
  # Update command-specific stats
  local cmd_key=$(echo "$command" | tr ' ' '_' | tr -d '[:punct:]' | tr '[:upper:]' '[:lower:]' | cut -c1-50)
  
  # Update JSON (simple sed-based approach)
  data=$(echo "$data" | sed "s/\"sessions\": $sessions/\"sessions\": $sessions/")
  data=$(echo "$data" | sed "s/\"total_commands\": $total_commands/\"total_commands\": $new_total_commands/")
  data=$(echo "$data" | sed "s/\"total_accuracy\": $total_accuracy/\"total_accuracy\": $new_total_accuracy/")
  data=$(echo "$data" | sed "s/\"total_time\": $total_time/\"total_time\": $new_total_time/")
  data=$(echo "$data" | sed "s/\"best_wpm\": $best_wpm/\"best_wpm\": $best_wpm/")
  data=$(echo "$data" | sed "s/\"best_accuracy\": $best_accuracy/\"best_accuracy\": $best_accuracy/")
  
  local today=$($DATE_CMD +"%Y-%m-%d")
  data=$(echo "$data" | sed "s/\"last_session\": \"[^\"]*\"/\"last_session\": \"$today\"/")
  
  echo "$data" > "$TYPING_STATS_FILE"
  
  # Award XP for practice session
  if command -v gtd-cka-gamification &>/dev/null; then
    if [[ "$result" == "correct" ]]; then
      gtd-cka-gamification practice > /dev/null 2>&1
    fi
  fi
}

# Show typing practice menu
show_typing_menu() {
  clear
  echo -e "${BOLD}${CYAN}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${NC}"
  echo -e "${BOLD}${CYAN}‚å®Ô∏è  CKA Typing Simulator${NC}"
  echo -e "${CYAN}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${NC}"
  echo ""
  echo -e "${BOLD}Practice kubectl commands for muscle memory${NC}"
  echo ""
  echo -e "${GREEN}1)${NC} Basic Commands (Beginner)"
  echo -e "${GREEN}2)${NC} Pod Management (Intermediate)"
  echo -e "${GREEN}3)${NC} Deployments (Intermediate)"
  echo -e "${GREEN}4)${NC} Services (Intermediate)"
  echo -e "${GREEN}5)${NC} ConfigMaps & Secrets (Intermediate)"
  echo -e "${GREEN}6)${NC} Storage (Advanced)"
  echo -e "${GREEN}7)${NC} Troubleshooting (Advanced)"
  echo -e "${GREEN}8)${NC} Exam-Focused (All Topics)"
  echo -e "${GREEN}9)${NC} Random Mix (All Topics)"
  echo -e "${GREEN}10)${NC} View Statistics"
  echo ""
  echo -e "${YELLOW}0)${NC} Exit"
  echo ""
  echo -n "Choose: "
}

# Show statistics
show_stats() {
  init_typing_stats
  
  local data=$(cat "$TYPING_STATS_FILE")
  local sessions=$(echo "$data" | grep -o '"sessions": [0-9]*' | grep -o '[0-9]*')
  local total_commands=$(echo "$data" | grep -o '"total_commands": [0-9]*' | grep -o '[0-9]*')
  local total_accuracy=$(echo "$data" | grep -o '"total_accuracy": [0-9.]*' | grep -o '[0-9.]*')
  local total_time=$(echo "$data" | grep -o '"total_time": [0-9]*' | grep -o '[0-9]*')
  local best_wpm=$(echo "$data" | grep -o '"best_wpm": [0-9]*' | grep -o '[0-9]*')
  local best_accuracy=$(echo "$data" | grep -o '"best_accuracy": [0-9.]*' | grep -o '[0-9.]*')
  
  clear
  echo -e "${BOLD}${CYAN}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${NC}"
  echo -e "${BOLD}${CYAN}üìä Typing Practice Statistics${NC}"
  echo -e "${CYAN}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${NC}"
  echo ""
  echo -e "${BOLD}Overall Stats:${NC}"
  echo -e "   Practice Sessions: ${sessions}"
  echo -e "   Commands Practiced: ${total_commands}"
  echo -e "   Total Practice Time: ${total_time} seconds"
  echo ""
  echo -e "${BOLD}Performance:${NC}"
  echo -e "   Average Accuracy: ${total_accuracy}%"
  echo -e "   Best WPM: ${best_wpm}"
  echo -e "   Best Accuracy: ${best_accuracy}%"
  echo ""
  
  if [[ $total_commands -gt 0 ]]; then
    local avg_time=$(echo "scale=1; $total_time / $total_commands" | bc 2>/dev/null || echo "0")
    echo -e "${BOLD}Average:${NC}"
    echo -e "   Time per command: ${avg_time}s"
  fi
  
  echo ""
  read -p "Press Enter to continue..."
}

# Practice session
practice_session() {
  local topic="$1"
  local count="${2:-10}"  # Default 10 commands
  
  init_typing_stats
  
  # Start session
  local data=$(cat "$TYPING_STATS_FILE")
  local sessions=$(echo "$data" | grep -o '"sessions": [0-9]*' | grep -o '[0-9]*')
  local new_sessions=$((sessions + 1))
  data=$(echo "$data" | sed "s/\"sessions\": $sessions/\"sessions\": $new_sessions/")
  echo "$data" > "$TYPING_STATS_FILE"
  
  local correct=0
  local total=0
  
  echo ""
  echo -e "${BOLD}Starting practice session...${NC}"
  echo -e "Topic: ${topic} | Commands: ${count}"
  echo ""
  sleep 1
  
  for ((i=1; i<=count; i++)); do
    local command=$(get_random_command "$topic")
    
    if [[ -z "$command" ]]; then
      echo "No commands available for topic: $topic"
      return 1
    fi
    
    # Practice the command - keep trying until correct, skipped, or quit
    while true; do
      practice_command "$command" "false"
      local result=$?
      
      if [[ $result -eq 0 ]]; then
        # Correct!
        ((correct++))
        ((total++))
        break  # Move to next command
      elif [[ $result -eq 2 ]]; then
        # User wants to quit
        # Show summary even if quitting early
        if [[ $total -gt 0 || $i -gt 1 ]]; then
          clear
          echo -e "${BOLD}${CYAN}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${NC}"
          echo -e "${BOLD}${CYAN}üìä Practice Session Complete${NC}"
          echo -e "${CYAN}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${NC}"
          echo ""
          
          if [[ $total -gt 0 ]]; then
            local accuracy=$(echo "scale=1; ($correct * 100) / $total" | bc 2>/dev/null || echo "0")
            echo -e "${BOLD}Results:${NC}"
            echo -e "   Commands: ${total}"
            echo -e "   Correct: ${GREEN}${correct}${NC}"
            echo -e "   Incorrect: ${RED}$((total - correct))${NC}"
            echo -e "   Accuracy: ${accuracy}%"
            echo ""
          fi
          
          echo ""
          read -p "Press Enter to continue..."
        fi
        return 0  # Exit session
      elif [[ $result -eq 1 ]]; then
        # User skipped this command
        ((total++))
        break  # Move to next command
      elif [[ $result -eq 3 ]]; then
        # Try again - loop back to practice the same command
        continue
      else
        # Unknown result, count as attempted
        ((total++))
        break  # Move to next command
      fi
    done
  done
  
  # Session summary
  clear
  echo -e "${BOLD}${CYAN}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${NC}"
  echo -e "${BOLD}${CYAN}üìä Practice Session Complete${NC}"
  echo -e "${CYAN}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${NC}"
  echo ""
  
  if [[ $total -gt 0 ]]; then
    local accuracy=$(echo "scale=1; ($correct * 100) / $total" | bc 2>/dev/null || echo "0")
    echo -e "${BOLD}Results:${NC}"
    echo -e "   Commands: ${total}"
    echo -e "   Correct: ${GREEN}${correct}${NC}"
    echo -e "   Incorrect: ${RED}$((total - correct))${NC}"
    echo -e "   Accuracy: ${accuracy}%"
    echo ""
    
    if (( $(echo "$accuracy >= 90" | bc -l 2>/dev/null || echo "0") )); then
      echo -e "${GREEN}üéâ Excellent! You're mastering these commands!${NC}"
    elif (( $(echo "$accuracy >= 70" | bc -l 2>/dev/null || echo "0") )); then
      echo -e "${YELLOW}üëç Good progress! Keep practicing!${NC}"
    else
      echo -e "${BLUE}üí™ Keep going! Practice makes perfect!${NC}"
    fi
  fi
  
  echo ""
  read -p "Press Enter to continue..."
}

# Main function
main() {
  init_typing_stats
  
  while true; do
    show_typing_menu
    read choice
    
    case "$choice" in
      1)
        echo ""
        read -p "How many commands to practice? (default: 10): " count
        count=${count:-10}
        practice_session "basic" "$count"
        ;;
      2)
        echo ""
        read -p "How many commands to practice? (default: 10): " count
        count=${count:-10}
        practice_session "pods" "$count"
        ;;
      3)
        echo ""
        read -p "How many commands to practice? (default: 10): " count
        count=${count:-10}
        practice_session "deployments" "$count"
        ;;
      4)
        echo ""
        read -p "How many commands to practice? (default: 10): " count
        count=${count:-10}
        practice_session "services" "$count"
        ;;
      5)
        echo ""
        read -p "How many commands to practice? (default: 10): " count
        count=${count:-10}
        practice_session "config" "$count"
        ;;
      6)
        echo ""
        read -p "How many commands to practice? (default: 10): " count
        count=${count:-10}
        practice_session "storage" "$count"
        ;;
      7)
        echo ""
        read -p "How many commands to practice? (default: 10): " count
        count=${count:-10}
        practice_session "troubleshooting" "$count"
        ;;
      8)
        echo ""
        read -p "How many commands to practice? (default: 10): " count
        count=${count:-10}
        practice_session "exam" "$count"
        ;;
      9)
        echo ""
        read -p "How many commands to practice? (default: 10): " count
        count=${count:-10}
        # Random mix - pick random topic for each command
        local topics=("basic" "pods" "deployments" "services" "config" "storage" "troubleshooting" "exam")
        local correct=0
        local total=0
        
        for ((i=1; i<=count; i++)); do
          local random_topic=${topics[$RANDOM % ${#topics[@]}]}
          local command=$(get_random_command "$random_topic")
          
          if [[ -n "$command" ]]; then
            practice_command "$command" "false"
            local result=$?
            
            if [[ $result -eq 0 ]]; then
              ((correct++))
              ((total++))
            elif [[ $result -eq 2 ]]; then
              break
            elif [[ $result -eq 3 ]]; then
              ((i--))
              continue
            else
              ((total++))
            fi
          fi
        done
        ;;
      10)
        show_stats
        ;;
      0)
        echo ""
        echo "Keep practicing! Muscle memory takes time, but you'll get there! ‚å®Ô∏è"
        exit 0
        ;;
      *)
        echo "Invalid choice. Press Enter..."
        read
        ;;
    esac
  done
}

# Check if bc is available (for calculations)
if ! command -v bc &>/dev/null; then
  echo "‚ö†Ô∏è  Warning: 'bc' command not found. Some calculations may not work."
  echo "   Install with: brew install bc (macOS) or apt-get install bc (Linux)"
  echo ""
fi

main "$@"

