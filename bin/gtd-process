#!/bin/bash
# GTD Process Command - Process inbox items using GTD methodology

# Load GTD config
GTD_CONFIG_FILE="$HOME/.gtd_config"
if [[ -f "$HOME/code/personal/dotfiles/zsh/.gtd_config" ]]; then
  GTD_CONFIG_FILE="$HOME/code/personal/dotfiles/zsh/.gtd_config"
fi

# Source config if it exists
if [[ -f "$GTD_CONFIG_FILE" ]]; then
  source "$GTD_CONFIG_FILE"
fi

# Default values
GTD_BASE_DIR="${GTD_BASE_DIR:-$HOME/Documents/gtd}"
GTD_INBOX_DIR="${GTD_INBOX_DIR:-0-inbox}"
GTD_PROJECTS_DIR="${GTD_PROJECTS_DIR:-1-projects}"
GTD_AREAS_DIR="${GTD_AREAS_DIR:-2-areas}"
GTD_REFERENCE_DIR="${GTD_REFERENCE_DIR:-3-reference}"
GTD_SOMEDAY_DIR="${GTD_SOMEDAY_DIR:-4-someday-maybe}"
GTD_WAITING_DIR="${GTD_WAITING_DIR:-5-waiting-for}"
GTD_ARCHIVE_DIR="${GTD_ARCHIVE_DIR:-6-archive}"

INBOX_PATH="${GTD_BASE_DIR}/${GTD_INBOX_DIR}"
PROJECTS_PATH="${GTD_BASE_DIR}/${GTD_PROJECTS_DIR}"
AREAS_PATH="${GTD_BASE_DIR}/${GTD_AREAS_DIR}"
REFERENCE_PATH="${GTD_BASE_DIR}/${GTD_REFERENCE_DIR}"
SOMEDAY_PATH="${GTD_BASE_DIR}/${GTD_SOMEDAY_DIR}"
WAITING_PATH="${GTD_BASE_DIR}/${GTD_WAITING_DIR}"
ARCHIVE_PATH="${GTD_BASE_DIR}/${GTD_ARCHIVE_DIR}"

# Create directories if they don't exist
mkdir -p "$INBOX_PATH" "$PROJECTS_PATH" "$AREAS_PATH" "$REFERENCE_PATH" "$SOMEDAY_PATH" "$WAITING_PATH" "$ARCHIVE_PATH"

# Get inbox items
get_inbox_items() {
  find "$INBOX_PATH" -type f -name "*.md" -maxdepth 1 2>/dev/null | sort
}

# Count inbox items
count_inbox_items() {
  get_inbox_items | wc -l | tr -d ' '
}

# Extract frontmatter value
get_frontmatter_value() {
  local file="$1"
  local key="$2"
  grep "^${key}:" "$file" 2>/dev/null | head -1 | cut -d':' -f2 | sed 's/^[[:space:]]*//' | sed 's/[[:space:]]*$//'
}

# Update frontmatter value
update_frontmatter_value() {
  local file="$1"
  local key="$2"
  local value="$3"
  
  if grep -q "^${key}:" "$file" 2>/dev/null; then
    # Update existing key
    if [[ "$OSTYPE" == "darwin"* ]]; then
      sed -i '' "s/^${key}:.*/${key}: ${value}/" "$file"
    else
      sed -i "s/^${key}:.*/${key}: ${value}/" "$file"
    fi
  else
    # Add new key after first ---
    if [[ "$OSTYPE" == "darwin"* ]]; then
      sed -i '' "/^---$/a\\
${key}: ${value}
" "$file"
    else
      sed -i "/^---$/a\\${key}: ${value}" "$file"
    fi
  fi
}

# Process a single item
process_item() {
  local file="$1"
  local filename=$(basename "$file")
  
  echo ""
  echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
  echo "ğŸ“‹ Processing: $filename"
  echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
  
  # Show file content
  echo ""
  echo "Content:"
  head -20 "$file" | tail -15
  echo ""
  
  # GTD Processing Questions
  echo "1. What is it?"
  read -p "   Description: " description
  
  echo ""
  echo "2. Is it actionable?"
  echo "   a) Yes - I need to do something"
  echo "   b) No - It's reference, trash, or someday/maybe"
  read -p "   Choice (a/b): " actionable_choice
  
  if [[ "$actionable_choice" != "a" ]]; then
    # Not actionable
    echo ""
    echo "3. What should we do with it?"
    echo "   1) Delete (trash)"
    echo "   2) Reference (file for later)"
    echo "   3) Someday/Maybe"
    read -p "   Choice (1-3): " non_actionable_choice
    
    case "$non_actionable_choice" in
      1)
        echo "ğŸ—‘ï¸  Deleting..."
        rm "$file"
        echo "âœ“ Deleted"
        return
        ;;
      2)
        echo "ğŸ“š Moving to reference..."
        mv "$file" "$REFERENCE_PATH/"
        echo "âœ“ Moved to reference: $REFERENCE_PATH/"
        return
        ;;
      3)
        echo "ğŸ’­ Moving to Someday/Maybe..."
        mv "$file" "$SOMEDAY_PATH/"
        echo "âœ“ Moved to Someday/Maybe: $SOMEDAY_PATH/"
        return
        ;;
      *)
        echo "âš ï¸  Invalid choice, skipping..."
        return
        ;;
    esac
  fi
  
  # Actionable - continue processing
  echo ""
  echo "3. Will it take less than 2 minutes?"
  read -p "   Yes/No (y/n): " two_minute
  
  if [[ "$two_minute" == "y" ]]; then
    echo "âš¡ Do it now! (Marking as done)"
    update_frontmatter_value "$file" "status" "done"
    mv "$file" "$ARCHIVE_PATH/"
    echo "âœ“ Archived as done"
    return
  fi
  
  echo ""
  echo "4. Does it require multiple steps?"
  read -p "   Yes/No (y/n): " multiple_steps
  
  if [[ "$multiple_steps" == "y" ]]; then
    # Create project
    echo ""
    read -p "   Project name: " project_name
    project_name=$(echo "$project_name" | tr ' ' '-' | tr '[:upper:]' '[:lower:]')
    project_dir="${PROJECTS_PATH}/${project_name}"
    mkdir -p "$project_dir"
    
    # Move file to project
    mv "$file" "${project_dir}/README.md"
    update_frontmatter_value "${project_dir}/README.md" "status" "active"
    update_frontmatter_value "${project_dir}/README.md" "type" "project"
    update_frontmatter_value "${project_dir}/README.md" "project" "$project_name"
    
    echo "âœ“ Created project: $project_name"
    echo "  Location: $project_dir"
  else
    # Single action - create task
    echo ""
    echo "5. What's the next action?"
    read -p "   Next action: " next_action
    
    # Get context
    echo ""
    echo "6. What's the context?"
    echo "   Available: home, office, computer, phone, errands, online, offline"
    read -p "   Context: " context
    
    # Get energy level
    echo ""
    echo "7. What's the energy level required?"
    echo "   Available: low, medium, high, creative, administrative"
    read -p "   Energy: " energy
    
    # Get priority
    echo ""
    echo "8. What's the priority?"
    echo "   1) Urgent & Important"
    echo "   2) Not Urgent & Important"
    echo "   3) Urgent & Not Important"
    echo "   4) Not Urgent & Not Important"
    read -p "   Priority (1-4): " priority_choice
    
    case "$priority_choice" in
      1) priority="urgent_important" ;;
      2) priority="not_urgent_important" ;;
      3) priority="urgent_not_important" ;;
      4) priority="not_urgent_not_important" ;;
      *) priority="not_urgent_important" ;;
    esac
    
    # Update file
    update_frontmatter_value "$file" "status" "active"
    update_frontmatter_value "$file" "type" "task"
    update_frontmatter_value "$file" "next_action" "$next_action"
    update_frontmatter_value "$file" "context" "$context"
    update_frontmatter_value "$file" "energy" "$energy"
    update_frontmatter_value "$file" "priority" "$priority"
    
    # Move to tasks directory (create if needed)
    TASKS_PATH="${GTD_BASE_DIR}/tasks"
    mkdir -p "$TASKS_PATH"
    mv "$file" "${TASKS_PATH}/"
    
    echo "âœ“ Created task"
    echo "  Next action: $next_action"
    echo "  Context: $context"
    echo "  Energy: $energy"
  fi
}

# Main processing loop
main() {
  local process_all=false
  
  # Parse arguments
  case "$1" in
    --all|-a)
      process_all=true
      ;;
    --help|-h)
      echo "Usage: gtd-process [--all]"
      echo ""
      echo "Process inbox items using GTD methodology."
      echo ""
      echo "Options:"
      echo "  --all, -a    Process all items in inbox"
      echo "  --help, -h   Show this help"
      exit 0
      ;;
  esac
  
  local inbox_count=$(count_inbox_items)
  
  if [[ $inbox_count -eq 0 ]]; then
    echo "âœ“ Inbox is empty! Nothing to process."
    exit 0
  fi
  
  echo "ğŸ“¥ Inbox has $inbox_count item(s) to process"
  
  if [[ "$process_all" == "true" ]]; then
    # Process all items
    local items=($(get_inbox_items))
    for item in "${items[@]}"; do
      process_item "$item"
    done
    echo ""
    echo "âœ“ Finished processing all items"
  else
    # Process one item
    local items=($(get_inbox_items))
    if [[ ${#items[@]} -gt 0 ]]; then
      process_item "${items[0]}"
      local remaining=$(count_inbox_items)
      if [[ $remaining -gt 0 ]]; then
        echo ""
        echo "ğŸ“¥ $remaining item(s) remaining in inbox"
        echo "   Run 'gtd-process' again or 'gtd-process --all' to process all"
      fi
    fi
  fi
}

main "$@"



