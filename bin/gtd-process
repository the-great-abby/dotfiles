#!/bin/bash
# GTD Process Command - Process inbox items using GTD methodology

# Source common GTD helpers
GTD_COMMON="$HOME/code/dotfiles/bin/gtd-common.sh"
if [[ ! -f "$GTD_COMMON" && -f "$HOME/code/personal/dotfiles/bin/gtd-common.sh" ]]; then
  GTD_COMMON="$HOME/code/personal/dotfiles/bin/gtd-common.sh"
fi
if [[ -f "$GTD_COMMON" ]]; then
  source "$GTD_COMMON"
else
  echo "Warning: gtd-common.sh not found. Some features may not work." >&2
fi

# Additional paths (INBOX_PATH, REFERENCE_PATH, SOMEDAY_PATH, WAITING_PATH, ARCHIVE_PATH 
# are already set by init_gtd_paths in gtd-common.sh - DRY - reuse existing helper)
# Keep directory name variables for backward compatibility if needed

# Create directories if they don't exist
mkdir -p "$INBOX_PATH" "$PROJECTS_PATH" "$AREAS_PATH" "$REFERENCE_PATH" "$SOMEDAY_PATH" "$WAITING_PATH" "$ARCHIVE_PATH"

# Get inbox items
get_inbox_items() {
  find "$INBOX_PATH" -type f -name "*.md" -maxdepth 1 2>/dev/null | sort
}

# Count inbox items
count_inbox_items() {
  get_inbox_items | wc -l | tr -d ' '
}

# Extract frontmatter value
get_frontmatter_value() {
  local file="$1"
  local key="$2"
  grep "^${key}:" "$file" 2>/dev/null | head -1 | cut -d':' -f2 | sed 's/^[[:space:]]*//' | sed 's/[[:space:]]*$//'
}

# Update frontmatter value
update_frontmatter_value() {
  local file="$1"
  local key="$2"
  local value="$3"
  
  if grep -q "^${key}:" "$file" 2>/dev/null; then
    # Update existing key
    if [[ "$OSTYPE" == "darwin"* ]]; then
      sed -i '' "s/^${key}:.*/${key}: ${value}/" "$file"
    else
      sed -i "s/^${key}:.*/${key}: ${value}/" "$file"
    fi
  else
    # Add new key after first ---
    if [[ "$OSTYPE" == "darwin"* ]]; then
      sed -i '' "/^---$/a\\
${key}: ${value}
" "$file"
    else
      sed -i "/^---$/a\\${key}: ${value}" "$file"
    fi
  fi
}

# Process a single item
process_item() {
  local file="$1"
  local filename=$(basename "$file")
  
  echo ""
  echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
  echo "ðŸ“‹ Processing: $filename"
  echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
  
  # Show file preview and allow viewing full content
  echo ""
  echo "Content (preview):"
  head -20 "$file" | tail -15
  echo ""
  
  # Menu for viewing options
  while true; do
    echo "Options:"
    echo "  1) View full file contents"
    echo "  2) Open in editor"
    echo "  3) Continue processing (default)"
    echo ""
    read -p "Choose (1-3, or Enter to continue): " view_choice
    
    case "$view_choice" in
      1|"v"|"view")
        echo ""
        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
        echo "Full content of: $filename"
        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
        echo ""
        cat "$file"
        echo ""
        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
        echo ""
        echo "Press Enter to continue..."
        read
        break
        ;;
      2|"e"|"edit")
        if [[ -n "$EDITOR" ]]; then
          $EDITOR "$file"
          echo ""
          echo "Press Enter to continue processing after editing..."
          read
        else
          echo "âš ï¸  EDITOR environment variable not set"
          echo "   You can set it with: export EDITOR='vim' (or your preferred editor)"
        fi
        break
        ;;
      3|""|"c"|"continue")
        break
        ;;
      *)
        echo "Invalid choice. Please choose 1, 2, or 3 (or press Enter)."
        ;;
    esac
  done
  
  # GTD Processing Questions
  echo ""
  echo "1. What is it?"
  read -p "   Description: " description
  
  echo ""
  echo "2. Is it actionable?"
  echo "   a) Yes - I need to do something"
  echo "   b) No - It's reference, trash, or someday/maybe"
  read -p "   Choice (a/b): " actionable_choice
  
  if [[ "$actionable_choice" != "a" ]]; then
    # Not actionable
    echo ""
    echo "3. What should we do with it?"
    echo "   1) Delete (trash)"
    echo "   2) Reference (file for later)"
    echo "   3) Someday/Maybe"
    read -p "   Choice (1-3): " non_actionable_choice
    
    case "$non_actionable_choice" in
      1)
        echo "ðŸ—‘ï¸  Deleting..."
        rm "$file"
        echo "âœ“ Deleted"
        return
        ;;
      2)
        echo "ðŸ“š Moving to reference..."
        mv "$file" "$REFERENCE_PATH/"
        echo "âœ“ Moved to reference: $REFERENCE_PATH/"
        return
        ;;
      3)
        echo "ðŸ’­ Moving to Someday/Maybe..."
        mv "$file" "$SOMEDAY_PATH/"
        echo "âœ“ Moved to Someday/Maybe: $SOMEDAY_PATH/"
        return
        ;;
      *)
        echo "âš ï¸  Invalid choice, skipping..."
        return
        ;;
    esac
  fi
  
  # Actionable - continue processing
  echo ""
  echo "3. Will it take less than 2 minutes?"
  read -p "   Yes/No (y/n): " two_minute
  
  if [[ "$two_minute" == "y" ]]; then
    echo "âš¡ Do it now! (Marking as done)"
    update_frontmatter_value "$file" "status" "done"
    mv "$file" "$ARCHIVE_PATH/"
    echo "âœ“ Archived as done"
    return
  fi
  
  echo ""
  echo "4. Does it require multiple steps?"
  read -p "   Yes/No (y/n): " multiple_steps
  
  if [[ "$multiple_steps" == "y" ]]; then
    # Create or select project
    echo ""
    echo "   Link to existing project or create new?"
    if [[ -d "$PROJECTS_PATH" ]] && [[ -n "$(find "$PROJECTS_PATH" -type d -mindepth 1 -maxdepth 1 2>/dev/null)" ]]; then
      echo ""
      echo "   Available projects:"
      # Don't redirect stderr - we want to see the list!
      existing_project=$(select_from_list "project" "$PROJECTS_PATH" "project")
      if [[ -n "$existing_project" ]]; then
        # User selected an existing project
        project_name=$(echo "$existing_project" | tr ' ' '-' | tr '[:upper:]' '[:lower:]')
      else
        # User wants to create new - ask for name
        echo ""
        read -p "   New project name: " project_name
        project_name=$(echo "$project_name" | tr ' ' '-' | tr '[:upper:]' '[:lower:]')
      fi
    else
      # No existing projects, just ask for name
      read -p "   Project name: " project_name
      project_name=$(echo "$project_name" | tr ' ' '-' | tr '[:upper:]' '[:lower:]')
    fi
    project_dir="${PROJECTS_PATH}/${project_name}"
    mkdir -p "$project_dir"
    
    # Move file to project
    mv "$file" "${project_dir}/README.md"
    update_frontmatter_value "${project_dir}/README.md" "status" "active"
    update_frontmatter_value "${project_dir}/README.md" "type" "project"
    update_frontmatter_value "${project_dir}/README.md" "project" "$project_name"
    
    echo "âœ“ Created project: $project_name"
    echo "  Location: $project_dir"
  else
    # Single action - create task
    echo ""
    echo "5. What's the next action?"
    read -p "   Next action: " next_action
    
    # Get context
    echo ""
    echo "6. What's the context?"
    echo "   Available: home, office, computer, phone, errands, online, offline"
    read -p "   Context: " context
    
    # Track context usage for preferences learning
    if [[ -n "$context" ]] && command -v gtd-preferences-learn &>/dev/null; then
      gtd-preferences-learn track-context "$context" 2>/dev/null || true
    fi
    
    # Get energy level
    echo ""
    echo "7. What's the energy level required?"
    echo "   Available: low, medium, high, creative, administrative"
    read -p "   Energy: " energy
    
    # Get priority
    echo ""
    echo "8. What's the priority?"
    echo "   1) Urgent & Important"
    echo "   2) Not Urgent & Important"
    echo "   3) Urgent & Not Important"
    echo "   4) Not Urgent & Not Important"
    read -p "   Priority (1-4): " priority_choice
    
    case "$priority_choice" in
      1) priority="urgent_important" ;;
      2) priority="not_urgent_important" ;;
      3) priority="urgent_not_important" ;;
      4) priority="not_urgent_not_important" ;;
      *) priority="not_urgent_important" ;;
    esac
    
    # Update file
    update_frontmatter_value "$file" "status" "active"
    update_frontmatter_value "$file" "type" "task"
    update_frontmatter_value "$file" "next_action" "$next_action"
    update_frontmatter_value "$file" "context" "$context"
    update_frontmatter_value "$file" "energy" "$energy"
    update_frontmatter_value "$file" "priority" "$priority"
    
    # Move to tasks directory (create if needed)
    TASKS_PATH="${GTD_BASE_DIR}/tasks"
    mkdir -p "$TASKS_PATH"
    mv "$file" "${TASKS_PATH}/"
    
    echo "âœ“ Created task"
    echo "  Next action: $next_action"
    echo "  Context: $context"
    echo "  Energy: $energy"
  fi
}

# Main processing loop
main() {
  local process_all=false
  
  # Parse arguments
  case "$1" in
    --all|-a)
      process_all=true
      ;;
    --help|-h)
      echo "Usage: gtd-process [--all]"
      echo ""
      echo "Process inbox items using GTD methodology."
      echo ""
      echo "Options:"
      echo "  --all, -a    Process all items in inbox"
      echo "  --help, -h   Show this help"
      exit 0
      ;;
  esac
  
  local inbox_count=$(count_inbox_items)
  
  # Send notification if inbox is empty after processing
  if [[ $inbox_count -eq 0 ]]; then
    # Check if notifications are enabled
    if [[ "${GTD_NOTIFICATIONS:-true}" == "true" ]]; then
      "$(dirname "$0")/gtd-notify" "GTD Inbox" "Inbox is empty" "All items processed" "Ping" 2>/dev/null || true
    fi
  fi
  
  if [[ $inbox_count -eq 0 ]]; then
    echo "âœ“ Inbox is empty! Nothing to process."
    exit 0
  fi
  
  echo "ðŸ“¥ Inbox has $inbox_count item(s) to process"
  
  if [[ "$process_all" == "true" ]]; then
    # Process all items
    local items=($(get_inbox_items))
    for item in "${items[@]}"; do
      process_item "$item"
    done
    echo ""
    echo "âœ“ Finished processing all items"
  else
    # Process one item
    local items=($(get_inbox_items))
    if [[ ${#items[@]} -gt 0 ]]; then
      process_item "${items[0]}"
      local remaining=$(count_inbox_items)
      if [[ $remaining -gt 0 ]]; then
        echo ""
        echo "ðŸ“¥ $remaining item(s) remaining in inbox"
        echo "   Run 'gtd-process' again or 'gtd-process --all' to process all"
      fi
    fi
  fi
}

main "$@"



