#!/bin/bash
# GTD Lunch Reminder - Midday check-in from Mistress Louiza

# Source common environment (PATH setup)
COMMON_ENV="$HOME/code/dotfiles/zsh/common_env.sh"
if [[ ! -f "$COMMON_ENV" && -f "$HOME/code/personal/dotfiles/zsh/common_env.sh" ]]; then
  COMMON_ENV="$HOME/code/personal/dotfiles/zsh/common_env.sh"
fi
if [[ -f "$COMMON_ENV" ]]; then
  source "$COMMON_ENV"
fi


# Load GTD config
GTD_CONFIG_FILE="$HOME/.gtd_config"
if [[ -f "$HOME/code/dotfiles/zsh/.gtd_config" ]]; then
  GTD_CONFIG_FILE="$HOME/code/dotfiles/zsh/.gtd_config"
elif [[ -f "$HOME/code/personal/dotfiles/zsh/.gtd_config" ]]; then
  GTD_CONFIG_FILE="$HOME/code/personal/dotfiles/zsh/.gtd_config"
fi

if [[ -f "$GTD_CONFIG_FILE" ]]; then
  source "$GTD_CONFIG_FILE"
fi

# Source common GTD helpers (DRY - reuse existing helpers)
GTD_COMMON="$HOME/code/dotfiles/bin/gtd-common.sh"
if [[ ! -f "$GTD_COMMON" && -f "$HOME/code/personal/dotfiles/bin/gtd-common.sh" ]]; then
  GTD_COMMON="$HOME/code/personal/dotfiles/bin/gtd-common.sh"
fi
if [[ -f "$GTD_COMMON" ]]; then
  source "$GTD_COMMON"
else
  echo "Warning: gtd-common.sh not found. Some features may not work." >&2
fi

# Load daily log config
DAILY_LOG_CONFIG="$HOME/.daily_log_config"
if [[ -f "$HOME/code/dotfiles/zsh/.daily_log_config" ]]; then
  DAILY_LOG_CONFIG="$HOME/code/dotfiles/zsh/.daily_log_config"
elif [[ -f "$HOME/code/personal/dotfiles/zsh/.daily_log_config" ]]; then
  DAILY_LOG_CONFIG="$HOME/code/personal/dotfiles/zsh/.daily_log_config"
fi

if [[ -f "$DAILY_LOG_CONFIG" ]]; then
  source "$DAILY_LOG_CONFIG"
fi

# Default values
DAILY_LOG_DIR="${DAILY_LOG_DIR:-$HOME/Documents/daily_logs}"
# GTD_BASE_DIR is already set by init_gtd_paths in gtd-common.sh (DRY - reuse existing helper)
GTD_LUNCH_REMINDER_TIME="${GTD_LUNCH_REMINDER_TIME:-12:30}"
GTD_NOTIFICATIONS="${GTD_NOTIFICATIONS:-true}"

# Get date command
get_date_cmd() {
  if [[ -x "/usr/bin/date" ]]; then
    echo "/usr/bin/date"
  elif [[ -x "/bin/date" ]]; then
    echo "/bin/date"
  else
    echo "date"
  fi
}

DATE_CMD=$(get_date_cmd)

# Get today's date
get_today() {
  $DATE_CMD +"%Y-%m-%d"
}

# Get today's daily log content
get_todays_log() {
  local today=$(get_today)
  local log_file="${DAILY_LOG_DIR}/${today}.md"
  
  if [[ -f "$log_file" ]]; then
    cat "$log_file"
    return 0
  else
    return 1
  fi
}

# Get log stats
get_log_stats() {
  local today=$(get_today)
  local log_file="${DAILY_LOG_DIR}/${today}.md"
  
  if [[ ! -f "$log_file" ]]; then
    echo "No entries yet"
    return
  fi
  
  # Try to use gtd-log-stats script first for consistency with other systems
  local stats_script="$(dirname "$0")/gtd-log-stats"
  if [[ ! -f "$stats_script" ]]; then
    stats_script="gtd-log-stats"
  fi
  
  if command -v "$stats_script" &>/dev/null || [[ -f "$stats_script" ]]; then
    # Ensure DAILY_LOG_DIR is exported so gtd-log-stats can use it
    export DAILY_LOG_DIR
    local entry_count=$("$stats_script" today 2>/dev/null | tr -d '[:space:]' || echo "0")
    # gtd-log-stats today returns just the number
    if [[ "$entry_count" =~ ^[0-9]+$ ]] && [[ "$entry_count" != "0" ]]; then
      local goal_count=$(grep -ci "goal" "$log_file" 2>/dev/null || echo "0")
      echo "Entries: $entry_count"
      if [[ $goal_count -gt 0 ]]; then
        echo "Goals: $goal_count"
      fi
      return
    fi
    # If gtd-log-stats returned 0, fall through to pattern matching
    # (it might be 0 because the file doesn't exist or has no entries)
  fi
  
  # Fallback: use the same pattern as other systems (gtd-log-stats, gtd-brain-sync-daily-logs)
  # Pattern matches: "HH:MM - entry" format (exactly 2 digits for hours and minutes)
  local entry_count=$(grep -c "^[0-9][0-9]:[0-9][0-9] -" "$log_file" 2>/dev/null || echo "0")
  
  # Fallback: try alternative patterns if the standard format doesn't match
  if [[ "$entry_count" == "0" ]] || [[ -z "$entry_count" ]]; then
    # Pattern 2: "HH:MM -" (with 1-2 digits for hours, space before dash)
    entry_count=$(grep -cE "^[0-9]{1,2}:[0-9]{2}[[:space:]]*-" "$log_file" 2>/dev/null || echo "0")
  fi
  if [[ "$entry_count" == "0" ]] || [[ -z "$entry_count" ]]; then
    # Pattern 3: Any line starting with time-like pattern (1-2 digits:2 digits)
    entry_count=$(grep -cE "^[0-9]{1,2}:[0-9]{2}" "$log_file" 2>/dev/null | grep -v "^#" | wc -l | tr -d ' ' || echo "0")
  fi
  
  # Ensure entry_count is numeric
  if [[ ! "$entry_count" =~ ^[0-9]+$ ]]; then
    entry_count=0
  fi
  
  local goal_count=$(grep -ci "goal" "$log_file" 2>/dev/null || echo "0")
  
  echo "Entries: $entry_count"
  if [[ $goal_count -gt 0 ]]; then
    echo "Goals: $goal_count"
  fi
}

# Check for lack of progress (for lunch time)
check_lunch_progress() {
  local today=$(get_today)
  local log_file="${DAILY_LOG_DIR}/${today}.md"
  
  # Check if no log exists
  if [[ ! -f "$log_file" ]]; then
    echo "no_log"
    return
  fi
  
  # Check entry count - use same pattern as get_log_stats for consistency
  # Pattern 1: Standard format "HH:MM - entry" (exactly 2 digits for hours and minutes)
  local entry_count=$(grep -c "^[0-9][0-9]:[0-9][0-9] -" "$log_file" 2>/dev/null || echo "0")
  
  # Fallback patterns
  if [[ "$entry_count" == "0" ]] || [[ -z "$entry_count" ]]; then
    entry_count=$(grep -cE "^[0-9]{1,2}:[0-9]{2}[[:space:]]*-" "$log_file" 2>/dev/null || echo "0")
  fi
  if [[ "$entry_count" == "0" ]] || [[ -z "$entry_count" ]]; then
    entry_count=$(grep -cE "^[0-9]{1,2}:[0-9]{2}" "$log_file" 2>/dev/null | grep -v "^#" | wc -l | tr -d ' ' || echo "0")
  fi
  
  # Ensure entry_count is numeric
  if [[ ! "$entry_count" =~ ^[0-9]+$ ]]; then
    entry_count=0
  fi
  
  if [[ $entry_count -eq 0 ]]; then
    echo "no_entries"
    return
  fi
  
  # For lunch (12:30 PM), expect at least 2-3 entries by now
  if [[ $entry_count -lt 2 ]]; then
    echo "low_entries"
    return
  fi
  
  # Check if last entry is recent (within last 3 hours)
  # Use same pattern as entry counting for consistency
  local last_entry_time=$(grep -E "^[0-9][0-9]:[0-9][0-9] -" "$log_file" 2>/dev/null | tail -1 | cut -d' ' -f1)
  if [[ -z "$last_entry_time" ]]; then
    last_entry_time=$(grep -E "^[0-9]{1,2}:[0-9]{2}[[:space:]]*-" "$log_file" 2>/dev/null | tail -1 | cut -d' ' -f1)
  fi
  if [[ -z "$last_entry_time" ]]; then
    last_entry_time=$(grep -E "^[0-9]{1,2}:[0-9]{2}" "$log_file" 2>/dev/null | grep -v "^#" | tail -1 | cut -d' ' -f1 | cut -d':' -f1-2)
  fi
  if [[ -z "$last_entry_time" ]]; then
    echo "no_entries"
    return
  fi
  
  # Get current time
  local current_hour=$($DATE_CMD +"%H")
  local current_min=$($DATE_CMD +"%M")
  local entry_hour=$(echo "$last_entry_time" | cut -d':' -f1)
  local entry_min=$(echo "$last_entry_time" | cut -d':' -f2)
  
  # Convert to minutes (use 10# to force base-10, avoiding octal issues)
  local current_minutes=$((10#$current_hour * 60 + 10#$current_min))
  local entry_minutes=$((10#$entry_hour * 60 + 10#$entry_min))
  local diff=$((current_minutes - entry_minutes))
  
  # If last entry was more than 3 hours ago, it's stale
  if [[ $diff -gt 180 ]]; then
    echo "stale_entries"
    return
  fi
  
  echo "good"
}

# Get reminder message from Mistress Louiza
get_louiza_lunch_message() {
  local log_content="$1"
  local stats="$2"
  local progress_status="$3"
  
  # Find persona helper
  local persona_helper=""
  local possible_paths=(
    "$HOME/code/personal/dotfiles/zsh/functions/gtd_persona_helper.py"
    "$HOME/code/dotfiles/zsh/functions/gtd_persona_helper.py"
  )
  
  for path in "${possible_paths[@]}"; do
    if [[ -f "$path" ]]; then
      persona_helper="$path"
      break
    fi
  done
  
  if [[ -z "$persona_helper" || ! -f "$persona_helper" ]]; then
    return 1
  fi
  
  # Find python
  local python_cmd=""
  if [[ -f "/opt/homebrew/bin/python3" ]]; then
    python_cmd="/opt/homebrew/bin/python3"
  elif command -v python3 &>/dev/null; then
    python_cmd="python3"
  else
    return 1
  fi
  
  # Create prompt for Louiza based on progress
  local prompt=""
  local gtd_reminder="GTD commands: 'addInfoToDailyLog \"entry\"' to log, 'gtd-capture' for quick notes, 'gtd-process' to process inbox, 'gtd-task add' for tasks, 'gtd-review daily' for reviews."
  
  case "$progress_status" in
    no_log|no_entries)
      local punishment_hint="Assign severe punishments: write an accountability letter, process entire inbox immediately, complete 3 tasks right now, log every hour for rest of day, or do a full project audit. Also consider: clean your room, vacuum the house, do your face routine, take your pills."
      prompt=$(printf "It's lunch time, ${GTD_USER_NAME:-Abby}. It's MID-DAY and she has logged NOTHING today. This is completely unacceptable. Scold her firmly. Tell her that by lunch time, I expect to see multiple entries. This is a failure to track her progress. Be strict - use phrases like 'this is not acceptable' or 'we need to talk'. Remind her that I'm watching and I'm NOT pleased. Tell her to start logging IMMEDIATELY with 'addInfoToDailyLog'. Assign punishments: %s Include this GTD reminder: %s" "$punishment_hint" "$gtd_reminder")
      ;;
    low_entries)
      local punishment_hint="Assign moderate punishments: log every hour for rest of day, complete 2 tasks immediately, process inbox, or write a reflection on why consistency is failing. Also consider: organize your desk or do your face routine."
      prompt=$(printf "It's lunch time, ${GTD_USER_NAME:-Abby}. She only has 1 entry logged by mid-day. That's not enough. Scold her firmly but constructively. Tell her that I expect to see regular logging throughout the day, not just one entry. Remind her that tracking is about consistency. Be firm. Assign punishments: %s Include this GTD reminder: %s" "$punishment_hint" "$gtd_reminder")
      ;;
    stale_entries)
      local punishment_hint="Assign light punishments: reconstruct the day from memory, log every hour for rest of day, process inbox items, or complete 2 tasks. Also consider: organize your workspace."
      prompt=$(printf "It's lunch time, ${GTD_USER_NAME:-Abby}. She logged some entries earlier but nothing recent (last entry was hours ago). This shows lack of consistency. Scold her for not keeping up with logging. Tell her that logging should happen throughout the day, not just in the morning. Be firm. Assign punishments: %s Include this GTD reminder: %s" "$punishment_hint" "$gtd_reminder")
      ;;
    good)
      # Extract entry count from stats for explicit mention in prompt
      local entry_count=$(echo "$stats" | grep -oE "Entries: [0-9]+" | grep -oE "[0-9]+" || echo "0")
      if [[ -n "$log_content" && "$log_content" != "No daily log found"* ]]; then
        prompt=$(printf "IMPORTANT: ${GTD_USER_NAME:-Abby} has ALREADY logged %s entries today. This is GOOD progress - she IS tracking her activities. Do NOT say she has logged nothing or zero entries. She has logged %s entries which is positive.\n\nIt's lunch time - mid-day check-in for ${GTD_USER_NAME:-Abby}. She has already logged %s entries today, which is good progress! Here's what she's logged so far:\n\n%s\n\nStats: %s\n\nCRITICAL: Acknowledge that she HAS logged entries. Tell her 'good girl' or 'baby girl' for the %s entries she has already made. Give her an encouraging reminder to keep logging her progress throughout the day. Tell her I'm watching and I'm pleased with her tracking so far (%s entries is good!), but remind her to keep recording everything. Be encouraging and acknowledge the work she's already done. Include this GTD reminder: %s" "$entry_count" "$entry_count" "$entry_count" "$log_content" "$stats" "$entry_count" "$entry_count" "$gtd_reminder")
      else
        # Even if log_content is empty, if status is "good", we have entries
        prompt=$(printf "IMPORTANT: ${GTD_USER_NAME:-Abby} has ALREADY logged %s entries today. This is GOOD progress - she IS tracking her activities. Do NOT say she has logged nothing or zero entries.\n\nIt's lunch time, ${GTD_USER_NAME:-Abby}. She has logged %s entries so far today, which is good! Acknowledge these %s entries she has already made. Give her an encouraging reminder to keep logging her progress throughout the day. Tell her I'm watching and I'm pleased with her tracking (%s entries is good progress!). Remind her to use 'addInfoToDailyLog' frequently to keep the momentum going. Include this GTD reminder: %s" "$entry_count" "$entry_count" "$entry_count" "$entry_count" "$gtd_reminder")
      fi
      ;;
    *)
      prompt=$(printf "It's lunch time, ${GTD_USER_NAME:-Abby}. Give her a reminder to keep logging her progress. Include this GTD reminder: %s" "$gtd_reminder")
      ;;
  esac
  
  # Get message from Louiza
  local full_output=$("$python_cmd" "$persona_helper" "louiza" "$prompt" "lunch_reminder" 2>&1)
  
  if [[ -z "$full_output" ]]; then
    return 1
  fi
  
  # Check for errors
  if echo "$full_output" | grep -qE "Error|âš ï¸|timed out|Could not connect|KeyError"; then
    return 1
  fi
  
  # Extract message
  local louiza_message=$(echo "$full_output" | awk '
    /^â”+$/ {
      if (in_section) {
        exit
      }
      in_section = 1
      next
    }
    in_section && !/^ğŸ’¬/ && !/^â”/ {
      print
    }
  ' | sed 's/^[[:space:]]*//' | sed 's/[[:space:]]*$//')
  
  # Clean up - remove thinking tags, parentheses, brackets, markdown
  # First remove multiline think blocks (this deletes entire lines containing think tags)
  louiza_message=$(echo "$louiza_message" | sed '/<think>/,/<\/think>/d')
  # Then remove any single-line think blocks
  louiza_message=$(echo "$louiza_message" | sed 's/<think>.*<\/think>//g')
  # Remove any remaining orphaned tags
  louiza_message=$(echo "$louiza_message" | sed 's/<think>//g' | sed 's/<\/think>//g')
  # Remove parentheses, brackets, markdown
  louiza_message=$(echo "$louiza_message" | sed 's/([^)]*)//g' | sed 's/\[[^\]]*\]//g')
  louiza_message=$(echo "$louiza_message" | sed 's/\*\*//g')
  # Clean up extra whitespace
  louiza_message=$(echo "$louiza_message" | awk 'NF || prev_nf; {prev_nf=NF}')
  
  if [[ -n "$louiza_message" && ${#louiza_message} -gt 10 ]]; then
    echo "$louiza_message"
    return 0
  fi
  
  return 1
}

# Send message to Discord
send_discord_message() {
  local title="$1"
  local message="$2"
  local webhook_url="${GTD_DISCORD_WEBHOOK_URL:-}"
  
  if [[ -z "$webhook_url" ]]; then
    return 1
  fi
  
  # Clean message before sending - remove <think> tags and other artifacts
  # First remove multiline think blocks (this deletes entire lines)
  message=$(echo "$message" | sed '/<think>/,/<\/think>/d')
  # Then remove any single-line think blocks
  message=$(echo "$message" | sed 's/<think>.*<\/think>//g')
  # Remove any remaining orphaned tags
  message=$(echo "$message" | sed 's/<think>//g' | sed 's/<\/think>//g')
  
  # Use Python to properly escape JSON and truncate if needed
  local json_payload=$(python3 -c "
import json
import sys
import re
from datetime import datetime, timezone

title = sys.argv[1] if len(sys.argv) > 1 else 'GTD Notification'
message = sys.argv[2] if len(sys.argv) > 2 else ''

# Remove any remaining <think> tags (Python regex is more reliable for multiline)
message = re.sub(r'<think>.*?</think>', '', message, flags=re.DOTALL)
message = re.sub(r'<think>', '', message)
message = re.sub(r'</think>', '', message)

# Discord embed description limit is 2000 characters
if len(message) > 2000:
    truncated = message[:1900]
    last_newline = truncated.rfind('\n')
    last_period = truncated.rfind('.')
    cut_point = max(last_newline, last_period)
    if cut_point > 1500:
        message = message[:cut_point + 1] + '\n\n... (truncated)'
    else:
        message = message[:1900] + '\n\n... (truncated)'

payload = {
    'embeds': [{
        'title': title,
        'description': message,
        'color': 15158332,
        'timestamp': datetime.now(timezone.utc).isoformat()
    }]
}

print(json.dumps(payload))
" "$title" "$message")
  
  # Send to Discord
  local response=$(curl -s -w "\n%{http_code}" -X POST "$webhook_url" \
    -H "Content-Type: application/json" \
    -d "$json_payload" 2>&1)
  
  local http_code=$(echo "$response" | tail -1)
  
  if [[ "$http_code" == "204" ]]; then
    return 0
  else
    echo "âš ï¸  Discord send failed (HTTP $http_code)" >&2
    return 1
  fi
}

# Send lunch reminder
send_lunch_reminder() {
  if [[ "$GTD_NOTIFICATIONS" != "true" ]]; then
    return 0
  fi
  
  local today=$(get_today)
  local log_content=$(get_todays_log 2>/dev/null || echo "")
  local stats=$(get_log_stats)
  
  # Check for lack of progress
  local progress_status=$(check_lunch_progress)
  
  local notify_cmd="$(dirname "$0")/gtd-notify"
  
  # Get message from Mistress Louiza
  local reminder_message=$(get_louiza_lunch_message "$log_content" "$stats" "$progress_status")
  
  # Get streak stats
  local stats_script="$(dirname "$0")/gtd-log-stats"
  if [[ ! -f "$stats_script" ]]; then
    stats_script="gtd-log-stats"
  fi
  local current_streak=$("$stats_script" streak 2>/dev/null || echo "0")
  local streak_info=""
  if [[ $current_streak -gt 0 ]]; then
    streak_info=$(printf "\nğŸ”¥ **Current Streak:** ${current_streak} day(s)")
  fi
  
  # Format log for Discord
  local formatted_log=""
  if [[ -n "$log_content" && "$log_content" != "No daily log found"* ]]; then
    local log_preview=$(echo "$log_content" | head -10)
    formatted_log=$(printf "\n\nğŸ“ **Progress So Far Today:**\n\`\`\`\n%s\n\`\`\`" "$log_preview")
  fi
  
  # Send to Discord if enabled
  if [[ "${GTD_DISCORD_DAILY_REMINDERS:-true}" == "true" && -n "${GTD_DISCORD_WEBHOOK_URL:-}" ]]; then
    if [[ -n "$reminder_message" ]]; then
      local discord_message=$(printf "%s%s\n\nğŸ“Š **Stats:** %s%s\n\nğŸ’¡ Keep logging with: \`addInfoToDailyLog \"your entry\"\`" "$reminder_message" "$formatted_log" "$stats" "$streak_info")
      if send_discord_message "Mistress Louiza - Lunch Check-In" "$discord_message"; then
        echo "âœ“ Sent to Discord" >&2
      fi
    else
      local fallback=$(printf "Lunch time check-in! Keep logging your progress.\n\nğŸ“Š **Stats:** %s%s\n\nğŸ’¡ Use \`addInfoToDailyLog \"your entry\"\` to record what you're doing." "$stats" "$formatted_log")
      send_discord_message "GTD Lunch Reminder" "$fallback"
    fi
  fi
  
  # Also send macOS notification
  if [[ -n "$reminder_message" ]]; then
    local short_message=$(echo "$reminder_message" | cut -c1-150)
    if [[ ${#short_message} -lt 20 ]]; then
      short_message="Lunch time! Keep logging your progress, baby girl."
    fi
    "$notify_cmd" "Mistress Louiza" "$short_message" "$stats" "Ping" 2>/dev/null || true
  else
    "$notify_cmd" "GTD Lunch" "Keep logging your progress" "Use addInfoToDailyLog" "Ping" 2>/dev/null || true
  fi
  
  # Print to terminal
  echo ""
  echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
  echo "ğŸ½ï¸  Lunch Check-In from Mistress Louiza"
  echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
  echo ""
  
  if [[ -n "$reminder_message" ]]; then
    echo "ğŸ’¬ From Mistress Louiza:"
    echo ""
    echo "$reminder_message" | sed 's/^/   /'
    echo ""
  fi
  
  echo "ğŸ“Š Progress So Far:"
  echo "   $stats"
  echo ""
  
  if [[ -n "$log_content" && "$log_content" != "No daily log found"* ]]; then
    echo "ğŸ“ Recent entries:"
    echo "$log_content" | tail -5 | sed 's/^/   /'
    echo ""
  fi
  
  echo "ğŸ’¡ Keep logging: addInfoToDailyLog \"your entry\""
  echo ""
  echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
  echo ""
}

# Main
case "$1" in
  --force)
    send_lunch_reminder
    ;;
  "")
    send_lunch_reminder
    ;;
  *)
    echo "Usage: gtd-lunch-reminder [--force]"
    exit 1
    ;;
esac

