#!/bin/bash
# GTD Learning System Preferences
# Tracks user behavior and learns preferences to adapt the system

# Source common environment
COMMON_ENV="$HOME/code/dotfiles/zsh/common_env.sh"
if [[ ! -f "$COMMON_ENV" && -f "$HOME/code/personal/dotfiles/zsh/common_env.sh" ]]; then
  COMMON_ENV="$HOME/code/personal/dotfiles/zsh/common_env.sh"
fi
if [[ -f "$COMMON_ENV" ]]; then
  source "$COMMON_ENV"
fi

# Load GTD config
GTD_CONFIG_FILE="$HOME/.gtd_config"
if [[ -f "$HOME/code/dotfiles/zsh/.gtd_config" ]]; then
  GTD_CONFIG_FILE="$HOME/code/dotfiles/zsh/.gtd_config"
elif [[ -f "$HOME/code/personal/dotfiles/zsh/.gtd_config" ]]; then
  GTD_CONFIG_FILE="$HOME/code/personal/dotfiles/zsh/.gtd_config"
fi

if [[ -f "$GTD_CONFIG_FILE" ]]; then
  source "$GTD_CONFIG_FILE"
fi

# Source common GTD helpers (DRY - reuse existing helpers)
GTD_COMMON="$HOME/code/dotfiles/bin/gtd-common.sh"
if [[ ! -f "$GTD_COMMON" && -f "$HOME/code/personal/dotfiles/bin/gtd-common.sh" ]]; then
  GTD_COMMON="$HOME/code/personal/dotfiles/bin/gtd-common.sh"
fi
if [[ -f "$GTD_COMMON" ]]; then
  source "$GTD_COMMON"
else
  echo "Warning: gtd-common.sh not found. Some features may not work." >&2
fi

# Default values
# GTD_BASE_DIR is already set by init_gtd_paths in gtd-common.sh (DRY - reuse existing helper)
PREFERENCES_FILE="$HOME/.gtd_preferences.json"
PREFERENCES_CONFIG="$HOME/.gtd_preferences_config"

# Colors
CYAN='\033[0;36m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BOLD='\033[1m'
NC='\033[0m'

# Initialize preferences file
init_preferences() {
  if [[ ! -f "$PREFERENCES_FILE" ]]; then
    python3 <<EOF
import json
from datetime import datetime

prefs = {
    "created": datetime.now().isoformat(),
    "last_updated": datetime.now().isoformat(),
    "contexts": {
        "usage": {},  # context -> count
        "preferences": {}  # context -> preference_score (0-1)
    },
    "priorities": {
        "calibration": {},  # Learn what user considers urgent/important
        "usage_patterns": {}  # priority -> count, avg_completion_time
    },
    "writing_style": {
        "task_titles": [],  # Examples of user's task titles
        "note_styles": [],  # Examples of note writing
        "preferred_format": "unknown"
    },
    "review_timing": {
        "daily": {
            "scheduled": None,
            "actual_times": [],  # When reviews actually happen
            "average_time": None
        },
        "weekly": {
            "scheduled_day": None,
            "scheduled_time": None,
            "actual_times": [],
            "average_day": None,
            "average_time": None
        },
        "monthly": {
            "actual_times": []
        }
    },
    "feature_usage": {
        "commands": {},  # command -> usage_count, last_used
        "wizard_options": {},  # option -> usage_count
        "suggestions": {
            "accepted": 0,
            "dismissed": 0,
            "accepted_types": {},  # suggestion_type -> count
            "dismissed_types": {}
        }
    },
    "manual_overrides": {}  # User-set preferences that override learning
}

with open("$PREFERENCES_FILE", 'w') as f:
    json.dump(prefs, f, indent=2)
EOF
    echo "‚úì Initialized preferences file: $PREFERENCES_FILE"
  fi
}

# Track context usage
track_context_usage() {
  local context="$1"
  
  if [[ -z "$context" ]]; then
    echo "‚ùå Context required"
    return 1
  fi
  
  python3 <<EOF
import json
from datetime import datetime
from pathlib import Path

prefs_file = Path("$PREFERENCES_FILE")
if not prefs_file.exists():
    print("ERROR: Preferences file not initialized. Run 'gtd-preferences-learn init' first.")
    exit(1)

with open(prefs_file) as f:
    prefs = json.load(f)

context = "$context"

# Track usage
if context not in prefs["contexts"]["usage"]:
    prefs["contexts"]["usage"][context] = 0
prefs["contexts"]["usage"][context] += 1

# Update preference score (simple: usage frequency)
total_usage = sum(prefs["contexts"]["usage"].values())
if total_usage > 0:
    prefs["contexts"]["preferences"][context] = prefs["contexts"]["usage"][context] / total_usage

prefs["last_updated"] = datetime.now().isoformat()

with open(prefs_file, 'w') as f:
    json.dump(prefs, f, indent=2)
EOF
}

# Track priority calibration
track_priority_usage() {
  local priority="$1"
  local task_title="$2"
  
  python3 <<EOF
import json
from datetime import datetime
from pathlib import Path

prefs_file = Path("$PREFERENCES_FILE")
if not prefs_file.exists():
    exit(0)  # Silently skip if not initialized

with open(prefs_file) as f:
    prefs = json.load(f)

priority = "$priority"
task_title = "$2"

# Track usage
if priority not in prefs["priorities"]["usage_patterns"]:
    prefs["priorities"]["usage_patterns"][priority] = {
        "count": 0,
        "tasks": []
    }
prefs["priorities"]["usage_patterns"][priority]["count"] += 1

# Store example tasks for calibration
if task_title and len(prefs["priorities"]["usage_patterns"][priority]["tasks"]) < 10:
    prefs["priorities"]["usage_patterns"][priority]["tasks"].append(task_title)

prefs["last_updated"] = datetime.now().isoformat()

with open(prefs_file, 'w') as f:
    json.dump(prefs, f, indent=2)
EOF
}

# Track review timing
track_review_timing() {
  local review_type="$1"  # daily, weekly, monthly
  
  if [[ -z "$review_type" ]]; then
    echo "‚ùå Review type required"
    return 1
  fi
  
  python3 <<EOF
import json
from datetime import datetime
from pathlib import Path

prefs_file = Path("$PREFERENCES_FILE")
if not prefs_file.exists():
    exit(0)  # Silently skip if not initialized

with open(prefs_file) as f:
    prefs = json.load(f)

review_type = "$review_type"
now = datetime.now()

if review_type == "daily":
    hour = now.hour
    minute = now.minute
    time_str = f"{hour:02d}:{minute:02d}"
    prefs["review_timing"]["daily"]["actual_times"].append(time_str)
    
    # Keep last 30 days
    if len(prefs["review_timing"]["daily"]["actual_times"]) > 30:
        prefs["review_timing"]["daily"]["actual_times"] = prefs["review_timing"]["daily"]["actual_times"][-30:]
    
    # Calculate average time
    if prefs["review_timing"]["daily"]["actual_times"]:
        times = prefs["review_timing"]["daily"]["actual_times"]
        total_minutes = sum(int(t.split(':')[0]) * 60 + int(t.split(':')[1]) for t in times)
        avg_minutes = total_minutes // len(times)
        avg_hour = avg_minutes // 60
        avg_min = avg_minutes % 60
        prefs["review_timing"]["daily"]["average_time"] = f"{avg_hour:02d}:{avg_min:02d}"

elif review_type == "weekly":
    day_of_week = now.strftime("%A")  # Monday, Tuesday, etc.
    hour = now.hour
    minute = now.minute
    time_str = f"{day_of_week} {hour:02d}:{minute:02d}"
    prefs["review_timing"]["weekly"]["actual_times"].append(time_str)
    
    # Keep last 12 weeks
    if len(prefs["review_timing"]["weekly"]["actual_times"]) > 12:
        prefs["review_timing"]["weekly"]["actual_times"] = prefs["review_timing"]["weekly"]["actual_times"][-12:]

elif review_type == "monthly":
    prefs["review_timing"]["monthly"]["actual_times"].append(now.isoformat())

prefs["last_updated"] = datetime.now().isoformat()

with open(prefs_file, 'w') as f:
    json.dump(prefs, f, indent=2)
EOF
}

# Track feature usage
track_feature_usage() {
  local feature_type="$1"  # command, wizard_option, suggestion
  local feature_name="$2"
  local action="${3:-used}"  # used, accepted, dismissed
  
  python3 <<EOF
import json
from datetime import datetime
from pathlib import Path

prefs_file = Path("$PREFERENCES_FILE")
if not prefs_file.exists():
    exit(0)  # Silently skip if not initialized

with open(prefs_file) as f:
    prefs = json.load(f)

feature_type = "$feature_type"
feature_name = "$feature_name"
action = "$action"

now = datetime.now().isoformat()

if feature_type == "command":
    if feature_name not in prefs["feature_usage"]["commands"]:
        prefs["feature_usage"]["commands"][feature_name] = {
            "usage_count": 0,
            "last_used": None
        }
    prefs["feature_usage"]["commands"][feature_name]["usage_count"] += 1
    prefs["feature_usage"]["commands"][feature_name]["last_used"] = now

elif feature_type == "wizard_option":
    if feature_name not in prefs["feature_usage"]["wizard_options"]:
        prefs["feature_usage"]["wizard_options"][feature_name] = 0
    prefs["feature_usage"]["wizard_options"][feature_name] += 1

elif feature_type == "suggestion":
    if action == "accepted":
        prefs["feature_usage"]["suggestions"]["accepted"] += 1
        # Track by type if provided
        if feature_name:
            if feature_name not in prefs["feature_usage"]["suggestions"]["accepted_types"]:
                prefs["feature_usage"]["suggestions"]["accepted_types"][feature_name] = 0
            prefs["feature_usage"]["suggestions"]["accepted_types"][feature_name] += 1
    elif action == "dismissed":
        prefs["feature_usage"]["suggestions"]["dismissed"] += 1
        if feature_name:
            if feature_name not in prefs["feature_usage"]["suggestions"]["dismissed_types"]:
                prefs["feature_usage"]["suggestions"]["dismissed_types"][feature_name] = 0
            prefs["feature_usage"]["suggestions"]["dismissed_types"][feature_name] += 1

prefs["last_updated"] = now

with open(prefs_file, 'w') as f:
    json.dump(prefs, f, indent=2)
EOF
}

# Learn from existing tasks
learn_from_tasks() {
  echo "üìö Learning from existing tasks..."
  
  python3 <<EOF
import json
import re
from pathlib import Path
from datetime import datetime
from collections import Counter

prefs_file = Path("$PREFERENCES_FILE")
tasks_dir = Path("$GTD_BASE_DIR") / "tasks"

if not prefs_file.exists():
    print("ERROR: Preferences file not initialized")
    exit(1)

with open(prefs_file) as f:
    prefs = json.load(f)

# Learn contexts from tasks
context_usage = Counter()
priority_usage = Counter()
task_titles = []

if tasks_dir.exists():
    for task_file in tasks_dir.glob("*.md"):
        try:
            with open(task_file, 'r') as f:
                content = f.read()
                
            # Extract context
            context_match = re.search(r'^context:\s*(.+)$', content, re.MULTILINE)
            if context_match:
                context = context_match.group(1).strip()
                context_usage[context] += 1
                
            # Extract priority
            priority_match = re.search(r'^priority:\s*(.+)$', content, re.MULTILINE)
            if priority_match:
                priority = priority_match.group(1).strip()
                priority_usage[priority] += 1
                
            # Extract title (first line after frontmatter or first heading)
            title_match = re.search(r'^#\s+(.+)$', content, re.MULTILINE)
            if title_match:
                task_titles.append(title_match.group(1).strip())
                
        except:
            continue

# Update preferences
for context, count in context_usage.items():
    if context not in prefs["contexts"]["usage"]:
        prefs["contexts"]["usage"][context] = 0
    prefs["contexts"]["usage"][context] += count

# Recalculate preference scores
total_context_usage = sum(prefs["contexts"]["usage"].values())
if total_context_usage > 0:
    for context in prefs["contexts"]["usage"]:
        prefs["contexts"]["preferences"][context] = prefs["contexts"]["usage"][context] / total_context_usage

# Update priority usage
for priority, count in priority_usage.items():
    if priority not in prefs["priorities"]["usage_patterns"]:
        prefs["priorities"]["usage_patterns"][priority] = {"count": 0, "tasks": []}
    prefs["priorities"]["usage_patterns"][priority]["count"] += count

# Store task title examples
prefs["writing_style"]["task_titles"] = task_titles[:20]  # Keep last 20

prefs["last_updated"] = datetime.now().isoformat()

with open(prefs_file, 'w') as f:
    json.dump(prefs, f, indent=2)

print(f"‚úì Learned from {len(task_titles)} tasks")
print(f"  - Contexts: {len(context_usage)} unique contexts")
print(f"  - Priorities: {len(priority_usage)} priority levels")
EOF
}

# Get learned preferences
get_preferences() {
  local preference_type="$1"
  
  python3 <<EOF
import json
from pathlib import Path

prefs_file = Path("$PREFERENCES_FILE")
if not prefs_file.exists():
    print("{}")
    exit(0)

with open(prefs_file) as f:
    prefs = json.load(f)

preference_type = "$preference_type"

if preference_type == "contexts":
    # Return preferred contexts sorted by preference score
    contexts = prefs.get("contexts", {}).get("preferences", {})
    sorted_contexts = sorted(contexts.items(), key=lambda x: x[1], reverse=True)
    result = {ctx: score for ctx, score in sorted_contexts[:5]}
    import json
    print(json.dumps(result))
elif preference_type == "priorities":
    # Return priority calibration
    print(json.dumps(prefs.get("priorities", {}).get("usage_patterns", {})))
elif preference_type == "review_timing":
    print(json.dumps(prefs.get("review_timing", {})))
elif preference_type == "feature_usage":
    print(json.dumps(prefs.get("feature_usage", {})))
else:
    print(json.dumps(prefs))
EOF
}

# Show preferences summary
show_preferences() {
  echo ""
  echo -e "${BOLD}${CYAN}üìö Learned Preferences${NC}"
  echo -e "${CYAN}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${NC}"
  echo ""
  
  python3 <<EOF
import json
from pathlib import Path
from datetime import datetime

prefs_file = Path("$PREFERENCES_FILE")
if not prefs_file.exists():
    print("‚ùå Preferences file not initialized")
    print("Run: gtd-preferences-learn init")
    exit(1)

with open(prefs_file) as f:
    prefs = json.load(f)

print("üéØ Preferred Contexts:")
contexts = prefs.get("contexts", {}).get("preferences", {})
if contexts:
    sorted_contexts = sorted(contexts.items(), key=lambda x: x[1], reverse=True)
    for ctx, score in sorted_contexts[:5]:
        bar = "‚ñà" * int(score * 20)
        print(f"   {ctx:20s} {bar} ({score*100:.0f}%)")
else:
    print("   (No data yet)")
print("")

print("‚ö° Priority Usage:")
priorities = prefs.get("priorities", {}).get("usage_patterns", {})
if priorities:
    for priority, data in sorted(priorities.items(), key=lambda x: x[1].get("count", 0), reverse=True):
        count = data.get("count", 0)
        print(f"   {priority:25s} {count} tasks")
else:
    print("   (No data yet)")
print("")

print("üìÖ Review Timing:")
daily_avg = prefs.get("review_timing", {}).get("daily", {}).get("average_time")
if daily_avg:
    print(f"   Daily reviews: Average time {daily_avg}")
else:
    print("   Daily reviews: (No data yet)")

weekly_times = prefs.get("review_timing", {}).get("weekly", {}).get("actual_times", [])
if weekly_times:
    print(f"   Weekly reviews: {len(weekly_times)} recorded")
else:
    print("   Weekly reviews: (No data yet)")
print("")

print("üîß Feature Usage:")
commands = prefs.get("feature_usage", {}).get("commands", {})
if commands:
    sorted_commands = sorted(commands.items(), key=lambda x: x[1].get("usage_count", 0), reverse=True)
    print("   Top commands:")
    for cmd, data in sorted_commands[:5]:
        count = data.get("usage_count", 0)
        print(f"      {cmd:30s} {count} uses")
else:
    print("   (No data yet)")

suggestions = prefs.get("feature_usage", {}).get("suggestions", {})
if suggestions:
    accepted = suggestions.get("accepted", 0)
    dismissed = suggestions.get("dismissed", 0)
    total = accepted + dismissed
    if total > 0:
        rate = (accepted / total) * 100
        print(f"\n   Suggestion acceptance rate: {accepted}/{total} ({rate:.1f}%)")
print("")

last_updated = prefs.get("last_updated", "Never")
print(f"Last updated: {last_updated}")
EOF
  
  echo ""
}

# Main function
main() {
  case "${1:-show}" in
    init)
      init_preferences
      ;;
    track-context)
      track_context_usage "$2"
      ;;
    track-priority)
      track_priority_usage "$2" "$3"
      ;;
    track-review)
      track_review_timing "$2"
      ;;
    track-feature)
      track_feature_usage "$2" "$3" "$4"
      ;;
    learn)
      learn_from_tasks
      ;;
    get)
      get_preferences "$2"
      ;;
    show|"")
      show_preferences
      ;;
    help|*)
      echo "Usage: gtd-preferences-learn <command> [args]"
      echo ""
      echo "Commands:"
      echo "  init                    - Initialize preferences file"
      echo "  learn                   - Learn from existing tasks"
      echo "  show                    - Show learned preferences (default)"
      echo "  get <type>              - Get preferences as JSON (contexts|priorities|review_timing|feature_usage)"
      echo ""
      echo "Tracking commands (called automatically by system):"
      echo "  track-context <context>         - Track context usage"
      echo "  track-priority <priority> <task> - Track priority usage"
      echo "  track-review <daily|weekly|monthly> - Track review timing"
      echo "  track-feature <type> <name> [action] - Track feature usage"
      echo ""
      echo "Examples:"
      echo "  gtd-preferences-learn init      # Initialize"
      echo "  gtd-preferences-learn learn     # Learn from existing tasks"
      echo "  gtd-preferences-learn show      # Show preferences"
      echo ""
      ;;
  esac
}

main "$@"
