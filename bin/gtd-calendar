#!/bin/bash
# GTD Calendar Integration - Google Calendar (personal) and Office 365 (work)

# Load config
GTD_CONFIG_FILE="$HOME/.gtd_config"
if [[ -f "$HOME/code/dotfiles/zsh/.gtd_config" ]]; then
  GTD_CONFIG_FILE="$HOME/code/dotfiles/zsh/.gtd_config"
elif [[ -f "$HOME/code/personal/dotfiles/zsh/.gtd_config" ]]; then
  GTD_CONFIG_FILE="$HOME/code/personal/dotfiles/zsh/.gtd_config"
fi

if [[ -f "$GTD_CONFIG_FILE" ]]; then
  source "$GTD_CONFIG_FILE"
fi

GTD_BASE_DIR="${GTD_BASE_DIR:-$HOME/Documents/gtd}"
TASKS_PATH="${GTD_BASE_DIR}/tasks"

# Calendar configuration
GOOGLE_CALENDAR="${GTD_GOOGLE_CALENDAR:-}"
OFFICE365_CALENDAR="${GTD_OFFICE365_CALENDAR:-}"
GOOGLE_CALENDAR_NAME="${GTD_GOOGLE_CALENDAR_NAME:-GTD}"
OFFICE365_CALENDAR_NAME="${GTD_OFFICE365_CALENDAR_NAME:-Work}"
PRIMARY_WRITE_CALENDAR="${GTD_PRIMARY_WRITE_CALENDAR:-${GOOGLE_CALENDAR_NAME}}"

# Parse multiple calendars configuration
# Format: "type:calendar_name:display_name" or "type:calendar_name"
parse_calendar_config() {
  local config_entry="$1"
  local part="${config_entry%%:*}"
  local remaining="${config_entry#*:}"
  
  # Check if it's a valid format
  if [[ "$config_entry" != *:* ]]; then
    return 1
  fi
  
  # Extract type (rw or ro)
  local type="$part"
  if [[ "$type" != "rw" && "$type" != "ro" ]]; then
    return 1
  fi
  
  # Extract calendar name and display name
  local calendar_name="${remaining%%:*}"
  local display_name="${remaining#*:}"
  
  # If no display name provided, use calendar name
  if [[ "$display_name" == "$calendar_name" ]]; then
    display_name="$calendar_name"
  fi
  
  echo "$type|$calendar_name|$display_name"
}

# Get list of all configured calendars (for viewing)
get_configured_calendars() {
  declare -a calendars
  
  # If GTD_CALENDARS is set and has entries, use it
  if [[ -n "${GTD_CALENDARS:-}" ]] && [[ ${#GTD_CALENDARS[@]} -gt 0 ]]; then
    for entry in "${GTD_CALENDARS[@]}"; do
      local parsed=$(parse_calendar_config "$entry")
      if [[ -n "$parsed" ]]; then
        calendars+=("$parsed")
      fi
    done
  else
    # Backwards compatibility: use primary calendars
    if [[ -n "$GOOGLE_CALENDAR_NAME" ]]; then
      calendars+=("rw|$GOOGLE_CALENDAR_NAME|$GOOGLE_CALENDAR_NAME")
    fi
    if [[ -n "$OFFICE365_CALENDAR_NAME" ]] && [[ -n "${GTD_OFFICE365_CLIENT_ID:-}" ]]; then
      calendars+=("rw|$OFFICE365_CALENDAR_NAME|$OFFICE365_CALENDAR_NAME")
    fi
  fi
  
  # Print each calendar on a new line
  for cal in "${calendars[@]}"; do
    echo "$cal"
  done
}

# Get list of read-write calendars (calendars that can be written to)
get_write_calendars() {
  declare -a write_calendars
  
  if [[ -n "${GTD_CALENDARS:-}" ]] && [[ ${#GTD_CALENDARS[@]} -gt 0 ]]; then
    for entry in "${GTD_CALENDARS[@]}"; do
      local parsed=$(parse_calendar_config "$entry")
      if [[ -n "$parsed" ]]; then
        local type="${parsed%%|*}"
        if [[ "$type" == "rw" ]]; then
          write_calendars+=("$parsed")
        fi
      fi
    done
  else
    # Backwards compatibility: use primary calendars as write calendars
    if [[ -n "$GOOGLE_CALENDAR_NAME" ]]; then
      write_calendars+=("rw|$GOOGLE_CALENDAR_NAME|$GOOGLE_CALENDAR_NAME")
    fi
  fi
  
  # Print each calendar on a new line
  for cal in "${write_calendars[@]}"; do
    echo "$cal"
  done
}

# Check if a calendar is writable
is_calendar_writable() {
  local calendar_name="$1"
  local write_cals
  write_cals=$(get_write_calendars)
  
  while IFS= read -r cal_entry; do
    if [[ -z "$cal_entry" ]]; then
      continue
    fi
    local cal_name="${cal_entry#*|}"
    cal_name="${cal_name%%|*}"
    if [[ "$cal_name" == "$calendar_name" ]]; then
      return 0
    fi
  done <<< "$write_cals"
  
  return 1
}

# Get date command
get_date_cmd() {
  if [[ -x "/usr/bin/date" ]]; then
    echo "/usr/bin/date"
  elif [[ -x "/bin/date" ]]; then
    echo "/bin/date"
  else
    echo "date"
  fi
}

DATE_CMD=$(get_date_cmd)

# Check if gcalcli is installed
check_gcalcli() {
  if command -v gcalcli &>/dev/null; then
    return 0
  else
    echo "Error: gcalcli not found. Install with: brew install gcalcli"
    return 1
  fi
}

# Convert to lowercase (bash 3+ compatible)
to_lowercase() {
  echo "$1" | tr '[:upper:]' '[:lower:]'
}

# Parse relative dates and convert to absolute dates or gcalcli-friendly format
parse_relative_date() {
  local date_input="$1"
  
  # Convert to lowercase for comparison (bash 3+ compatible)
  local lower_input=$(to_lowercase "$date_input")
  
  # Handle common typos and variations first
  case "$lower_input" in
    ""|"toda"|"tod"|"tday"|"todya")
      echo "today"
      return 0
      ;;
    "tomoro"|"tomorr"|"tomorow"|"tomrrow")
      echo "tomorrow"
      return 0
      ;;
  esac
  
  # Handle relative dates like "2 weeks from now", "next week", etc.
  local days_offset=0
  
  # Check for "X weeks/days/months from now" or "in X weeks/days"
  if echo "$lower_input" | grep -qiE "[0-9]"; then
    # Extract number
    local number=$(echo "$lower_input" | grep -oE "[0-9]+" | head -1)
    
    if [[ -n "$number" ]]; then
      # Determine unit (week, day, month)
      if echo "$lower_input" | grep -qiE "\bweek"; then
        days_offset=$((number * 7))
      elif echo "$lower_input" | grep -qiE "\bmonth"; then
        days_offset=$((number * 30))  # Approximate
      elif echo "$lower_input" | grep -qiE "\bday"; then
        days_offset=$number
      else
        # If no unit specified, assume days
        days_offset=$number
      fi
    fi
  elif echo "$lower_input" | grep -qiE "next week"; then
    days_offset=7
  elif echo "$lower_input" | grep -qiE "next month"; then
    days_offset=30
  fi
  
  # Calculate the date if we found an offset
  if [[ $days_offset -gt 0 ]]; then
    if [[ "$(uname)" == "Darwin" ]]; then
      # macOS date command
      local calculated_date
      calculated_date=$($DATE_CMD -v+${days_offset}d +"%Y-%m-%d" 2>/dev/null)
      if [[ -n "$calculated_date" ]]; then
        echo "$calculated_date"
        return 0
      fi
    else
      # Linux date command
      local calculated_date
      calculated_date=$($DATE_CMD -d "+${days_offset} days" +"%Y-%m-%d" 2>/dev/null)
      if [[ -n "$calculated_date" ]]; then
        echo "$calculated_date"
        return 0
      fi
    fi
  fi
  
  # If we calculated a date offset, we already returned it above
  # If we get here, we didn't find a relative date pattern
  
  # Try common date formats that gcalcli accepts
  # Check if it's already in a format gcalcli likes
  if echo "$date_input" | grep -qiE "(today|tomorrow|yesterday|now|monday|tuesday|wednesday|thursday|friday|saturday|sunday|[0-9]{4}-[0-9]{2}-[0-9]{2})"; then
    echo "$date_input"
    return 0
  fi
  
  # If we can't parse it, return as-is and let gcalcli try
  echo "$date_input"
}

# Normalize date input (handle typos and common variations)
normalize_date() {
  local date_input="$1"
  
  # Handle empty input
  if [[ -z "$date_input" ]]; then
    echo "today"
    return 0
  fi
  
  # Try to parse as relative date first
  parse_relative_date "$date_input"
}

# Convert date to YYYY-MM-DD format for comparison
normalize_to_ymd() {
  local date_str="$1"
  
  # Handle special cases
  if [[ "$date_str" == "today" ]]; then
    date +"%Y-%m-%d" 2>/dev/null || echo ""
    return 0
  elif [[ "$date_str" == "tomorrow" ]]; then
    if [[ "$(uname)" == "Darwin" ]]; then
      date -v+1d +"%Y-%m-%d" 2>/dev/null || echo ""
    else
      date -d "+1 day" +"%Y-%m-%d" 2>/dev/null || echo ""
    fi
    return 0
  fi
  
  # If already in YYYY-MM-DD format, return as-is
  if echo "$date_str" | grep -qE "^[0-9]{4}-[0-9]{2}-[0-9]{2}$"; then
    echo "$date_str"
    return 0
  fi
  
  # Try to parse other formats
  if [[ "$(uname)" == "Darwin" ]]; then
    # Try common date formats on macOS
    date -j -f "%Y-%m-%d" "$date_str" +"%Y-%m-%d" 2>/dev/null || echo "$date_str"
  else
    date -d "$date_str" +"%Y-%m-%d" 2>/dev/null || echo "$date_str"
  fi
}

# Convert date string to Unix timestamp (seconds since epoch)
date_to_timestamp() {
  local date_str="$1"
  
  # Handle special cases
  if [[ "$date_str" == "today" ]]; then
    date +%s 2>/dev/null || echo "0"
    return 0
  elif [[ "$date_str" == "tomorrow" ]]; then
    if [[ "$(uname)" == "Darwin" ]]; then
      date -v+1d +%s 2>/dev/null || echo "0"
    else
      date -d "+1 day" +%s 2>/dev/null || echo "0"
    fi
    return 0
  fi
  
  # If already in YYYY-MM-DD format, convert to timestamp
  if echo "$date_str" | grep -qE "^[0-9]{4}-[0-9]{2}-[0-9]{2}$"; then
    if [[ "$(uname)" == "Darwin" ]]; then
      # macOS: use -j to parse the date, then convert to timestamp
      date -j -f "%Y-%m-%d" "$date_str" +%s 2>/dev/null || echo "0"
    else
      # Linux: use -d to parse the date, then convert to timestamp
      date -d "$date_str" +%s 2>/dev/null || echo "0"
    fi
    return 0
  fi
  
  # Try to parse other formats and convert to timestamp
  if [[ "$(uname)" == "Darwin" ]]; then
    date -j -f "%Y-%m-%d" "$date_str" +%s 2>/dev/null || echo "0"
  else
    date -d "$date_str" +%s 2>/dev/null || echo "0"
  fi
}

# Filter gcalcli output by date range using Python for reliable date parsing
filter_events_by_date() {
  local events="$1"
  local start_date="$2"
  local end_date="$3"
  
  # Normalize dates to YYYY-MM-DD
  local start_ymd=$(normalize_to_ymd "$start_date")
  local end_ymd=$(normalize_to_ymd "$end_date")
  
  # If we can't normalize, return all events (don't filter)
  if [[ -z "$start_ymd" ]] || [[ -z "$end_ymd" ]]; then
    echo "$events"
    return 0
  fi
  
  # Use Python to filter events (more reliable date parsing)
  # Pass events via stdin to avoid shell escaping issues
  echo "$events" | python3 - "$start_ymd" "$end_ymd" <<'PYTHON_SCRIPT'
import sys
import re
from datetime import datetime

# Get dates from command line args
start_date = sys.argv[1] if len(sys.argv) > 1 else "2024-01-01"
end_date = sys.argv[2] if len(sys.argv) > 2 else "2024-12-31"

try:
    start_dt = datetime.strptime(start_date, "%Y-%m-%d")
    end_dt = datetime.strptime(end_date, "%Y-%m-%d")
except:
    # If date parsing fails, print all events
    sys.stdout.write(sys.stdin.read())
    sys.exit(0)

events_text = sys.stdin.read()

if not events_text or "No Events Found" in events_text:
    sys.stdout.write(events_text)
    sys.exit(0)

# Parse events - gcalcli format: "Mon Dec 09  9:00" or "Mon Dec 09" at start of line
lines = events_text.split('\n')
filtered_lines = []
current_event_lines = []
current_event_date = None
now = datetime.now()
current_year = now.year

for line in lines:
    # Check if line starts with a date (new event)
    # Format: "Mon Dec 09" or "Mon Dec 09  9:00" (with or without ANSI codes)
    # Strip ANSI codes first
    clean_line = re.sub(r'\x1b\[[0-9;]*m', '', line)
    # Also strip leading/trailing whitespace
    clean_line = clean_line.strip()
    # Match date pattern - allow for optional leading whitespace
    date_match = re.match(r'([A-Z][a-z]{2} [A-Z][a-z]{2} +[0-9]{1,2})', clean_line)
    
    if date_match:
        # Process previous event if we have one
        if current_event_date is not None:
            try:
                # Parse the date - handle single or double spaces
                event_date_str = current_event_date.strip()
                parsed = False
                event_dt = None
                
                for fmt in ["%a %b %d", "%a %b  %d"]:  # Single or double space
                    try:
                        # Try current year first
                        event_dt = datetime.strptime(f"{event_date_str} {current_year}", f"{fmt} %Y")
                        # Determine correct year based on whether the date is in the past
                        # If the event date (with current year) is in the past, it's likely next year
                        if event_dt < now:
                            # Event is in the past - check how far
                            days_diff = (now - event_dt).days
                            # If more than 30 days ago, it's definitely next year
                            # If less than 30 days but still in past, it could be this year or next
                            # For safety, if it's more than 7 days in the past, assume next year
                            if days_diff > 7:
                                event_dt = datetime.strptime(f"{event_date_str} {current_year + 1}", f"{fmt} %Y")
                        parsed = True
                        break
                    except ValueError:
                        continue
                
                # If we successfully parsed the date, check if it's in range
                if parsed and event_dt:
                    # Compare dates (ignore time component)
                    event_date_only = event_dt.date()
                    start_date_only = start_dt.date()
                    end_date_only = end_dt.date()
                    # Only include if within range
                    if start_date_only <= event_date_only <= end_date_only:
                        filtered_lines.extend(current_event_lines)
                    # If outside range, don't include (don't extend current_event_lines)
                # If parsing failed, don't include the event (it's better to be strict about date ranges)
            except Exception:
                # On any error, include the event (better to show than hide)
                filtered_lines.extend(current_event_lines)
        
        # Start new event
        current_event_lines = [line]
        current_event_date = date_match.group(1)
    elif current_event_date is not None:
        # Continuation of current event
        current_event_lines.append(line)
    else:
        # Header or non-event line - include it
        filtered_lines.append(line)

# Process last event
if current_event_date is not None:
    try:
        event_date_str = current_event_date.strip()
        parsed = False
        event_dt = None
        
        for fmt in ["%a %b %d", "%a %b  %d"]:
            try:
                # Try current year first
                event_dt = datetime.strptime(f"{event_date_str} {current_year}", f"{fmt} %Y")
                # Determine correct year based on whether the date is in the past
                # If the event date (with current year) is in the past, it's likely next year
                if event_dt < now:
                    # Event is in the past - check how far
                    days_diff = (now - event_dt).days
                    # If more than 30 days ago, it's definitely next year
                    # If less than 30 days but still in past, it could be this year or next
                    # For safety, if it's more than 7 days in the past, assume next year
                    if days_diff > 7:
                        event_dt = datetime.strptime(f"{event_date_str} {current_year + 1}", f"{fmt} %Y")
                parsed = True
                break
            except ValueError:
                continue
        
        # If we successfully parsed the date, check if it's in range
        if parsed and event_dt:
            # Compare dates (ignore time component)
            event_date_only = event_dt.date()
            start_date_only = start_dt.date()
            end_date_only = end_dt.date()
            # Only include if within range
            if start_date_only <= event_date_only <= end_date_only:
                filtered_lines.extend(current_event_lines)
            # If outside range, don't include
        # If parsing failed, don't include the event (be strict about date ranges)
    except Exception:
        filtered_lines.extend(current_event_lines)

# Print filtered events
sys.stdout.write('\n'.join(filtered_lines))
if filtered_lines and filtered_lines[-1]:
    sys.stdout.write('\n')
PYTHON_SCRIPT
}

# Get Google Calendar events
get_google_events() {
  local start_date="${1:-today}"
  local end_date="${2:-tomorrow}"
  local calendar="${3:-$GOOGLE_CALENDAR_NAME}"
  
  if ! check_gcalcli; then
    return 1
  fi
  
  # Normalize dates
  local normalized_start=$(normalize_date "$start_date")
  local normalized_end=$(normalize_date "$end_date")
  
  # For date range queries, we might need to query a wider range and filter
  # because gcalcli sometimes doesn't strictly respect end dates
  # Query with a reasonable buffer, then filter
  local query_end="$normalized_end"
  
  # If end date is a relative date far in future, cap it reasonably
  local end_ts=$(date_to_timestamp "$normalized_end")
  local start_ts=$(date_to_timestamp "$normalized_start")
  local days_diff=0
  
  if [[ "$end_ts" != "0" ]] && [[ "$start_ts" != "0" ]]; then
    days_diff=$(( (end_ts - start_ts) / 86400 ))
  fi
  
  # If the range is more than 30 days, cap the query at 60 days to avoid huge results
  if [[ $days_diff -gt 30 ]]; then
    if [[ "$(uname)" == "Darwin" ]]; then
      query_end=$(date -v+60d +"%Y-%m-%d" 2>/dev/null || echo "$normalized_end")
    else
      query_end=$(date -d "+60 days" +"%Y-%m-%d" 2>/dev/null || echo "$normalized_end")
    fi
  fi
  
  # Try to get events and capture both stdout and stderr for debugging
  local error_output
  error_output=$(mktemp)
  
  # Convert YYYY-MM-DD dates to gcalcli-friendly format if needed
  # gcalcli accepts: today, tomorrow, YYYY-MM-DD, or relative dates
  local gcalcli_start="$normalized_start"
  local gcalcli_end="$query_end"
  
  # If normalized dates are in YYYY-MM-DD format, they should work with gcalcli
  # But let's make sure we're using the right format
  local events
  events=$(gcalcli --calendar "$calendar" agenda "$gcalcli_start" "$gcalcli_end" 2>"$error_output")
  local exit_code=$?
  
  # Check for errors
  if [[ $exit_code -ne 0 ]] || [[ -s "$error_output" ]]; then
    # Check if it's just "no events" or an actual error
    local error_text
    error_text=$(cat "$error_output" 2>/dev/null || echo "")
    
    # Common errors to handle
    if echo "$error_text" | grep -qi "calendar.*not found\|could not find calendar\|unknown calendar"; then
      echo "‚ö†Ô∏è  Calendar '$calendar' not found. Available calendars:" >&2
      gcalcli list 2>/dev/null | head -10 >&2
      echo "" >&2
      echo "üí° Tip: Calendar names are case-sensitive and must match exactly." >&2
      echo "   Run 'gtd-calendar discover' to see available calendars." >&2
      rm -f "$error_output"
      return 1
    fi
    
    # If there's an error but it's not a calendar not found error, 
    # it might be a date format issue - try with a wider query
    if [[ -n "$error_text" ]] && [[ "$error_text" != *"No Events Found"* ]]; then
      # Try querying with a wider range using today as start
      local fallback_events
      fallback_events=$(gcalcli --calendar "$calendar" agenda "today" "$query_end" 2>/dev/null)
      if [[ -n "$fallback_events" ]] && [[ "$fallback_events" != *"No Events Found"* ]]; then
        events="$fallback_events"
      fi
    fi
  fi
  
  rm -f "$error_output"
  
  # Always filter events to the exact date range requested
  # (gcalcli sometimes shows events beyond the end date)
  # Use normalize_to_ymd to ensure we have YYYY-MM-DD for filtering
  local filter_start=$(normalize_to_ymd "$normalized_start")
  local filter_end=$(normalize_to_ymd "$normalized_end")
  
  if [[ -n "$events" ]] && [[ "$events" != *"No Events Found"* ]]; then
    # Store original events in case filtering removes everything
    local original_events="$events"
    local has_events_before_filter=false
    if echo "$events" | grep -qiE "([A-Z][a-z]{2} [A-Z][a-z]{2}|[0-9]{1,2}:[0-9]{2})"; then
      has_events_before_filter=true
    fi
    
    # Only filter if we have valid YYYY-MM-DD dates
    if [[ -n "$filter_start" ]] && [[ -n "$filter_end" ]] && \
       echo "$filter_start" | grep -qE "^[0-9]{4}-[0-9]{2}-[0-9]{2}$" && \
       echo "$filter_end" | grep -qE "^[0-9]{4}-[0-9]{2}-[0-9]{2}$"; then
      # Filter events by date range
      local filtered_events
      filtered_events=$(filter_events_by_date "$events" "$filter_start" "$filter_end")
      
      # If we had events before filtering but none after, something went wrong
      # Return original events (better to show too many than none)
      if [[ "$has_events_before_filter" == "true" ]] && \
         [[ -z "$filtered_events" ]] || ! echo "$filtered_events" | grep -qiE "([A-Z][a-z]{2} [A-Z][a-z]{2}|[0-9]{1,2}:[0-9]{2})"; then
        events="$original_events"
      else
        events="$filtered_events"
      fi
    else
      # If we can't normalize dates properly, still try to filter with what we have
      # This handles cases where dates are in relative format that gcalcli understands
      # but we can't convert to YYYY-MM-DD
      if [[ "$normalized_start" != "today" ]] || [[ "$normalized_end" != "tomorrow" ]]; then
        # For non-default dates, try to filter even if dates aren't perfect YYYY-MM-DD
        # The filter function will handle this gracefully
        local filtered_events
        filtered_events=$(filter_events_by_date "$events" "$normalized_start" "$normalized_end" 2>/dev/null || echo "$events")
        
        # Safety check: if filtering removed everything but we had events, use original
        if [[ "$has_events_before_filter" == "true" ]] && \
           [[ -z "$filtered_events" ]] || ! echo "$filtered_events" | grep -qiE "([A-Z][a-z]{2} [A-Z][a-z]{2}|[0-9]{1,2}:[0-9]{2})"; then
          events="$original_events"
        else
          events="$filtered_events"
        fi
      fi
    fi
  fi
  
  # Return events if any, or empty string
  # Check if events contain actual event data (not just headers or "No Events Found")
  # Be lenient - if we have any content that looks like events, return it
  if [[ -n "$events" ]] && [[ "$events" != *"No Events Found"* ]]; then
    # Check if it looks like event data (has date patterns or event-like content)
    # This is more lenient - if filtering removed everything, we might have had events
    if echo "$events" | grep -qiE "([A-Z][a-z]{2} [A-Z][a-z]{2}|[0-9]{1,2}:[0-9]{2})"; then
      echo "$events"
      return 0
    fi
  fi
  
  # Return empty string if no events found
  return 0  # No events is not an error
}

# Add event to Google Calendar
add_google_event() {
  local title="$1"
  local when="$2"
  local duration="${3:-60}"
  local description="${4:-}"
  local calendar="${5:-$PRIMARY_WRITE_CALENDAR}"
  
  if ! check_gcalcli; then
    echo "‚ùå Error: gcalcli not found. Install with: brew install gcalcli" >&2
    return 1
  fi
  
  if [[ -z "$title" ]]; then
    echo "‚ùå Error: Event title is required" >&2
    return 1
  fi
  
  if [[ -z "$when" ]]; then
    echo "‚ùå Error: Event time is required" >&2
    return 1
  fi
  
  # Check if calendar is writable
  if ! is_calendar_writable "$calendar"; then
    echo "‚ùå Error: Calendar '$calendar' is read-only or not found" >&2
    echo "" >&2
    echo "Writable calendars:" >&2
    local write_cals
    write_cals=$(get_write_calendars)
    local count=1
    while IFS= read -r cal_entry; do
      if [[ -n "$cal_entry" ]]; then
        local cal_name="${cal_entry#*|}"
        cal_name="${cal_name%%|*}"
        local display_name="${cal_entry##*|}"
        echo "  $count) $display_name ($cal_name)" >&2
        ((count++))
      fi
    done <<< "$write_cals"
    return 1
  fi
  
  # Build command with proper quoting to handle special characters
  local error_output
  error_output=$(mktemp)
  
  # Use proper argument passing instead of eval to avoid quoting issues
  if [[ -n "$description" ]]; then
    gcalcli --calendar "$calendar" add --title "$title" --when "$when" --duration "$duration" --description "$description" 2>"$error_output"
  else
    gcalcli --calendar "$calendar" add --title "$title" --when "$when" --duration "$duration" 2>"$error_output"
  fi
  
  local exit_code=$?
  
  if [[ $exit_code -eq 0 ]]; then
    echo "‚úÖ Successfully added event to Google Calendar: $title"
    
    # Award XP for adding calendar event (gamification)
    if command -v gtd-gamify-award &>/dev/null; then
      gtd-gamify-award task "" "Added calendar event: $title" 2>/dev/null || true
    elif [[ -f "$HOME/code/dotfiles/bin/gtd-gamify-award" ]]; then
      "$HOME/code/dotfiles/bin/gtd-gamify-award" task "" "Added calendar event: $title" 2>/dev/null || true
    elif [[ -f "$HOME/code/personal/dotfiles/bin/gtd-gamify-award" ]]; then
      "$HOME/code/personal/dotfiles/bin/gtd-gamify-award" task "" "Added calendar event: $title" 2>/dev/null || true
    fi
    
    rm -f "$error_output"
    return 0
  else
    echo "‚ùå Failed to add event to Google Calendar" >&2
    if [[ -s "$error_output" ]]; then
      echo "Error details:" >&2
      cat "$error_output" >&2
      echo "" >&2
    fi
    echo "Common issues:" >&2
    echo "  ‚Ä¢ gcalcli not authenticated - run: gcalcli auth" >&2
    echo "  ‚Ä¢ Calendar '$calendar' not found - check calendar name" >&2
    echo "  ‚Ä¢ Invalid date/time format - use format like '2024-12-05 10:00' or 'tomorrow 2pm'" >&2
    
    rm -f "$error_output"
    return 1
  fi
}

# Get Office 365 events (requires Microsoft Graph API or similar)
get_office365_events() {
  local start_date="${1:-today}"
  local end_date="${2:-tomorrow}"
  
  # Check if we have Office 365 credentials
  if [[ -z "$GTD_OFFICE365_CLIENT_ID" ]] || [[ -z "$GTD_OFFICE365_CLIENT_SECRET" ]]; then
    echo "Error: Office 365 credentials not configured"
    echo "Set GTD_OFFICE365_CLIENT_ID and GTD_OFFICE365_CLIENT_SECRET in your .gtd_config"
    return 1
  fi
  
  # Use Microsoft Graph API
  # This is a simplified version - you may need to implement OAuth2 flow
  local access_token="${GTD_OFFICE365_ACCESS_TOKEN:-}"
  
  if [[ -z "$access_token" ]]; then
    echo "Error: Office 365 access token not available"
    echo "You may need to authenticate first"
    return 1
  fi
  
  # Format dates for Graph API
  local start_iso=$(date -j -f "%Y-%m-%d" "$start_date" +"%Y-%m-%dT00:00:00Z" 2>/dev/null || date -d "$start_date" +"%Y-%m-%dT00:00:00Z" 2>/dev/null || echo "")
  local end_iso=$(date -j -f "%Y-%m-%d" "$end_date" +"%Y-%m-%dT23:59:59Z" 2>/dev/null || date -d "$end_date" +"%Y-%m-%dT23:59:59Z" 2>/dev/null || echo "")
  
  # Call Graph API
  curl -s -H "Authorization: Bearer $access_token" \
    "https://graph.microsoft.com/v1.0/me/calendar/calendarView?startDateTime=${start_iso}&endDateTime=${end_iso}" \
    2>/dev/null | python3 -m json.tool 2>/dev/null || echo "[]"
}

# View calendar (all configured calendars)
view_calendar() {
  local days="${1:-7}"
  local end_date=""
  
  if [[ "$(uname)" == "Darwin" ]]; then
    end_date=$($DATE_CMD -v+${days}d +"%Y-%m-%d" 2>/dev/null || echo "")
  else
    end_date=$($DATE_CMD -d "+${days} days" +"%Y-%m-%d" 2>/dev/null || echo "")
  fi
  
  echo "üìÖ Calendar View (Next $days days)"
  echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
  echo ""
  
  # Get all configured calendars
  local configured_cals
  configured_cals=$(get_configured_calendars)
  
  if [[ -z "$configured_cals" ]]; then
    echo "‚ö†Ô∏è  No calendars configured"
    echo ""
    echo "To configure calendars, edit ~/.gtd_config_calendar or add:"
    echo "  GTD_CALENDARS=("
    echo "    \"rw:GTD:My GTD Calendar\""
    echo "    \"ro:Family:Family Events\""
    echo "  )"
    return 0
  fi
  
  local calendar_count=0
  
  # Process each configured calendar
  while IFS= read -r cal_entry; do
    if [[ -z "$cal_entry" ]]; then
      continue
    fi
    
    local type="${cal_entry%%|*}"
    local cal_name="${cal_entry#*|}"
    cal_name="${cal_name%%|*}"
    local display_name="${cal_entry##*|}"
    
    # Use calendar name as display name if not provided
    if [[ "$display_name" == "$cal_entry" ]] || [[ "$display_name" == "$cal_name" ]]; then
      display_name="$cal_name"
    fi
    
    ((calendar_count++))
    
    # Determine icon based on type
    local icon="üìò"
    local type_label=""
    if [[ "$type" == "ro" ]]; then
      icon="üëÅÔ∏è "
      type_label=" (read-only)"
    else
      icon="‚úèÔ∏è "
      type_label=" (read-write)"
    fi
    
    echo "${icon} $display_name${type_label}:"
    echo ""
    
    # Fetch and display events for Google calendars
    if check_gcalcli; then
      local events
      events=$(get_google_events "today" "$end_date" "$cal_name" 2>/dev/null)
      if [[ -n "$events" ]]; then
        echo "$events" | head -20 | sed 's/^/  /'
      else
        echo "  (No events found)"
      fi
    else
      echo "  (gcalcli not configured)"
    fi
    
    echo ""
  done <<< "$configured_cals"
  
  if [[ $calendar_count -eq 0 ]]; then
    echo "‚ö†Ô∏è  No calendars found to display"
  fi
}

# Check for conflicts
check_conflicts() {
  local start_time="$1"
  local end_time="$2"
  local duration="${3:-60}"
  
  if [[ -z "$start_time" || -z "$end_time" ]]; then
    echo "Usage: gtd-calendar conflicts <start-time> <end-time> [duration-minutes]"
    echo "Example: gtd-calendar conflicts '2024-12-02 10:00' '2024-12-02 11:00'"
    exit 1
  fi
  
  echo "üîç Checking for conflicts across all calendars..."
  echo ""
  
  local conflicts=0
  local start_date=$(echo "$start_time" | cut -d' ' -f1)
  local end_date=$(echo "$end_time" | cut -d' ' -f1)
  
  # Get all configured calendars
  local configured_cals
  configured_cals=$(get_configured_calendars)
  
  if [[ -z "$configured_cals" ]]; then
    echo "‚ö†Ô∏è  No calendars configured for conflict checking"
    return 1
  fi
  
  # Check each calendar for conflicts
  while IFS= read -r cal_entry; do
    if [[ -z "$cal_entry" ]]; then
      continue
    fi
    
    local type="${cal_entry%%|*}"
    local cal_name="${cal_entry#*|}"
    cal_name="${cal_name%%|*}"
    local display_name="${cal_entry##*|}"
    
    # Use calendar name as display name if not provided
    if [[ "$display_name" == "$cal_entry" ]] || [[ "$display_name" == "$cal_name" ]]; then
      display_name="$cal_name"
    fi
    
    # Check Google calendars (gcalcli can access any Google calendar)
    if check_gcalcli; then
      local events
      events=$(get_google_events "$start_date" "$end_date" "$cal_name" 2>/dev/null)
      if [[ -n "$events" ]]; then
        local conflict_events
        conflict_events=$(echo "$events" | grep -E "$start_date|$end_date" 2>/dev/null)
        if [[ -n "$conflict_events" ]]; then
          echo "‚ö†Ô∏è  Conflicts in $display_name:"
          echo "$conflict_events" | sed 's/^/  /'
          echo ""
          ((conflicts++))
        fi
      fi
    fi
  done <<< "$configured_cals"
  
  if [[ $conflicts -eq 0 ]]; then
    echo "‚úÖ No conflicts found in any calendar!"
  else
    echo "Found conflicts in $conflicts calendar(s)"
  fi
}

# Sync task to calendar
sync_task_to_calendar() {
  local task_id="$1"
  local calendar_type="${2:-google}"  # google or office365
  local when="${3:-}"
  
  # Find task
  local task_file=""
  if [[ -d "$TASKS_PATH" ]]; then
    task_file=$(find "$TASKS_PATH" -name "*${task_id}*.md" -type f | head -1)
  fi
  
  if [[ -z "$task_file" || ! -f "$task_file" ]]; then
    echo "Error: Task not found"
    exit 1
  fi
  
  # Extract task info
  get_frontmatter_value() {
    local file="$1"
    local key="$2"
    grep "^${key}:" "$file" 2>/dev/null | head -1 | cut -d':' -f2 | sed 's/^[[:space:]]*//' | sed 's/[[:space:]]*$//'
  }
  
  local title=$(get_frontmatter_value "$task_file" "title")
  local due=$(get_frontmatter_value "$task_file" "due")
  local description=$(get_frontmatter_value "$task_file" "description")
  local energy=$(get_frontmatter_value "$task_file" "energy")
  
  # Use due date or provided when
  local event_time="${when:-$due}"
  
  if [[ -z "$event_time" ]]; then
    echo "Error: No time specified. Use --when or task must have due date"
    exit 1
  fi
  
  # Format for calendar
  case "$calendar_type" in
    google)
      if check_gcalcli; then
        if add_google_event "$title" "$event_time" "60" "$description" "$PRIMARY_WRITE_CALENDAR"; then
          # Award XP for syncing task to calendar (gamification)
          if command -v gtd-gamify-award &>/dev/null; then
            gtd-gamify-award task "" "Synced task to calendar: $title" 2>/dev/null || true
          elif [[ -f "$HOME/code/dotfiles/bin/gtd-gamify-award" ]]; then
            "$HOME/code/dotfiles/bin/gtd-gamify-award" task "" "Synced task to calendar: $title" 2>/dev/null || true
          elif [[ -f "$HOME/code/personal/dotfiles/bin/gtd-gamify-award" ]]; then
            "$HOME/code/personal/dotfiles/bin/gtd-gamify-award" task "" "Synced task to calendar: $title" 2>/dev/null || true
          fi
        else
          echo "‚ùå Failed to sync task to Google Calendar" >&2
          return 1
        fi
      else
        echo "‚ùå gcalcli not available. Install with: brew install gcalcli" >&2
        return 1
      fi
      ;;
    office365)
      echo "Office 365 sync requires Microsoft Graph API implementation"
      echo "Task: $title"
      echo "Time: $event_time"
      
      # Award XP for syncing task to calendar (gamification)
      if command -v gtd-gamify-award &>/dev/null; then
        gtd-gamify-award task "" "Synced task to calendar: $title" 2>/dev/null || true
      elif [[ -f "$HOME/code/dotfiles/bin/gtd-gamify-award" ]]; then
        "$HOME/code/dotfiles/bin/gtd-gamify-award" task "" "Synced task to calendar: $title" 2>/dev/null || true
      elif [[ -f "$HOME/code/personal/dotfiles/bin/gtd-gamify-award" ]]; then
        "$HOME/code/personal/dotfiles/bin/gtd-gamify-award" task "" "Synced task to calendar: $title" 2>/dev/null || true
      fi
      ;;
    *)
      echo "Error: Unknown calendar type: $calendar_type"
      exit 1
      ;;
  esac
}

# Main function
# List events from all configured calendars
list_events() {
  local start_date="${1:-}"
  local end_date="${2:-}"
  
  # Set defaults if empty
  if [[ -z "$start_date" ]]; then
    start_date="today"
  fi
  if [[ -z "$end_date" ]]; then
    end_date="tomorrow"
  fi
  
  # Normalize dates (fix typos and parse relative dates)
  start_date=$(normalize_date "$start_date")
  end_date=$(normalize_date "$end_date")
  
  echo "üìÖ Events from all calendars ($start_date to $end_date)"
  echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
  echo ""
  
  # Get all configured calendars
  local configured_cals
  configured_cals=$(get_configured_calendars)
  
  if [[ -z "$configured_cals" ]]; then
    echo "‚ö†Ô∏è  No calendars configured"
    return 0
  fi
  
  local calendar_count=0
  local error_count=0
  
  # Process each configured calendar
  while IFS= read -r cal_entry; do
    if [[ -z "$cal_entry" ]]; then
      continue
    fi
    
    local type="${cal_entry%%|*}"
    local cal_name="${cal_entry#*|}"
    cal_name="${cal_name%%|*}"
    local display_name="${cal_entry##*|}"
    
    # Use calendar name as display name if not provided
    if [[ "$display_name" == "$cal_entry" ]] || [[ "$display_name" == "$cal_name" ]]; then
      display_name="$cal_name"
    fi
    
    ((calendar_count++))
    
    # Determine icon based on type
    local icon="üìò"
    if [[ "$type" == "ro" ]]; then
      icon="üëÅÔ∏è "
    else
      icon="‚úèÔ∏è "
    fi
    
    echo "${icon} $display_name:"
    
    # Fetch and display events for Google calendars
    if check_gcalcli; then
      # Capture stderr separately to show errors
      local error_output
      error_output=$(mktemp)
      
      local events
      events=$(get_google_events "$start_date" "$end_date" "$cal_name" 2>"$error_output")
      local exit_code=$?
      
      if [[ -s "$error_output" ]]; then
        echo "  ‚ö†Ô∏è  Error accessing calendar:" | sed 's/^/  /'
        cat "$error_output" | sed 's/^/    /' >&2
        ((error_count++))
      elif [[ -n "$events" ]]; then
        echo "$events" | sed 's/^/  /'
      else
        echo "  (No events found in this date range)"
      fi
      
      rm -f "$error_output"
    else
      echo "  (gcalcli not configured)"
    fi
    
    echo ""
  done <<< "$configured_cals"
  
  if [[ $calendar_count -eq 0 ]]; then
    echo "‚ö†Ô∏è  No calendars found to display"
  elif [[ $error_count -gt 0 ]]; then
    echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
    echo "‚ö†Ô∏è  Found $error_count error(s) accessing calendars"
    echo ""
    echo "üí° Troubleshooting tips:"
    echo "   ‚Ä¢ Calendar names are case-sensitive and must match exactly"
    echo "   ‚Ä¢ Run 'gtd-calendar discover' to see available calendar names"
    echo "   ‚Ä¢ Run 'gcalcli list' to see all calendars gcalcli can access"
    echo "   ‚Ä¢ Make sure gcalcli is authenticated: gcalcli auth"
  fi
}

# List configured calendars
list_calendars() {
  echo "üìÖ Configured Calendars"
  echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
  echo ""
  
  local configured_cals
  configured_cals=$(get_configured_calendars)
  
  if [[ -z "$configured_cals" ]]; then
    echo "‚ö†Ô∏è  No calendars configured"
    echo ""
    echo "To configure calendars, edit ~/.gtd_config_calendar and add:"
    echo "  GTD_CALENDARS=("
    echo "    \"rw:GTD:My GTD Calendar\""
    echo "    \"ro:Family:Family Events\""
    echo "  )"
    return 0
  fi
  
  echo "Read-Write Calendars (can add events):"
  echo ""
  local write_cals
  write_cals=$(get_write_calendars)
  local count=1
  while IFS= read -r cal_entry; do
    if [[ -n "$cal_entry" ]]; then
      local cal_name="${cal_entry#*|}"
      cal_name="${cal_name%%|*}"
      local display_name="${cal_entry##*|}"
      if [[ "$display_name" == "$cal_entry" ]] || [[ "$display_name" == "$cal_name" ]]; then
        display_name="$cal_name"
      fi
      echo "  $count) ‚úèÔ∏è  $display_name ($cal_name)"
      ((count++))
    fi
  done <<< "$write_cals"
  
  if [[ $count -eq 1 ]]; then
    echo "  (none configured)"
  fi
  
  echo ""
  echo "Read-Only Calendars (view only):"
  echo ""
  
  local ro_count=0
  while IFS= read -r cal_entry; do
    if [[ -z "$cal_entry" ]]; then
      continue
    fi
    
    local type="${cal_entry%%|*}"
    if [[ "$type" == "ro" ]]; then
      local cal_name="${cal_entry#*|}"
      cal_name="${cal_name%%|*}"
      local display_name="${cal_entry##*|}"
      if [[ "$display_name" == "$cal_entry" ]] || [[ "$display_name" == "$cal_name" ]]; then
        display_name="$cal_name"
      fi
      ((ro_count++))
      echo "  $ro_count) üëÅÔ∏è  $display_name ($cal_name)"
    fi
  done <<< "$configured_cals"
  
  if [[ $ro_count -eq 0 ]]; then
    echo "  (none configured)"
  fi
  
  echo ""
  echo "üí° To discover available Google Calendars, run: gcalcli list"
}

# Discover available Google calendars
discover_calendars() {
  if ! check_gcalcli; then
    return 1
  fi
  
  echo "üîç Discovering Available Google Calendars"
  echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
  echo ""
  echo "Available calendars in your Google account:"
  echo ""
  
  local available_cals
  available_cals=$(gcalcli list 2>&1)
  local exit_code=$?
  
  if [[ $exit_code -ne 0 ]]; then
    echo "‚ùå Failed to list calendars."
    echo ""
    echo "Error output:"
    echo "$available_cals" | grep -v "^$"
    echo ""
    echo "üí° Make sure you're authenticated:"
    echo "   Run: gcalcli auth"
    return 1
  fi
  
  if [[ -z "$available_cals" ]]; then
    echo "‚ö†Ô∏è  No calendars found (or not authenticated)"
    return 1
  fi
  
  echo "$available_cals"
  echo ""
  echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
  echo ""
  echo "üìã Currently Configured Calendars:"
  echo ""
  
  local configured_cals
  configured_cals=$(get_configured_calendars)
  
  if [[ -z "$configured_cals" ]]; then
    echo "  (none configured)"
  else
    while IFS= read -r cal_entry; do
      if [[ -z "$cal_entry" ]]; then
        continue
      fi
      
      local type="${cal_entry%%|*}"
      local cal_name="${cal_entry#*|}"
      cal_name="${cal_name%%|*}"
      local display_name="${cal_entry##*|}"
      
      if [[ "$display_name" == "$cal_entry" ]] || [[ "$display_name" == "$cal_name" ]]; then
        display_name="$cal_name"
      fi
      
      # Check if this calendar exists in the available list
      if echo "$available_cals" | grep -qi "$cal_name"; then
        echo "  ‚úì $display_name ($cal_name) - found"
      else
        echo "  ‚ö†Ô∏è  $display_name ($cal_name) - NOT FOUND in Google Calendar"
        echo "     üí° Calendar name must match exactly (case-sensitive)"
      fi
    done <<< "$configured_cals"
  fi
  
  echo ""
  echo "üí° To add a calendar to your configuration:"
  echo "   1. Edit ~/.gtd_config_calendar"
  echo "   2. Add entries to GTD_CALENDARS array:"
  echo "      GTD_CALENDARS=("
  echo "        \"rw:CalendarName:Display Name\"  # for read-write"
  echo "        \"ro:CalendarName:Display Name\"  # for read-only"
  echo "      )"
  echo ""
  echo "   ‚ö†Ô∏è  IMPORTANT: Calendar names are case-sensitive and must match exactly!"
}

main() {
  case "${1:-view}" in
    view)
      shift
      view_calendar "${1:-7}"
      ;;
    conflicts)
      shift
      check_conflicts "$@"
      ;;
    sync)
      shift
      sync_task_to_calendar "$@"
      ;;
    list)
      list_calendars
      ;;
    list-events)
      shift
      list_events "${1:-today}" "${2:-tomorrow}"
      ;;
    discover)
      discover_calendars
      ;;
    google)
      shift
      case "$1" in
        add)
          shift
          add_google_event "$@"
          ;;
        list|agenda)
          shift
          get_google_events "${1:-today}" "${2:-tomorrow}" "${3:-$GOOGLE_CALENDAR_NAME}"
          ;;
        *)
          echo "Usage: gtd-calendar google [add|list|agenda]"
          exit 1
          ;;
      esac
      ;;
    office365|o365)
      shift
      case "$1" in
        list|agenda)
          shift
          get_office365_events "${1:-today}" "${2:-tomorrow}"
          ;;
        *)
          echo "Usage: gtd-calendar office365 [list|agenda]"
          exit 1
          ;;
      esac
      ;;
    count-events)
      shift
      # Enhanced calendar function: count events for date
      ENHANCED_SCRIPT="$HOME/code/dotfiles/bin/gtd-calendar-enhanced.sh"
      if [[ ! -f "$ENHANCED_SCRIPT" ]]; then
        ENHANCED_SCRIPT="$HOME/code/personal/dotfiles/bin/gtd-calendar-enhanced.sh"
      fi
      if [[ -f "$ENHANCED_SCRIPT" ]]; then
        source "$ENHANCED_SCRIPT"
        count_events_for_date "${1:-tomorrow}"
      else
        echo "Enhanced calendar features not available"
        exit 1
      fi
      ;;
    analyze-density)
      shift
      # Analyze calendar density for date range
      ENHANCED_SCRIPT="$HOME/code/dotfiles/bin/gtd-calendar-enhanced.sh"
      if [[ ! -f "$ENHANCED_SCRIPT" ]]; then
        ENHANCED_SCRIPT="$HOME/code/personal/dotfiles/bin/gtd-calendar-enhanced.sh"
      fi
      if [[ -f "$ENHANCED_SCRIPT" ]]; then
        source "$ENHANCED_SCRIPT"
        analyze_calendar_density "${1:-today}" "${2:-tomorrow}"
      else
        echo "Enhanced calendar features not available"
        exit 1
      fi
      ;;
    upcoming-context)
      shift
      # Show upcoming events in context
      ENHANCED_SCRIPT="$HOME/code/dotfiles/bin/gtd-calendar-enhanced.sh"
      if [[ ! -f "$ENHANCED_SCRIPT" ]]; then
        ENHANCED_SCRIPT="$HOME/code/personal/dotfiles/bin/gtd-calendar-enhanced.sh"
      fi
      if [[ -f "$ENHANCED_SCRIPT" ]]; then
        source "$ENHANCED_SCRIPT"
        get_upcoming_events_context "${1:-7}"
      else
        echo "Enhanced calendar features not available"
        exit 1
      fi
      ;;
    check-over-scheduled)
      shift
      # Warn about over-scheduled days
      ENHANCED_SCRIPT="$HOME/code/dotfiles/bin/gtd-calendar-enhanced.sh"
      if [[ ! -f "$ENHANCED_SCRIPT" ]]; then
        ENHANCED_SCRIPT="$HOME/code/personal/dotfiles/bin/gtd-calendar-enhanced.sh"
      fi
      if [[ -f "$ENHANCED_SCRIPT" ]]; then
        source "$ENHANCED_SCRIPT"
        check_over_scheduled_warning "${1:-tomorrow}"
      else
        echo "Enhanced calendar features not available"
        exit 1
      fi
      ;;
    suggest-time-blocking)
      shift
      # Suggest time-blocking for tasks
      ENHANCED_SCRIPT="$HOME/code/dotfiles/bin/gtd-calendar-enhanced.sh"
      if [[ ! -f "$ENHANCED_SCRIPT" ]]; then
        ENHANCED_SCRIPT="$HOME/code/personal/dotfiles/bin/gtd-calendar-enhanced.sh"
      fi
      if [[ -f "$ENHANCED_SCRIPT" ]]; then
        source "$ENHANCED_SCRIPT"
        suggest_time_blocking "${1:-}" "${2:-tomorrow}" "${3:-60}"
      else
        echo "Enhanced calendar features not available"
        exit 1
      fi
      ;;
    optimize-energy)
      shift
      # Energy pattern optimization
      ENHANCED_SCRIPT="$HOME/code/dotfiles/bin/gtd-calendar-enhanced.sh"
      if [[ ! -f "$ENHANCED_SCRIPT" ]]; then
        ENHANCED_SCRIPT="$HOME/code/personal/dotfiles/bin/gtd-calendar-enhanced.sh"
      fi
      if [[ -f "$ENHANCED_SCRIPT" ]]; then
        source "$ENHANCED_SCRIPT"
        optimize_calendar_for_energy "${1:-tomorrow}"
      else
        echo "Enhanced calendar features not available"
        exit 1
      fi
      ;;
    insights)
      shift
      # Get calendar insights
      ENHANCED_SCRIPT="$HOME/code/dotfiles/bin/gtd-calendar-enhanced.sh"
      if [[ ! -f "$ENHANCED_SCRIPT" ]]; then
        ENHANCED_SCRIPT="$HOME/code/personal/dotfiles/bin/gtd-calendar-enhanced.sh"
      fi
      if [[ -f "$ENHANCED_SCRIPT" ]]; then
        source "$ENHANCED_SCRIPT"
        get_calendar_insights "${1:-tomorrow}"
      else
        echo "Enhanced calendar features not available"
        exit 1
      fi
      ;;
    --help|-h)
      echo "GTD Calendar Integration"
      echo ""
      echo "Usage: gtd-calendar [command] [options]"
      echo ""
      echo "Commands:"
      echo "  view [days]              - View all configured calendars (default: 7 days)"
      echo "  list                     - List configured calendars"
      echo "  discover                 - Discover available Google calendars"
      echo "  conflicts <start> <end> - Check for scheduling conflicts across all calendars"
      echo "  sync <task-id> [type]   - Sync task to calendar (google/office365)"
      echo "  google add <title> <when> [duration] [description] [calendar]"
      echo "  google list [start] [end] [calendar]"
      echo "  office365 list [start] [end]"
      echo ""
      echo "Enhanced Features:"
      echo "  count-events [date]      - Count events for a specific date"
      echo "  analyze-density [start] [end] - Analyze calendar density for date range"
      echo "  upcoming-context [days]  - Show upcoming events in context (for planning)"
      echo "  check-over-scheduled [date] - Warn about over-scheduled days"
      echo "  suggest-time-blocking [task] [date] [duration] - Suggest time-blocking"
      echo "  optimize-energy [date]   - Energy pattern ‚Üí calendar optimization"
      echo "  insights [date]          - Get calendar insights for a date"
      echo ""
      echo "Examples:"
      echo "  gtd-calendar view 14"
      echo "  gtd-calendar list"
      echo "  gtd-calendar discover"
      echo "  gtd-calendar conflicts '2024-12-02 10:00' '2024-12-02 11:00'"
      echo "  gtd-calendar sync task-123 google"
      echo "  gtd-calendar google add 'Meeting' '2024-12-02 10:00' 60"
      echo "  gtd-calendar count-events tomorrow"
      echo "  gtd-calendar optimize-energy tomorrow"
      exit 0
      ;;
    *)
      echo "Unknown command: $1"
      echo "Use --help for usage"
      exit 1
      ;;
  esac
}

main "$@"


