# CRITICAL: Set system paths FIRST, before anything else
# This ensures basic commands (grep, mkdir, git, rm, etc.) are always available
# macOS system binaries are in /usr/bin and /bin
# Initialize PATH with system paths if it's empty or doesn't contain them
if [[ -z "$PATH" ]] || [[ ":$PATH:" != *":/usr/bin:"* ]]; then
  export PATH="/usr/bin:/bin:/usr/sbin:/sbin${PATH:+:$PATH}"
fi

# If you come from bash you might have to change your $PATH.
# export PATH=$HOME/bin:$HOME/.local/bin:/usr/local/bin:$PATH

# Path to your Oh My Zsh installation.
export ZSH="$HOME/.oh-my-zsh"

# Set name of the theme to load --- if set to "random", it will
# load a random theme each time Oh My Zsh is loaded, in which case,
# to know which specific one was loaded, run: echo $RANDOM_THEME
# See https://github.com/ohmyzsh/ohmyzsh/wiki/Themes
# ZSH_THEME="robbyrussell"
# ZSH_THEME="crunch"
# ZSH_THEME="aussiegeek"
ZSH_THEME="fino-time"

# Set list of themes to pick from when loading at random
# Setting this variable when ZSH_THEME=random will cause zsh to load
# a theme from this variable instead of looking in $ZSH/themes/
# If set to an empty array, this variable will have no effect.
# ZSH_THEME_RANDOM_CANDIDATES=( "robbyrussell" "agnoster" )

# Uncomment the following line to use case-sensitive completion.
# CASE_SENSITIVE="true"

# Uncomment the following line to use hyphen-insensitive completion.
# Case-sensitive completion must be off. _ and - will be interchangeable.
# HYPHEN_INSENSITIVE="true"

# Uncomment one of the following lines to change the auto-update behavior
# zstyle ':omz:update' mode disabled  # disable automatic updates
# zstyle ':omz:update' mode auto      # update automatically without asking
# zstyle ':omz:update' mode reminder  # just remind me to update when it's time

# Uncomment the following line to change how often to auto-update (in days).
# zstyle ':omz:update' frequency 13

# Uncomment the following line if pasting URLs and other text is messed up.
# DISABLE_MAGIC_FUNCTIONS="true"

# Uncomment the following line to disable colors in ls.
# DISABLE_LS_COLORS="true"

# Uncomment the following line to disable auto-setting terminal title.
# DISABLE_AUTO_TITLE="true"

# Uncomment the following line to enable command auto-correction.
# ENABLE_CORRECTION="true"

# Uncomment the following line to display red dots whilst waiting for completion.
# You can also set it to another string to have that shown instead of the default red dots.
# e.g. COMPLETION_WAITING_DOTS="%F{yellow}waiting...%f"
# Caution: this setting can cause issues with multiline prompts in zsh < 5.7.1 (see #5765)
# COMPLETION_WAITING_DOTS="true"

# Uncomment the following line if you want to disable marking untracked files
# under VCS as dirty. This makes repository status check for large repositories
# much, much faster.
# DISABLE_UNTRACKED_FILES_DIRTY="true"

# Uncomment the following line if you want to change the command execution time
# stamp shown in the history command output.
# You can set one of the optional three formats:
# "mm/dd/yyyy"|"dd.mm.yyyy"|"yyyy-mm-dd"
# or set a custom format using the strftime function format specifications,
# see 'man strftime' for details.
# HIST_STAMPS="mm/dd/yyyy"

# Would you like to use another custom folder than $ZSH/custom?
# ZSH_CUSTOM=/path/to/new-custom-folder

# Which plugins would you like to load?
# Standard plugins can be found in $ZSH/plugins/
# Custom plugins may be added to $ZSH_CUSTOM/plugins/
# Example format: plugins=(rails git textmate ruby lighthouse)
# Add wisely, as too many plugins slow down shell startup.
plugins=(git)

source $ZSH/oh-my-zsh.sh

# GTD System Hints - Rotating hints about available commands
_GTD_HINTS=(
  "üí≠ Log your thoughts: addInfoToDailyLog \"your entry\""
  "üì• Quick capture: gtd-capture \"your note\""
  "üì• Capture a task: gtd-capture --type=task \"your task\""
  "üìã Process your inbox: Check ~/Documents/gtd/0-inbox/"
  "ü§ñ Get advice: python3 ~/code/personal/dotfiles/zsh/functions/gtd_persona_helper.py hank \"your question\""
  "üé≠ Try different personas: george, john, jon, david, cal, james, marie, warren, sheryl, tim, spiderman, ironman, squirrelgirl, harley, deadpool, rogue, esther, gottman, gary, brene, romance"
  "üìù Daily log location: ~/Documents/daily_logs/"
  "üìÅ GTD inbox: ~/Documents/gtd/0-inbox/"
  "üí° Capture ideas: gtd-capture --type=idea \"your idea\""
  "üîó Save links: gtd-capture --type=link \"https://...\""
  "üìû Log calls: gtd-capture --type=call \"call notes\""
  "üìß Capture email actions: gtd-capture --type=email \"email action\""
  "üéØ Get GTD advice: python3 ~/code/personal/dotfiles/zsh/functions/gtd_persona_helper.py david \"help with organization\""
  "üß† Deep work advice: python3 ~/code/personal/dotfiles/zsh/functions/gtd_persona_helper.py cal \"help with focus\""
  "üìä Habit advice: python3 ~/code/personal/dotfiles/zsh/functions/gtd_persona_helper.py james \"build a habit\""
  "üòÑ Satirical take: python3 ~/code/personal/dotfiles/zsh/functions/gtd_persona_helper.py george \"your situation\""
  "üá¨üáß Witty analysis: python3 ~/code/personal/dotfiles/zsh/functions/gtd_persona_helper.py john \"your question\""
  "üé§ Sharp insights: python3 ~/code/personal/dotfiles/zsh/functions/gtd_persona_helper.py jon \"review this\""
)

# Daily log reminder with rotating hints - shows every 5 commands
_daily_log_command_counter() {
  # Initialize counter if not set
  (( _daily_log_cmd_count++ ))
  
  # Show reminder every 5 commands
  if (( _daily_log_cmd_count % 5 == 0 )); then
    local log_dir="${DAILY_LOG_DIR:-$HOME/Documents/daily_logs}"
    # Use date command with fallback
    local date_cmd="date"
    if [[ -x "/usr/bin/date" ]]; then
      date_cmd="/usr/bin/date"
    elif [[ -x "/bin/date" ]]; then
      date_cmd="/bin/date"
    fi
    local today=$($date_cmd +"%Y-%m-%d")
    local log_file="${log_dir}/${today}.md"
    
    # Get GTD inbox count if it exists
    # Try to load GTD config for base dir
    local gtd_config_file="$HOME/.gtd_config"
    if [[ ! -f "$gtd_config_file" && -f "$HOME/code/personal/dotfiles/zsh/.gtd_config" ]]; then
      gtd_config_file="$HOME/code/personal/dotfiles/zsh/.gtd_config"
    fi
    local gtd_base_dir="${GTD_BASE_DIR:-$HOME/Documents/gtd}"
    if [[ -f "$gtd_config_file" ]]; then
      # Try to extract GTD_BASE_DIR from config (use ripgrep if available, fallback to grep)
      # Use full paths to ensure commands are found even if PATH isn't set
      local head_cmd="/usr/bin/head"
      local cut_cmd="/usr/bin/cut"
      local tr_cmd="/usr/bin/tr"
      [[ ! -f "$head_cmd" ]] && head_cmd="head"
      [[ ! -f "$cut_cmd" ]] && cut_cmd="cut"
      [[ ! -f "$tr_cmd" ]] && tr_cmd="tr"
      local config_base_dir=""
      if command -v rg &>/dev/null; then
        # Use ripgrep for file search (faster)
        config_base_dir=$(rg "^GTD_BASE_DIR=" "$gtd_config_file" 2>/dev/null | "$head_cmd" -1 | "$cut_cmd" -d'=' -f2 | "$tr_cmd" -d '"' | "$tr_cmd" -d "'")
      else
        # Fallback to grep
        local grep_cmd="/usr/bin/grep"
        [[ ! -f "$grep_cmd" ]] && grep_cmd="grep"
        config_base_dir=$("$grep_cmd" "^GTD_BASE_DIR=" "$gtd_config_file" 2>/dev/null | "$head_cmd" -1 | "$cut_cmd" -d'=' -f2 | "$tr_cmd" -d '"' | "$tr_cmd" -d "'")
      fi
      if [[ -n "$config_base_dir" ]]; then
        gtd_base_dir="$config_base_dir"
      fi
    fi
    local gtd_inbox="${gtd_base_dir}/0-inbox"
    local inbox_count=0
    if [[ -d "$gtd_inbox" ]]; then
      # Use full paths to ensure commands are found
      local wc_cmd="/usr/bin/wc"
      local tr_cmd="/usr/bin/tr"
      [[ ! -f "$wc_cmd" ]] && wc_cmd="wc"
      [[ ! -f "$tr_cmd" ]] && tr_cmd="tr"
      inbox_count=$(find "$gtd_inbox" -type f -name "*.md" 2>/dev/null | "$wc_cmd" -l | "$tr_cmd" -d ' ')
    fi
    
    echo ""
    echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
    
    # Show random hint (rotate based on command count)
    local hint_index=$(( (_daily_log_cmd_count / 5) % ${#_GTD_HINTS[@]} ))
    echo "üí° ${_GTD_HINTS[$hint_index + 1]}"
    
    # Show daily log reminder
    if [[ -f "$log_file" ]]; then
      echo "üí≠ Daily log active - add more: addInfoToDailyLog \"your entry\""
    else
      echo "üìù Start your daily log: addInfoToDailyLog \"your entry\""
    fi
    
    # Show inbox reminder if there are items
    if [[ $inbox_count -gt 0 ]]; then
      echo "üì• Inbox has $inbox_count item(s) - process them from: $gtd_inbox"
    fi
    
    echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
  fi
}

# Track commands and show reminder
autoload -Uz add-zsh-hook
add-zsh-hook precmd _daily_log_command_counter

# User configuration

# export MANPATH="/usr/local/man:$MANPATH"

# You may need to manually set your language environment
# export LANG=en_US.UTF-8

# Preferred editor for local and remote sessions
# if [[ -n $SSH_CONNECTION ]]; then
#   export EDITOR='vim'
# else
#   export EDITOR='nvim'
# fi

# Compilation flags
# export ARCHFLAGS="-arch $(uname -m)"

# Set personal aliases, overriding those provided by Oh My Zsh libs,
# plugins, and themes. Aliases can be placed here, though Oh My Zsh
# users are encouraged to define aliases within a top-level file in
# the $ZSH_CUSTOM folder, with .zsh extension. Examples:
# - $ZSH_CUSTOM/aliases.zsh
# - $ZSH_CUSTOM/macos.zsh
# For a full list of active aliases, run `alias`.
#
# Example aliases
# alias zshconfig="mate ~/.zshrc"
# alias ohmyzsh="mate ~/.oh-my-zsh"

# Added by LM Studio CLI (lms)
export PATH="$PATH:/Users/abbymalson/.lmstudio/bin"
# End of LM Studio CLI section


### MANAGED BY RANCHER DESKTOP START (DO NOT EDIT)
export PATH="/Users/abby/.rd/bin:$PATH"
### MANAGED BY RANCHER DESKTOP END (DO NOT EDIT)

# CRITICAL: Ensure system paths are PREPENDED before mise activation
# This ensures basic commands (grep, head, cut, tr, wc, mkdir, git, rm, etc.) are always available
# Prepend system paths so they're found first
export PATH="/usr/bin:/bin:/usr/sbin:/sbin:${PATH}"

# mise (version manager) - replaces asdf
# Save system paths before mise activation (mise can reset PATH)
saved_system_paths="/usr/bin:/bin:/usr/sbin:/sbin"
eval "$(mise activate zsh)"

# CRITICAL: Re-add system paths immediately after mise activation
# mise can reset PATH, so we must ensure system paths are always present
export PATH="${saved_system_paths}:${PATH}"

# Double-check system paths are present (defensive programming)
if [[ ":$PATH:" != *":/usr/bin:"* ]]; then
  export PATH="/usr/bin:${PATH}"
fi
if [[ ":$PATH:" != *":/bin:"* ]]; then
  export PATH="/bin:${PATH}"
fi
if [[ ":$PATH:" != *":/usr/sbin:"* ]]; then
  export PATH="/usr/sbin:${PATH}"
fi
if [[ ":$PATH:" != *":/sbin:"* ]]; then
  export PATH="/sbin:${PATH}"
fi

# zsh-syntax-highlighting - must be sourced after oh-my-zsh
if [ -f /opt/homebrew/share/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh ]; then
  source /opt/homebrew/share/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh
  export ZSH_HIGHLIGHT_HIGHLIGHTERS_DIR=/opt/homebrew/share/zsh-syntax-highlighting/highlighters
fi

# zsh-autosuggestions - must be sourced after oh-my-zsh
if [ -f /opt/homebrew/share/zsh-autosuggestions/zsh-autosuggestions.zsh ]; then
  source /opt/homebrew/share/zsh-autosuggestions/zsh-autosuggestions.zsh
fi

# Vi mode with short timeout
bindkey -v
export KEYTIMEOUT=1

# Personal aliases
alias brewr="arch -x86_64 /usr/local/bin/brew"
alias leg="arch -x86_64"

# Pomo (Pomodoro timer) aliases
alias pomo="pomojs --log ~/.pomo.log --tmux"
alias longpomo="pomo -b 20"  # long-break pomodoro
alias minipomo="pomo -w 10"  # 10-minute pomodoro

# Utility function
function htmlEscape () {
    local s
    s=${1//&/&amp;}
    s=${s//</&lt;}
    s=${s//>/&gt;}
    s=${s//'"'/&quot;}
    printf -- %s "$s"
}

# PATH configurations
# IMPORTANT: System paths (/usr/bin, /bin) must come first for basic commands
# Re-ensure system paths are first (in case mise or other tools modified PATH)
if [[ ":$PATH:" != *":/usr/bin:"* ]]; then
  export PATH="/usr/bin:${PATH}"
fi
if [[ ":$PATH:" != *":/bin:"* ]]; then
  export PATH="/bin:${PATH}"
fi
# Homebrew (Apple Silicon)
export PATH="/opt/homebrew/bin:/opt/homebrew/sbin:${PATH}"
# npm global packages
export PATH="${HOME}/.local/bin:${PATH}"
# User bin directory
export PATH="${HOME}/bin:${PATH}"
# Dotfiles bin directory (GTD commands and other utilities)
export PATH="${HOME}/code/dotfiles/bin:${PATH}"
# Also support personal dotfiles location
if [[ -d "${HOME}/code/personal/dotfiles/bin" ]]; then
  export PATH="${HOME}/code/personal/dotfiles/bin:${PATH}"
fi

# Final safety check: ensure system binaries are always in PATH
# This prevents issues if mise or other tools remove them
if [[ ":$PATH:" != *":/usr/bin:"* ]]; then
  export PATH="/usr/bin:${PATH}"
fi
if [[ ":$PATH:" != *":/bin:"* ]]; then
  export PATH="/bin:${PATH}"
fi
if [[ ":$PATH:" != *":/usr/sbin:"* ]]; then
  export PATH="/usr/sbin:${PATH}"
fi
if [[ ":$PATH:" != *":/sbin:"* ]]; then
  export PATH="/sbin:${PATH}"
fi

# NVM (Node Version Manager)
export NVM_DIR="$HOME/.nvm"
if [ -s "/opt/homebrew/opt/nvm/nvm.sh" ]; then
  . "/opt/homebrew/opt/nvm/nvm.sh"
fi
if [ -s "/opt/homebrew/opt/nvm/etc/bash_completion.d/nvm" ]; then
  . "/opt/homebrew/opt/nvm/etc/bash_completion.d/nvm"
fi

# rbenv (Ruby version manager)
if command -v rbenv 1>/dev/null 2>&1; then
  eval "$(rbenv init - zsh)"
fi
export PATH="$HOME/.gem/ruby/3.0.0/bin:$PATH"

# pyenv (Python version manager)
if command -v pyenv 1>/dev/null 2>&1; then
  eval "$(pyenv init -)"
fi

# Daily Log Function with LM Studio Integration
# Load config from ~/.daily_log_config or fallback to dotfiles location
_daily_log_config_file="$HOME/.daily_log_config"
if [ ! -f "$_daily_log_config_file" ]; then
  # Try dotfiles location
  if [ -f "$HOME/code/personal/dotfiles/zsh/.daily_log_config" ]; then
    _daily_log_config_file="$HOME/code/personal/dotfiles/zsh/.daily_log_config"
  fi
fi

# Default values
DAILY_LOG_DIR="${DAILY_LOG_DIR:-$HOME/Documents/daily_logs}"
LM_STUDIO_URL="${LM_STUDIO_URL:-http://localhost:1234/v1/chat/completions}"

# Load config if it exists
if [[ -f "$_daily_log_config_file" ]]; then
  while IFS= read -r line; do
    # Skip comments and empty lines
    [[ "$line" =~ ^[[:space:]]*# ]] && continue
    [[ -z "${line// }" ]] && continue
    [[ ! "$line" =~ = ]] && continue
    
    # Split on first = sign
    key="${line%%=*}"
    value="${line#*=}"
    
    # Trim whitespace from key and value
    key="${key// /}"
    value="${value# }"
    value="${value% }"
    
    # Remove quotes from value
    value="${value#\"}"
    value="${value%\"}"
    value="${value#\'}"
    value="${value%\'}"
    
    # Expand $HOME in value
    value="${value//\$HOME/$HOME}"
    
    case "$key" in
      DAILY_LOG_DIR)
        DAILY_LOG_DIR="$value"
        ;;
      LM_STUDIO_URL)
        LM_STUDIO_URL="$value"
        ;;
    esac
  done < "$_daily_log_config_file"
fi
# gtd-advise is now a script in ~/bin - removed function to avoid shadowing
# Use: gtd-advise <persona> "content" or gtd-advise --all "content"
# Function to add info to daily log
addInfoToDailyLog() {
  if [[ -z "$1" ]]; then
    echo "Usage: addInfoToDailyLog \"Your log entry here\""
    return 1
  fi
  
  # Get config values (use defaults if not set)
  # Ensure $HOME is expanded if it's in the path
  local log_dir="${DAILY_LOG_DIR:-$HOME/Documents/daily_logs}"
  log_dir="${log_dir//\$HOME/$HOME}"
  local lm_url="${LM_STUDIO_URL:-http://localhost:1234/v1/chat/completions}"
  
  local log_entry="$1"
  # Use date command (PATH should have /usr/bin after mise activation fix)
  # Fallback to /bin/date if /usr/bin/date doesn't exist
  local date_cmd="date"
  if [[ -x "/usr/bin/date" ]]; then
    date_cmd="/usr/bin/date"
  elif [[ -x "/bin/date" ]]; then
    date_cmd="/bin/date"
  fi
  local today=$($date_cmd +"%Y-%m-%d")
  local current_time=$($date_cmd +"%H:%M")
  local log_file="${log_dir}/${today}.md"
  
  # Find the helper script - try multiple locations
  local helper_script=""
  local possible_paths=(
    "$HOME/code/personal/dotfiles/zsh/functions/lmstudio_helper.py"
    "${(%):-%x:h}/functions/lmstudio_helper.py"
  )
  
  for path in "${possible_paths[@]}"; do
    if [[ -f "$path" ]]; then
      helper_script="$path"
      break
    fi
  done
  
  # Create directory if it doesn't exist (use absolute path to mkdir)
  if [[ ! -d "$log_dir" ]]; then
    /bin/mkdir -p "$log_dir" || {
      echo "Error: Could not create directory $log_dir" >&2
      return 1
    }
  fi
  
  # Create file with header if it doesn't exist
  if [[ ! -f "$log_file" ]]; then
    echo "# Daily Log - $today" > "$log_file" || {
      echo "Error: Could not create log file $log_file"
      return 1
    }
    echo "" >> "$log_file"
  fi
  
  # Append the entry with timestamp
  echo "${current_time} - ${log_entry}" >> "$log_file" || {
    echo "Error: Could not write to log file $log_file"
    return 1
  }
  echo "‚úì Added: ${current_time} - ${log_entry}"
  
  # Check for kettlebell mention and trigger coach if first time today
  local kettlebell_flag_file="${log_dir}/.kettlebell_triggered_${today}"
  # Use ripgrep (rg) if available, fallback to grep
  local use_rg=false
  if command -v rg &>/dev/null; then
    use_rg=true
  fi
  local matched=false
  if [[ "$use_rg" == true ]]; then
    # rg can search stdin, use -i for case insensitive
    echo "$log_entry" | rg -qi "kettlebell" 2>/dev/null && matched=true
  else
    # Fallback to grep
    local grep_cmd="/usr/bin/grep"
    [[ ! -f "$grep_cmd" ]] && grep_cmd="grep"
    echo "$log_entry" | "$grep_cmd" -qi "kettlebell" 2>/dev/null && matched=true
  fi
  if [[ "$matched" == true ]]; then
    # Check if workout already exists in log file (more reliable than flag file)
    local workout_already_added=false
    if [[ -f "$log_file" ]]; then
      if [[ "$use_rg" == true ]]; then
        rg -q "KETTLEBELL EMOM WORKOUT" "$log_file" 2>/dev/null && workout_already_added=true
      else
        local grep_cmd="/usr/bin/grep"
        [[ ! -f "$grep_cmd" ]] && grep_cmd="grep"
        "$grep_cmd" -q "KETTLEBELL EMOM WORKOUT" "$log_file" 2>/dev/null && workout_already_added=true
      fi
    fi
    
    # Only trigger if flag file doesn't exist AND workout not already in log
    if [[ ! -f "$kettlebell_flag_file" && "$workout_already_added" == false ]]; then
      # Create flag file FIRST to prevent race conditions
      touch "$kettlebell_flag_file" 2>/dev/null || true
      
      # First mention of kettlebells today - trigger the coach
      echo ""
      echo "üí™ Kettlebell detected! Getting your EMOM workout for today..."
      echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
      
      # Find persona helper
      local persona_helper=""
      local possible_persona_paths=(
        "$HOME/code/personal/dotfiles/zsh/functions/gtd_persona_helper.py"
        "${(%):-%x:h}/functions/gtd_persona_helper.py"
        "$HOME/code/dotfiles/zsh/functions/gtd_persona_helper.py"
      )
      
      for path in "${possible_persona_paths[@]}"; do
        if [[ -f "$path" ]]; then
          persona_helper="$path"
          break
        fi
      done
      
      # Find python
      local python_cmd=""
      if [[ -f "/opt/homebrew/bin/python3" ]]; then
        python_cmd="/opt/homebrew/bin/python3"
      elif command -v python3 &>/dev/null; then
        python_cmd="python3"
      fi
      
      if [[ -n "$persona_helper" && -f "$persona_helper" && -n "$python_cmd" ]]; then
        # Get day of week for workout variety
        local day_of_week=$($date_cmd +"%A")
        local full_date=$($date_cmd +"%B %d, %Y")
        
        # Create special EMOM workout prompt
        local kettlebell_prompt=$(printf "I just mentioned kettlebells for the first time today! Today is %s, %s.

Please provide me with an EMOM (Every Minute On the Minute) kettlebell workout for today. IMPORTANT: EMOM means 'Every Minute On the Minute' - perform a set at the start of each minute, then rest for the remainder of that minute before the next set begins at the start of the next minute. This is a time-based format, NOT 'Every Month One Modification'. Make it:
- Challenging but achievable
- Varied and interesting
- Include exercises like swings, snatches, Turkish get-ups, goblet squats, cleans, presses, windmills
- Clear instructions with rep counts for each minute, total duration (e.g., 10 minutes = 10 rounds), and explain the EMOM timing format
- Motivating and encouraging

Give me a complete EMOM workout I can do right now. Be enthusiastic and celebrate my commitment to training!" "$day_of_week" "$full_date")
        
        # Call kettlebell coach
        local kettlebell_output
        kettlebell_output=$("$python_cmd" "$persona_helper" "kettlebell" "$kettlebell_prompt" "kettlebell_emom_workout" 2>&1)
        
        if [[ -n "$kettlebell_output" ]]; then
          echo "$kettlebell_output"
          echo ""
          
          # Append workout to daily log for easy reference
          echo "" >> "$log_file" || true
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ" >> "$log_file" || true
          echo "üí™ KETTLEBELL EMOM WORKOUT - ${day_of_week}, ${full_date}" >> "$log_file" || true
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ" >> "$log_file" || true
          echo "" >> "$log_file" || true
          echo "$kettlebell_output" >> "$log_file" || true
          echo "" >> "$log_file" || true
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ" >> "$log_file" || true
          echo "" >> "$log_file" || true
        fi
      else
        echo "‚ö†Ô∏è  Could not find persona helper or python3 for kettlebell coach"
        # Remove flag file if we couldn't add workout
        rm -f "$kettlebell_flag_file" 2>/dev/null || true
      fi
      
      echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
      echo ""
    fi
  fi
  
  # Check for Maxfit Pro/cable system mention and trigger coach if first time today
  local maxfit_flag_file="${log_dir}/.maxfit_triggered_${today}"
  # Use ripgrep (rg) if available, fallback to grep
  local use_rg=false
  if command -v rg &>/dev/null; then
    use_rg=true
  fi
  local matched=false
  if [[ "$use_rg" == true ]]; then
    echo "$log_entry" | rg -qiE "maxfit|cable system|cable workout" 2>/dev/null && matched=true
  else
    local grep_cmd="/usr/bin/grep"
    [[ ! -f "$grep_cmd" ]] && grep_cmd="grep"
    echo "$log_entry" | "$grep_cmd" -qiE "maxfit|cable system|cable workout" 2>/dev/null && matched=true
  fi
  if [[ "$matched" == true ]]; then
    # Check if workout already exists in log file (more reliable than flag file)
    local workout_already_added=false
    if [[ -f "$log_file" ]]; then
      if [[ "$use_rg" == true ]]; then
        rg -q "MAXFIT PRO CABLE WORKOUT" "$log_file" 2>/dev/null && workout_already_added=true
      else
        local grep_cmd="/usr/bin/grep"
        [[ ! -f "$grep_cmd" ]] && grep_cmd="grep"
        "$grep_cmd" -q "MAXFIT PRO CABLE WORKOUT" "$log_file" 2>/dev/null && workout_already_added=true
      fi
    fi
    
    # Only trigger if flag file doesn't exist AND workout not already in log
    if [[ ! -f "$maxfit_flag_file" && "$workout_already_added" == false ]]; then
      # Create flag file FIRST to prevent race conditions
      touch "$maxfit_flag_file" 2>/dev/null || true
      
      # First mention of Maxfit Pro/cable system today - trigger the coach
      echo ""
      echo "üí™ Maxfit Pro detected! Getting your cable workout for today..."
      echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
      
      # Find persona helper
      local persona_helper=""
      local possible_persona_paths=(
        "$HOME/code/personal/dotfiles/zsh/functions/gtd_persona_helper.py"
        "${(%):-%x:h}/functions/gtd_persona_helper.py"
        "$HOME/code/dotfiles/zsh/functions/gtd_persona_helper.py"
      )
      
      for path in "${possible_persona_paths[@]}"; do
        if [[ -f "$path" ]]; then
          persona_helper="$path"
          break
        fi
      done
      
      # Find python
      local python_cmd=""
      if [[ -f "/opt/homebrew/bin/python3" ]]; then
        python_cmd="/opt/homebrew/bin/python3"
      elif command -v python3 &>/dev/null; then
        python_cmd="python3"
      fi
      
      if [[ -n "$persona_helper" && -f "$persona_helper" && -n "$python_cmd" ]]; then
        # Get day of week for workout variety
        local day_of_week=$($date_cmd +"%A")
        local full_date=$($date_cmd +"%B %d, %Y")
        
        # Create special Maxfit Pro workout prompt
        local maxfit_prompt=$(printf "I just mentioned Maxfit Pro or my cable system for the first time today! Today is %s, %s.

Please provide me with a complete Maxfit Pro cable workout for today. Make it:
- Challenging but achievable
- Varied and interesting
- Include exercises like cable rows, cable presses, cable flies, cable curls, cable tricep extensions, cable lateral raises, cable wood chops, cable rotations, cable squats, cable deadlifts, cable pull-throughs, and cable core exercises
- Clear instructions with rep counts, sets, resistance levels, and rest periods
- Explain proper cable setup and form when relevant
- Motivating and encouraging

Give me a complete workout I can do right now with my Maxfit Pro cable system. Be enthusiastic and celebrate my commitment to training!" "$day_of_week" "$full_date")
        
        # Call Maxfit Pro coach
        local maxfit_output
        maxfit_output=$("$python_cmd" "$persona_helper" "maxfit" "$maxfit_prompt" "maxfit_workout" 2>&1)
        
        if [[ -n "$maxfit_output" ]]; then
          echo "$maxfit_output"
          echo ""
          
          # Append workout to daily log for easy reference
          echo "" >> "$log_file" || true
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ" >> "$log_file" || true
          echo "üí™ MAXFIT PRO CABLE WORKOUT - ${day_of_week}, ${full_date}" >> "$log_file" || true
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ" >> "$log_file" || true
          echo "" >> "$log_file" || true
          echo "$maxfit_output" >> "$log_file" || true
          echo "" >> "$log_file" || true
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ" >> "$log_file" || true
          echo "" >> "$log_file" || true
        fi
      else
        echo "‚ö†Ô∏è  Could not find persona helper or python3 for Maxfit Pro coach"
        # Remove flag file if we couldn't add workout
        rm -f "$maxfit_flag_file" 2>/dev/null || true
      fi
      
      echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
      echo ""
    fi
  fi
  
  # Check for dumbbell mention and trigger coach if first time today
  local dumbbell_flag_file="${log_dir}/.dumbbell_triggered_${today}"
  # Use ripgrep (rg) if available, fallback to grep
  local use_rg=false
  if command -v rg &>/dev/null; then
    use_rg=true
  fi
  local matched=false
  if [[ "$use_rg" == true ]]; then
    echo "$log_entry" | rg -qiE "dumbbell|dumbbells" 2>/dev/null && matched=true
  else
    local grep_cmd="/usr/bin/grep"
    [[ ! -f "$grep_cmd" ]] && grep_cmd="grep"
    echo "$log_entry" | "$grep_cmd" -qiE "dumbbell|dumbbells" 2>/dev/null && matched=true
  fi
  if [[ "$matched" == true ]]; then
    # Check if workout already exists in log file (more reliable than flag file)
    local workout_already_added=false
    if [[ -f "$log_file" ]]; then
      if [[ "$use_rg" == true ]]; then
        rg -q "DUMBBELL WORKOUT" "$log_file" 2>/dev/null && workout_already_added=true
      else
        local grep_cmd="/usr/bin/grep"
        [[ ! -f "$grep_cmd" ]] && grep_cmd="grep"
        "$grep_cmd" -q "DUMBBELL WORKOUT" "$log_file" 2>/dev/null && workout_already_added=true
      fi
    fi
    
    # Only trigger if flag file doesn't exist AND workout not already in log
    if [[ ! -f "$dumbbell_flag_file" && "$workout_already_added" == false ]]; then
      # Create flag file FIRST to prevent race conditions
      touch "$dumbbell_flag_file" 2>/dev/null || true
      
      # First mention of dumbbells today - trigger the coach
      echo ""
      echo "üí™ Dumbbells detected! Getting your workout for today..."
      echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
      
      # Find persona helper
      local persona_helper=""
      local possible_persona_paths=(
        "$HOME/code/personal/dotfiles/zsh/functions/gtd_persona_helper.py"
        "${(%):-%x:h}/functions/gtd_persona_helper.py"
        "$HOME/code/dotfiles/zsh/functions/gtd_persona_helper.py"
      )
      
      for path in "${possible_persona_paths[@]}"; do
        if [[ -f "$path" ]]; then
          persona_helper="$path"
          break
        fi
      done
      
      # Find python
      local python_cmd=""
      if [[ -f "/opt/homebrew/bin/python3" ]]; then
        python_cmd="/opt/homebrew/bin/python3"
      elif command -v python3 &>/dev/null; then
        python_cmd="python3"
      fi
      
      if [[ -n "$persona_helper" && -f "$persona_helper" && -n "$python_cmd" ]]; then
        # Get day of week for workout variety
        local day_of_week=$($date_cmd +"%A")
        local full_date=$($date_cmd +"%B %d, %Y")
        
        # Create special dumbbell workout prompt
        local dumbbell_prompt=$(printf "I just mentioned dumbbells for the first time today! Today is %s, %s.

Please provide me with a complete dumbbell workout for today. Make it:
- Challenging but achievable
- Varied and interesting
- Include exercises like dumbbell presses (chest, shoulder, incline), dumbbell rows, dumbbell curls, dumbbell tricep extensions, dumbbell lateral raises, dumbbell squats, dumbbell lunges, dumbbell deadlifts, dumbbell goblet squats, dumbbell renegade rows, dumbbell thrusters, and dumbbell core exercises
- Clear instructions with rep counts, sets, weight recommendations, and rest periods
- Explain proper form and technique
- Motivating and encouraging

Give me a complete workout I can do right now with dumbbells. Be enthusiastic and celebrate my commitment to training!" "$day_of_week" "$full_date")
        
        # Call dumbbell coach
        local dumbbell_output
        dumbbell_output=$("$python_cmd" "$persona_helper" "dumbbell" "$dumbbell_prompt" "dumbbell_workout" 2>&1)
        
        if [[ -n "$dumbbell_output" ]]; then
          echo "$dumbbell_output"
          echo ""
          
          # Append workout to daily log for easy reference
          echo "" >> "$log_file" || true
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ" >> "$log_file" || true
          echo "üí™ DUMBBELL WORKOUT - ${day_of_week}, ${full_date}" >> "$log_file" || true
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ" >> "$log_file" || true
          echo "" >> "$log_file" || true
          echo "$dumbbell_output" >> "$log_file" || true
          echo "" >> "$log_file" || true
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ" >> "$log_file" || true
          echo "" >> "$log_file" || true
        fi
      else
        echo "‚ö†Ô∏è  Could not find persona helper or python3 for dumbbell coach"
        # Remove flag file if we couldn't add workout
        rm -f "$dumbbell_flag_file" 2>/dev/null || true
      fi
      
      echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
      echo ""
    fi
  fi
  
  # Check for dip bar mention and trigger coach if first time today
  local dipbar_flag_file="${log_dir}/.dipbar_triggered_${today}"
  # Use word boundaries to avoid false matches
  # Match: "dip bar", "dipbar", "dips" (as whole word only), "parallel bar", "parallel bars"
  # This ensures "dips" only matches when it's a standalone word, not part of "kettlebell swings"
  # Use ripgrep (rg) if available, fallback to grep
  local use_rg=false
  if command -v rg &>/dev/null; then
    use_rg=true
  fi
  local matched=false
  if [[ "$use_rg" == true ]]; then
    echo "$log_entry" | rg -qiE "\b(dip[[:space:]]+bar|dipbar|parallel[[:space:]]+bar|parallel[[:space:]]+bars)\b|\bdips\b" 2>/dev/null && matched=true
  else
    local grep_cmd="/usr/bin/grep"
    [[ ! -f "$grep_cmd" ]] && grep_cmd="grep"
    echo "$log_entry" | "$grep_cmd" -qiE "\b(dip[[:space:]]+bar|dipbar|parallel[[:space:]]+bar|parallel[[:space:]]+bars)\b|\bdips\b" 2>/dev/null && matched=true
  fi
  if [[ "$matched" == true ]]; then
    # Check if workout already exists in log file (more reliable than flag file)
    local workout_already_added=false
    if [[ -f "$log_file" ]]; then
      if [[ "$use_rg" == true ]]; then
        rg -q "DIP BAR WORKOUT" "$log_file" 2>/dev/null && workout_already_added=true
      else
        local grep_cmd="/usr/bin/grep"
        [[ ! -f "$grep_cmd" ]] && grep_cmd="grep"
        "$grep_cmd" -q "DIP BAR WORKOUT" "$log_file" 2>/dev/null && workout_already_added=true
      fi
    fi
    
    # Only trigger if flag file doesn't exist AND workout not already in log
    if [[ ! -f "$dipbar_flag_file" && "$workout_already_added" == false ]]; then
      # Create flag file FIRST to prevent race conditions
      touch "$dipbar_flag_file" 2>/dev/null || true
      
      # First mention of dip bars today - trigger the coach
      echo ""
      echo "üí™ Dip bars detected! Getting your workout for today..."
      echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
      
      # Find persona helper
      local persona_helper=""
      local possible_persona_paths=(
        "$HOME/code/personal/dotfiles/zsh/functions/gtd_persona_helper.py"
        "${(%):-%x:h}/functions/gtd_persona_helper.py"
        "$HOME/code/dotfiles/zsh/functions/gtd_persona_helper.py"
      )
      
      for path in "${possible_persona_paths[@]}"; do
        if [[ -f "$path" ]]; then
          persona_helper="$path"
          break
        fi
      done
      
      # Find python
      local python_cmd=""
      if [[ -f "/opt/homebrew/bin/python3" ]]; then
        python_cmd="/opt/homebrew/bin/python3"
      elif command -v python3 &>/dev/null; then
        python_cmd="python3"
      fi
      
      if [[ -n "$persona_helper" && -f "$persona_helper" && -n "$python_cmd" ]]; then
        # Get day of week for workout variety
        local day_of_week=$($date_cmd +"%A")
        local full_date=$($date_cmd +"%B %d, %Y")
        
        # Create special dip bar workout prompt
        local dipbar_prompt=$(printf "I just mentioned dip bars, dips, or parallel bars for the first time today! Today is %s, %s.

Please provide me with a complete dip bar and bodyweight workout for today. Make it:
- Challenging but achievable
- Varied and interesting
- Include exercises like dips (chest dips, tricep dips, weighted dips), leg raises, L-sits, muscle-ups, bar support holds, dip bar rows, knee raises, hanging leg raises, Russian dips, Bulgarian dips, and dip bar core exercises
- Clear instructions with rep counts, sets, progression levels, and rest periods
- Explain proper form, grip positions, and safety tips
- Motivating and encouraging

Give me a complete workout I can do right now with dip bars. Be enthusiastic and celebrate my commitment to training!" "$day_of_week" "$full_date")
        
        # Call dip bar coach
        local dipbar_output
        dipbar_output=$("$python_cmd" "$persona_helper" "dipbar" "$dipbar_prompt" "dipbar_workout" 2>&1)
        
        if [[ -n "$dipbar_output" ]]; then
          echo "$dipbar_output"
          echo ""
          
          # Append workout to daily log for easy reference
          echo "" >> "$log_file" || true
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ" >> "$log_file" || true
          echo "üí™ DIP BAR WORKOUT - ${day_of_week}, ${full_date}" >> "$log_file" || true
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ" >> "$log_file" || true
          echo "" >> "$log_file" || true
          echo "$dipbar_output" >> "$log_file" || true
          echo "" >> "$log_file" || true
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ" >> "$log_file" || true
          echo "" >> "$log_file" || true
        fi
      else
        echo "‚ö†Ô∏è  Could not find persona helper or python3 for dip bar coach"
        # Remove flag file if we couldn't add workout
        rm -f "$dipbar_flag_file" 2>/dev/null || true
      fi
      
      echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
      echo ""
    fi
  fi
  
  # Get advice from LM Studio
  if [[ -n "$helper_script" && -f "$helper_script" ]]; then
    # Find python3 - try multiple methods (check file paths first for reliability)
    local python_cmd=""
    # First try homebrew python (most common on Mac)
    if [[ -f "/opt/homebrew/bin/python3" ]]; then
      python_cmd="/opt/homebrew/bin/python3"
    # Then try mise python directory
    elif command -v mise &>/dev/null; then
      local mise_python_path
      mise_python_path=$(mise which python 2>/dev/null)
      if [[ -n "$mise_python_path" ]]; then
        # Get directory from python path and check for python3
        local mise_python_dir="${mise_python_path%/*}"
        if [[ -f "$mise_python_dir/python3" ]]; then
          python_cmd="$mise_python_dir/python3"
        fi
      fi
      # Fallback to known mise path
      if [[ -z "$python_cmd" && -f "$HOME/.local/share/mise/installs/python/3.14.0/bin/python3" ]]; then
        python_cmd="$HOME/.local/share/mise/installs/python/3.14.0/bin/python3"
      fi
    fi
    # Final fallback to command lookup
    if [[ -z "$python_cmd" ]] && command -v python3 &>/dev/null; then
      python_cmd="python3"
    fi
    
    if [[ -z "$python_cmd" ]]; then
      echo "‚ö†Ô∏è  Could not find python3. Please install Python or ensure mise is configured."
      return 1
    fi
    
    # Intelligent persona selection based on log entry content
    # Read the full log content for better context matching
    local log_content_for_matching=""
    if [[ -f "$log_file" ]]; then
      log_content_for_matching=$(cat "$log_file" 2>/dev/null)
    fi
    # Combine log entry with full log content for matching
    local combined_content="${log_entry} ${log_content_for_matching}"
    
    # Define keyword patterns for each expertise area
    # Format: persona_key|keyword_pattern
    typeset -A persona_keywords
    persona_keywords["goggins"]="workout|exercise|fitness|gym|weight|lifting|strength training|cardio workout|endurance workout|mental toughness|stay hard|callous your mind|who's gonna carry the boats|physical limits|body limits|ultramarathon|endurance training|leg day|chest day|back day|shoulder day|arm day|workout session|fitness training|gym session|lifting session|physical training|PT session|fitness motivation|push your limits|break through barriers|physical barriers|body building|muscle building|powerlifting|crossfit|HIIT|high intensity|fitness challenge|physical challenge|fitness goal|training goal|bench press|squat|deadlift|barbell|dumbbell|kettlebell|pull up|push up|fitness routine|exercise routine|workout routine|training program|fitness program|muscle|muscle group|reps|sets|personal trainer|fitness coach|gym workout|home workout|strength workout"
    persona_keywords["dean"]="marathon|ultra|ultramarathon|endurance|race|running race|jog|jogging|running workout|training run|long run|running pace|running form|running distance|ultra distance|endurance running|running miles|running km|ultra running|endurance race|50k|50 mile|100k|100 mile|trail running|road race"
    persona_keywords["bioneer"]="workout|exercise|fitness|training|strength|movement|mobility|functional|form|technique|biomechanics|program|routine|muscle|muscle group"
    persona_keywords["david"]="project|goal|task|inbox|process|organize|gtd|getting things done|next action|context|review|weekly|system|workflow|area|someday|waiting"
    persona_keywords["cal"]="focus|distraction|deep work|concentration|flow|interruption|phone|social media|notification|attention|productivity|flow state|distracted|can't focus|interrupt"
    persona_keywords["james"]="habit|routine|system|atomic|incremental|progress|track|consistency|behavior|pattern|daily|repeat|build habit|form habit|stuck with habit"
    persona_keywords["marie"]="clutter|organize|declutter|spark joy|tidy|clean|minimal|simplify|stuff|things|belongings|space|messy|disorganized|too much stuff"
    persona_keywords["warren"]="strategy|priority|prioritize|important|urgent|decision|invest|long term|value|focus|opportunity|business|plan|planning|strategic"
    persona_keywords["sheryl"]="leadership|execute|execution|team|manage|lead|action|get things done|efficient|productivity|results|delegate|coordinate"
    persona_keywords["tim"]="optimize|optimization|hack|system|experiment|test|trial|improve|efficiency|life hack|productivity tip|experiment|trial|test"
    persona_keywords["bob"]="creative|art|paint|calm|stress|anxiety|peace|relax|breathe|joy|happy accident|mistake|process|meditation|mindful"
    persona_keywords["fred"]="kind|self-care|self care|worth|value|overwhelmed|emotional|support|care|gentle|compassion|love yourself|feeling|feelings|sad|depressed"
    persona_keywords["louiza"]="procrastinate|stuck|accountability|slacking|discipline|tracking|log|record|complete|done|finished|consequence|missed|failed|didn't do"
    persona_keywords["esther"]="relationship|partner|intimacy|connection|communicate|date|romance|love|couple|together|relationship advice"
    persona_keywords["gottman"]="relationship|partner|couple|marriage|communication|conflict|fight|argument|resolve|together|love language"
    persona_keywords["gary"]="love language|partner|relationship|affection|touch|service|gift|time|words|appreciation|express love"
    persona_keywords["brene"]="vulnerability|courage|connection|authentic|brave|shame|worth|belonging|daring|show up|present"
    persona_keywords["romance"]="date|romantic|surprise|gesture|massage|backrub|special|treat|appreciate|show love|make feel special"
    persona_keywords["kelsey"]="code|programming|software|engineering|overengineer|simple|ship|deploy|infrastructure|sre|system|tech"
    persona_keywords["kent"]="code|programming|software|tdd|test|yagni|simple|refactor|design|pattern|architecture|engineering"
    persona_keywords["charity"]="code|programming|software|observability|reliability|monitoring|sre|engineering|system|production|tech"
    persona_keywords["rich"]="code|programming|software|design|architecture|complexity|simple|clojure|system|engineering|tech"
    persona_keywords["spiderman"]="creative|problem|solve|challenge|stuck|juggling|balance|responsibility|creative solution|think outside"
    persona_keywords["ironman"]="creative|innovation|engineering|adhd|hyperfocus|system|build|create|invent|tech|project"
    persona_keywords["squirrelgirl"]="creative|positive|optimistic|problem|solve|communication|unconventional|think different|creative solution"
    persona_keywords["harley"]="creative|chaos|unconventional|think outside|creative solution|problem|solve|different|unique"
    persona_keywords["deadpool"]="creative|humor|funny|chaos|unconventional|problem|solve|think different|creative solution"
    persona_keywords["rogue"]="creative|adapt|overwhelmed|control|problem|solve|creative solution|think different|unique"
    
    # Score each persona based on keyword matches
    typeset -A persona_scores
    typeset -A persona_match_counts
    local max_score=0
    local best_personas=()
    
    # Score fitness coaches first (they have priority for fitness topics)
    # Use ripgrep (rg) if available, fallback to grep with full path
    local use_rg=false
    if command -v rg &>/dev/null; then
      use_rg=true
    fi
    local search_cmd=""
    if [[ "$use_rg" == true ]]; then
      search_cmd="rg"
    else
      search_cmd="/usr/bin/grep"
      [[ ! -f "$search_cmd" ]] && search_cmd="grep"
    fi
    local fitness_coaches=("goggins" "dean" "bioneer")
    for persona in "${fitness_coaches[@]}"; do
      local score=0
      local match_count=0
      # Count actual keyword matches for confidence scoring
      local matches_output=""
      if [[ "$use_rg" == true ]]; then
        matches_output=$(echo "$combined_content" | "$search_cmd" -oiE "${persona_keywords[$persona]}" 2>/dev/null)
      else
        matches_output=$(echo "$combined_content" | "$search_cmd" -oiE "${persona_keywords[$persona]}" 2>/dev/null)
      fi
      if [[ -n "$matches_output" ]]; then
        match_count=$(echo "$matches_output" | wc -l | tr -d ' ')
      fi
      # Fitness coaches need at least 2 matches for confidence (prevents false positives)
      if [[ $match_count -ge 2 ]]; then
        score=$((match_count * 2))  # Weight matches, but require multiple for confidence
      elif [[ $match_count -eq 1 ]]; then
        score=1  # Single match gets low score (likely false positive)
      fi
      persona_scores[$persona]=$score
      persona_match_counts[$persona]=$match_count
      if [[ $score -gt $max_score ]]; then
        max_score=$score
        best_personas=("$persona")
      elif [[ $score -eq $max_score && $score -gt 0 ]]; then
        best_personas+=("$persona")
      fi
    done
    
    # Score other personas
    local other_personas=("hank" "david" "cal" "james" "marie" "warren" "sheryl" "tim" "george" "john" "jon" "bob" "fred" "louiza" "spiderman" "ironman" "squirrelgirl" "harley" "deadpool" "rogue" "esther" "gottman" "gary" "brene" "romance" "kelsey" "kent" "charity" "rich")
    for persona in "${other_personas[@]}"; do
      local score=0
      local match_count=0
      # Count actual keyword matches
      local matches_output=""
      if [[ "$use_rg" == true ]]; then
        matches_output=$(echo "$combined_content" | "$search_cmd" -oiE "${persona_keywords[$persona]}" 2>/dev/null)
      else
        matches_output=$(echo "$combined_content" | "$search_cmd" -oiE "${persona_keywords[$persona]}" 2>/dev/null)
      fi
      if [[ -n "$matches_output" ]]; then
        match_count=$(echo "$matches_output" | wc -l | tr -d ' ')
      fi
      if [[ $match_count -gt 0 ]]; then
        score=$match_count
      fi
      persona_scores[$persona]=$score
      persona_match_counts[$persona]=$match_count
      if [[ $score -gt $max_score ]]; then
        max_score=$score
        best_personas=("$persona")
      elif [[ $score -eq $max_score && $score -gt 0 ]]; then
        best_personas+=("$persona")
      fi
    done
    
    # Select persona: use best match if found with sufficient confidence, otherwise fallback to random from general pool
    local selected_persona=""
    local confidence_threshold=2  # Minimum confidence score required for fitness coaches
    local general_threshold=1     # Minimum confidence score for other personas
    
    if [[ ${#best_personas[@]} -gt 0 && $max_score -gt 0 ]]; then
      # Check confidence threshold - filter out low-confidence matches
      local confident_personas=()
      for persona in "${best_personas[@]}"; do
        local is_fitness=false
        for fit_persona in "${fitness_coaches[@]}"; do
          if [[ "$persona" == "$fit_persona" ]]; then
            is_fitness=true
            break
          fi
        done
        
        # Fitness coaches need higher confidence (at least 2 matches = score 4)
        if [[ "$is_fitness" == true ]]; then
          if [[ ${persona_scores[$persona]} -ge 4 ]]; then  # 2+ matches * 2 = 4+
            confident_personas+=("$persona")
          fi
        else
          # Other personas need at least 1 match
          if [[ ${persona_scores[$persona]} -ge $general_threshold ]]; then
            confident_personas+=("$persona")
          fi
        fi
      done
      
      # Use confident personas if available, otherwise fall back to general pool
      if [[ ${#confident_personas[@]} -gt 0 ]]; then
        local best_count=${#confident_personas[@]}
        local random_index=$((RANDOM % best_count))
        selected_persona="${confident_personas[$random_index]}"
      else
        # Confidence too low - use general productivity coaches
        local general_personas=("hank" "david" "cal" "james" "marie" "warren" "sheryl" "tim" "bob" "fred" "louiza")
        local general_count=${#general_personas[@]}
        local random_index=$((RANDOM % general_count))
        selected_persona="${general_personas[$random_index]}"
      fi
    else
      # No clear match - use general productivity coaches (not fitness-specific)
      local general_personas=("hank" "david" "cal" "james" "marie" "warren" "sheryl" "tim" "bob" "fred" "louiza")
      local general_count=${#general_personas[@]}
      local random_index=$((RANDOM % general_count))
      selected_persona="${general_personas[$random_index]}"
    fi
    
    # Check if selected persona is a comic book character
    local comic_book_characters=("spiderman" "ironman" "squirrelgirl" "harley" "deadpool" "rogue")
    local is_comic_character=false
    for comic in "${comic_book_characters[@]}"; do
      if [[ "$selected_persona" == "$comic" ]]; then
        is_comic_character=true
        break
      fi
    done
    
    # Sometimes have a comic book character make a brief appearance before the main coach
    # (30% chance, but only if main coach is NOT already a comic book character)
    # Select hero based on topic relevance if possible
    local hero_brief_appearance=""
    local hero_name=""
    if [[ "$is_comic_character" == false ]]; then
      local hero_chance=$((RANDOM % 10))  # 0-9, so 30% chance (when < 3)
      if [[ $hero_chance -lt 3 ]]; then
        # Find heroes whose keywords match the log content
        local matching_heroes=()
        for hero in "${comic_book_characters[@]}"; do
          if [[ "$use_rg" == true ]]; then
            if echo "$combined_content" | "$search_cmd" -qiE "${persona_keywords[$hero]}" 2>/dev/null; then
              matching_heroes+=("$hero")
            fi
          else
            if echo "$combined_content" | "$search_cmd" -qiE "${persona_keywords[$hero]}"; then
              matching_heroes+=("$hero")
            fi
          fi
        done
        
        # If we have matching heroes, randomly pick one; otherwise pick randomly from all
        if [[ ${#matching_heroes[@]} -gt 0 ]]; then
          local matching_count=${#matching_heroes[@]}
          local hero_index=$((RANDOM % matching_count))
          hero_brief_appearance="${matching_heroes[$hero_index]}"
        else
          # No matches, randomly select any hero
          local hero_count=${#comic_book_characters[@]}
          local hero_index=$((RANDOM % hero_count))
          hero_brief_appearance="${comic_book_characters[$hero_index]}"
        fi
        
        case "$hero_brief_appearance" in
          spiderman) hero_name="Spider-Man" ;;
          ironman) hero_name="Iron Man" ;;
          squirrelgirl) hero_name="Squirrel Girl" ;;
          harley) hero_name="Harley Quinn" ;;
          deadpool) hero_name="Deadpool" ;;
          rogue) hero_name="Rogue" ;;
        esac
      fi
    fi
    
    # Get persona name for display
    local persona_name=""
    case "$selected_persona" in
      hank) persona_name="Hank Hill" ;;
      david) persona_name="David Allen" ;;
      cal) persona_name="Cal Newport" ;;
      james) persona_name="James Clear" ;;
      marie) persona_name="Marie Kondo" ;;
      warren) persona_name="Warren Buffett" ;;
      sheryl) persona_name="Sheryl Sandberg" ;;
      tim) persona_name="Tim Ferriss" ;;
      george) persona_name="George Carlin" ;;
      john) persona_name="John Oliver" ;;
      jon) persona_name="Jon Stewart" ;;
      bob) persona_name="Bob Ross" ;;
      fred) persona_name="Fred Rogers" ;;
      louiza) persona_name="Mistress Louiza" ;;
      spiderman) persona_name="Spider-Man" ;;
      ironman) persona_name="Iron Man" ;;
      squirrelgirl) persona_name="Squirrel Girl" ;;
      harley) persona_name="Harley Quinn" ;;
      deadpool) persona_name="Deadpool" ;;
      rogue) persona_name="Rogue" ;;
      esther) persona_name="Esther Perel" ;;
      gottman) persona_name="Dr. John Gottman" ;;
      gary) persona_name="Gary Chapman" ;;
      brene) persona_name="Bren√© Brown" ;;
      romance) persona_name="The Romance Coach" ;;
      kettlebell) persona_name="Kettlebell Coach" ;;
      maxfit) persona_name="Maxfit Pro Coach" ;;
      dumbbell) persona_name="Dumbbell Coach" ;;
      dipbar) persona_name="Dip Bar Coach" ;;
      kelsey) persona_name="Kelsey Hightower" ;;
      kent) persona_name="Kent Beck" ;;
      charity) persona_name="Charity Majors" ;;
      rich) persona_name="Rich Hickey" ;;
      goggins) persona_name="David Goggins" ;;
      dean) persona_name="Dean Karnazes" ;;
      bioneer) persona_name="The Bioneer (Adam)" ;;
      *) persona_name="Hank Hill" ;;
    esac
    
    # Use the persona helper instead of the old lmstudio_helper
    local persona_helper=""
    local possible_persona_paths=(
      "$HOME/code/personal/dotfiles/zsh/functions/gtd_persona_helper.py"
      "${(%):-%x:h}/functions/gtd_persona_helper.py"
    )
    
    for path in "${possible_persona_paths[@]}"; do
      if [[ -f "$path" ]]; then
        persona_helper="$path"
        break
      fi
    done
    
    local advice_output
    if [[ -n "$persona_helper" && -f "$persona_helper" ]]; then
      # Use persona helper with the log content
      # Format: persona, content, context
      # Read the log file (it should exist since we just wrote to it)
      local log_content=""
      if [[ -f "$log_file" ]]; then
        log_content=$(cat "$log_file" 2>/dev/null)
      fi
      
      # Get user name from config for prompt clarity
      local user_name="Abby"  # Default
      local gtd_config_file="$HOME/.gtd_config"
      if [[ ! -f "$gtd_config_file" && -f "$HOME/code/personal/dotfiles/zsh/.gtd_config" ]]; then
        gtd_config_file="$HOME/code/personal/dotfiles/zsh/.gtd_config"
      fi
      if [[ ! -f "$gtd_config_file" && -f "$HOME/code/dotfiles/zsh/.gtd_config" ]]; then
        gtd_config_file="$HOME/code/dotfiles/zsh/.gtd_config"
      fi
      if [[ -f "$gtd_config_file" ]]; then
        # Read GTD_USER_NAME or NAME from config - handle bash variable substitution format
        # Use grep -m 1 instead of head to avoid PATH issues
        local name_line=$(grep -m 1 -E "^GTD_USER_NAME=|^NAME=" "$gtd_config_file" 2>/dev/null)
        if [[ -n "$name_line" ]]; then
          # Extract value after =, handling quotes and variable substitution
          local name_value=$(echo "$name_line" | cut -d'=' -f2- | sed 's/^["'\'']*//; s/["'\'']*$//')
          # If it has ${GTD_USER_NAME:-default} or ${NAME:-default} format, extract the default value
          if echo "$name_value" | grep -qE '\$\{GTD_USER_NAME:-|\$\{NAME:-'; then
            # Extract the default value from ${VAR:-default} format
            user_name=$(echo "$name_value" | sed -E 's/.*\$\{[^:]+:-([^}]+)\}.*/\1/')
          elif [[ -n "$name_value" && "$name_value" != "\${GTD_USER_NAME:-Abby}" && "$name_value" != '${GTD_USER_NAME:-Abby}' ]]; then
            user_name="$name_value"
          fi
          user_name=$(echo "$user_name" | xargs)  # trim whitespace
        fi
      fi
      # Use environment variable if set (takes precedence)
      if [[ -n "$GTD_USER_NAME" ]]; then
        user_name="$GTD_USER_NAME"
      fi
      
      # Create prompt with log content
      if [[ -n "$log_content" ]]; then
        # Get current day of week and date for context
        local day_of_week=$($date_cmd +"%A")
        local full_date=$($date_cmd +"%B %d, %Y")
        
        # Use printf to properly format with newlines
        local prompt_text=$(printf "This is %s's daily log. You are providing advice to %s (the person writing this log).

CRITICAL: If the log mentions other people's names (colleagues, friends, recipients), those are OTHER PEOPLE - NOT %s. %s is the person writing the log, not anyone mentioned in it.

Today is %s, %s. Please be aware of the current day and date when providing advice.

Here is %s's complete daily log so far:

%s

%s just added this new entry: %s

Please review the log entries above and provide specific, actionable advice to %s based on what you see. Reference specific items from the log in your response. Remember: today is %s, and you are speaking to %s, not to anyone else mentioned in the log." "$user_name" "$user_name" "$user_name" "$user_name" "$day_of_week" "$full_date" "$user_name" "$log_content" "$user_name" "$log_entry" "$user_name" "$day_of_week" "$user_name")
      else
        # Log file doesn't exist or is empty
        # Get current day of week and date for context
        local day_of_week=$($date_cmd +"%A")
        local full_date=$($date_cmd +"%B %d, %Y")
        local prompt_text="This is ${user_name}'s daily log. You are providing advice to ${user_name} (the person writing this log). IMPORTANT: Today is ${day_of_week}, ${full_date}. ${user_name} just added a new entry to the daily log: ${log_entry}. Please provide advice to ${user_name}. Remember: today is ${day_of_week}. If the entry mentions other people's names, those are OTHER PEOPLE - you are speaking to ${user_name}, not anyone mentioned in the log."
      fi
      
      # If a comic book hero is making a brief appearance, call them first
      local hero_comment=""
      if [[ -n "$hero_brief_appearance" ]]; then
        # Create a brief prompt for the hero - they MUST give actual advice first, then leave
        local hero_prompt="You're making a BRIEF appearance. You MUST FIRST provide actual helpful advice (2-3 sentences) about the problem in the log entry - give real, actionable insight based on your expertise. THEN excuse yourself because you need to save someone. Format: [Your actual helpful advice] ... [Then your exit line]. DO NOT just leave immediately - you must give advice first! Here's the context: ${prompt_text}"
        hero_comment=$("$python_cmd" "$persona_helper" "$hero_brief_appearance" "$hero_prompt" "hero_brief_appearance" 2>&1)
      fi
      
      # ALWAYS call the main coach - they provide the full, detailed advice
      # If a hero appeared, the main coach should acknowledge it briefly but provide comprehensive advice
      local main_prompt="$prompt_text"
      if [[ -n "$hero_brief_appearance" ]]; then
        main_prompt="A superhero just made a brief appearance and had to leave. Now provide your FULL, COMPREHENSIVE advice about the log entry. Give detailed, actionable guidance. ${prompt_text}"
      fi
      
      # Validate selected_persona is not empty before calling
      if [[ -z "$selected_persona" ]]; then
        echo "‚ö†Ô∏è  Error: Could not determine which persona to use. Defaulting to 'hank'." >&2
        selected_persona="hank"
      fi
      
      # Pass the prompt text to the persona helper for the main coach
      # The content will be passed as a single argument, preserving newlines
      # Use printf to ensure proper quoting of the prompt
      advice_output=$("$python_cmd" "$persona_helper" "$selected_persona" "$(printf '%s' "$main_prompt")" "daily_log_review" 2>&1)
      
      # Combine hero comment with main advice if hero appeared
      if [[ -n "$hero_brief_appearance" && -n "$hero_comment" ]]; then
        # Check if hero comment has errors
        # Use ripgrep if available, otherwise grep (search_cmd already defined earlier)
        local has_error=false
        if [[ "$use_rg" == true ]]; then
          if echo "$hero_comment" | "$search_cmd" -qiE "error|‚ö†Ô∏è|timed out|Could not connect" 2>/dev/null; then
            has_error=true
          fi
        else
          if echo "$hero_comment" | "$search_cmd" -qiE "error|‚ö†Ô∏è|timed out|Could not connect"; then
            has_error=true
          fi
        fi
        if [[ "$has_error" == false ]]; then
          advice_output="${hero_comment}

${advice_output}"
        fi
      fi
    else
      # Fallback to old helper
      echo ""
      echo "ü§ñ Getting advice from $persona_name..."
      echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
      advice_output=$("$python_cmd" "$helper_script" "$log_file" 2>&1)
    fi
    local exit_code=$?
    
    if [[ -n "$persona_helper" && -f "$persona_helper" ]]; then
      # Persona helper already formats output, just show it
      if [[ $exit_code -eq 0 && -n "$advice_output" ]]; then
        echo "$advice_output"
      else
        echo ""
        echo "‚ö†Ô∏è  Could not connect to LM Studio. Make sure it's running at $lm_url"
        [[ -n "$advice_output" ]] && echo "Error details: $advice_output" >&2
      fi
    else
      # Old helper format
      if [[ $exit_code -eq 0 && -n "$advice_output" ]]; then
        echo "$advice_output"
      else
        echo "‚ö†Ô∏è  Could not connect to LM Studio. Make sure it's running at $lm_url"
        [[ -n "$advice_output" ]] && echo "Error details: $advice_output" >&2
      fi
      echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
    fi
  else
    echo "‚ö†Ô∏è  Helper script not found. Expected at: $HOME/code/personal/dotfiles/zsh/functions/lmstudio_helper.py"
  fi
}

# Added by LM Studio CLI (lms)
export PATH="$PATH:/Users/abby/.lmstudio/bin"
# End of LM Studio CLI section

# ============================================
# GTD Quick Aliases & Functions
# ============================================
if [[ -f "$HOME/code/dotfiles/zsh/gtd-aliases.zsh" ]]; then
  source "$HOME/code/dotfiles/zsh/gtd-aliases.zsh"
elif [[ -f "$HOME/code/personal/dotfiles/zsh/gtd-aliases.zsh" ]]; then
  source "$HOME/code/personal/dotfiles/zsh/gtd-aliases.zsh"
fi
